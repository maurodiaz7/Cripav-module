{"version":3,"file":"vendors-node_modules_d3-lasso_build_d3-lasso_js.6efd642ec237afa7a7c2.js","mappings":";;;;;;;;AAAA;AACA,IAAI,KAA4D,oBAAoB,mBAAO,CAAC,8DAAc,GAAG,mBAAO,CAAC,oDAAS;AAC9H,IAAI,CAC4D;AAChE,CAAC,+CAA+C;;AAEhD;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA,qBAAqB,KAAK;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,+CAA+C;AAC7G,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC,UAAU;AAC1C,gCAAgC,UAAU;AAC1C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB,uBAAuB;AACpG;AACA,mBAAmB,eAAe;AAClC,+EAA+E;AAC/E;AACA,kBAAkB,kCAAkC,YAAY,mBAAmB,KAAK,mBAAmB,gBAAgB;AAC3H;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB,oBAAoB;;AAExD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA,mDAAmD,aAAa;;AAEhE,CAAC","sources":["webpack://jupyter_d3_widget/./node_modules/d3-lasso/build/d3-lasso.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-drag')) :\n    typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-drag'], factory) :\n    (factory((global.d3 = global.d3 || {}),global.d3,global.d3));\n}(this, function (exports,d3Selection,d3Drag) { 'use strict';\n\n    function createCommonjsModule(fn, module) {\n    \treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n    }\n\n    var __moduleExports$1 = createCommonjsModule(function (module) {\n    \"use strict\"\n\n    module.exports = twoProduct\n\n    var SPLITTER = +(Math.pow(2, 27) + 1.0)\n\n    function twoProduct(a, b, result) {\n      var x = a * b\n\n      var c = SPLITTER * a\n      var abig = c - a\n      var ahi = c - abig\n      var alo = a - ahi\n\n      var d = SPLITTER * b\n      var bbig = d - b\n      var bhi = d - bbig\n      var blo = b - bhi\n\n      var err1 = x - (ahi * bhi)\n      var err2 = err1 - (alo * bhi)\n      var err3 = err2 - (ahi * blo)\n\n      var y = alo * blo - err3\n\n      if(result) {\n        result[0] = y\n        result[1] = x\n        return result\n      }\n\n      return [ y, x ]\n    }\n    });\n\n    var __moduleExports$2 = createCommonjsModule(function (module) {\n    \"use strict\"\n\n    module.exports = linearExpansionSum\n\n    //Easy case: Add two scalars\n    function scalarScalar(a, b) {\n      var x = a + b\n      var bv = x - a\n      var av = x - bv\n      var br = b - bv\n      var ar = a - av\n      var y = ar + br\n      if(y) {\n        return [y, x]\n      }\n      return [x]\n    }\n\n    function linearExpansionSum(e, f) {\n      var ne = e.length|0\n      var nf = f.length|0\n      if(ne === 1 && nf === 1) {\n        return scalarScalar(e[0], f[0])\n      }\n      var n = ne + nf\n      var g = new Array(n)\n      var count = 0\n      var eptr = 0\n      var fptr = 0\n      var abs = Math.abs\n      var ei = e[eptr]\n      var ea = abs(ei)\n      var fi = f[fptr]\n      var fa = abs(fi)\n      var a, b\n      if(ea < fa) {\n        b = ei\n        eptr += 1\n        if(eptr < ne) {\n          ei = e[eptr]\n          ea = abs(ei)\n        }\n      } else {\n        b = fi\n        fptr += 1\n        if(fptr < nf) {\n          fi = f[fptr]\n          fa = abs(fi)\n        }\n      }\n      if((eptr < ne && ea < fa) || (fptr >= nf)) {\n        a = ei\n        eptr += 1\n        if(eptr < ne) {\n          ei = e[eptr]\n          ea = abs(ei)\n        }\n      } else {\n        a = fi\n        fptr += 1\n        if(fptr < nf) {\n          fi = f[fptr]\n          fa = abs(fi)\n        }\n      }\n      var x = a + b\n      var bv = x - a\n      var y = b - bv\n      var q0 = y\n      var q1 = x\n      var _x, _bv, _av, _br, _ar\n      while(eptr < ne && fptr < nf) {\n        if(ea < fa) {\n          a = ei\n          eptr += 1\n          if(eptr < ne) {\n            ei = e[eptr]\n            ea = abs(ei)\n          }\n        } else {\n          a = fi\n          fptr += 1\n          if(fptr < nf) {\n            fi = f[fptr]\n            fa = abs(fi)\n          }\n        }\n        b = q0\n        x = a + b\n        bv = x - a\n        y = b - bv\n        if(y) {\n          g[count++] = y\n        }\n        _x = q1 + x\n        _bv = _x - q1\n        _av = _x - _bv\n        _br = x - _bv\n        _ar = q1 - _av\n        q0 = _ar + _br\n        q1 = _x\n      }\n      while(eptr < ne) {\n        a = ei\n        b = q0\n        x = a + b\n        bv = x - a\n        y = b - bv\n        if(y) {\n          g[count++] = y\n        }\n        _x = q1 + x\n        _bv = _x - q1\n        _av = _x - _bv\n        _br = x - _bv\n        _ar = q1 - _av\n        q0 = _ar + _br\n        q1 = _x\n        eptr += 1\n        if(eptr < ne) {\n          ei = e[eptr]\n        }\n      }\n      while(fptr < nf) {\n        a = fi\n        b = q0\n        x = a + b\n        bv = x - a\n        y = b - bv\n        if(y) {\n          g[count++] = y\n        } \n        _x = q1 + x\n        _bv = _x - q1\n        _av = _x - _bv\n        _br = x - _bv\n        _ar = q1 - _av\n        q0 = _ar + _br\n        q1 = _x\n        fptr += 1\n        if(fptr < nf) {\n          fi = f[fptr]\n        }\n      }\n      if(q0) {\n        g[count++] = q0\n      }\n      if(q1) {\n        g[count++] = q1\n      }\n      if(!count) {\n        g[count++] = 0.0  \n      }\n      g.length = count\n      return g\n    }\n    });\n\n    var __moduleExports$4 = createCommonjsModule(function (module) {\n    \"use strict\"\n\n    module.exports = fastTwoSum\n\n    function fastTwoSum(a, b, result) {\n    \tvar x = a + b\n    \tvar bv = x - a\n    \tvar av = x - bv\n    \tvar br = b - bv\n    \tvar ar = a - av\n    \tif(result) {\n    \t\tresult[0] = ar + br\n    \t\tresult[1] = x\n    \t\treturn result\n    \t}\n    \treturn [ar+br, x]\n    }\n    });\n\n    var __moduleExports$3 = createCommonjsModule(function (module) {\n    \"use strict\"\n\n    var twoProduct = __moduleExports$1\n    var twoSum = __moduleExports$4\n\n    module.exports = scaleLinearExpansion\n\n    function scaleLinearExpansion(e, scale) {\n      var n = e.length\n      if(n === 1) {\n        var ts = twoProduct(e[0], scale)\n        if(ts[0]) {\n          return ts\n        }\n        return [ ts[1] ]\n      }\n      var g = new Array(2 * n)\n      var q = [0.1, 0.1]\n      var t = [0.1, 0.1]\n      var count = 0\n      twoProduct(e[0], scale, q)\n      if(q[0]) {\n        g[count++] = q[0]\n      }\n      for(var i=1; i<n; ++i) {\n        twoProduct(e[i], scale, t)\n        var pq = q[1]\n        twoSum(pq, t[0], q)\n        if(q[0]) {\n          g[count++] = q[0]\n        }\n        var a = t[1]\n        var b = q[1]\n        var x = a + b\n        var bv = x - a\n        var y = b - bv\n        q[1] = x\n        if(y) {\n          g[count++] = y\n        }\n      }\n      if(q[1]) {\n        g[count++] = q[1]\n      }\n      if(count === 0) {\n        g[count++] = 0.0\n      }\n      g.length = count\n      return g\n    }\n    });\n\n    var __moduleExports$5 = createCommonjsModule(function (module) {\n    \"use strict\"\n\n    module.exports = robustSubtract\n\n    //Easy case: Add two scalars\n    function scalarScalar(a, b) {\n      var x = a + b\n      var bv = x - a\n      var av = x - bv\n      var br = b - bv\n      var ar = a - av\n      var y = ar + br\n      if(y) {\n        return [y, x]\n      }\n      return [x]\n    }\n\n    function robustSubtract(e, f) {\n      var ne = e.length|0\n      var nf = f.length|0\n      if(ne === 1 && nf === 1) {\n        return scalarScalar(e[0], -f[0])\n      }\n      var n = ne + nf\n      var g = new Array(n)\n      var count = 0\n      var eptr = 0\n      var fptr = 0\n      var abs = Math.abs\n      var ei = e[eptr]\n      var ea = abs(ei)\n      var fi = -f[fptr]\n      var fa = abs(fi)\n      var a, b\n      if(ea < fa) {\n        b = ei\n        eptr += 1\n        if(eptr < ne) {\n          ei = e[eptr]\n          ea = abs(ei)\n        }\n      } else {\n        b = fi\n        fptr += 1\n        if(fptr < nf) {\n          fi = -f[fptr]\n          fa = abs(fi)\n        }\n      }\n      if((eptr < ne && ea < fa) || (fptr >= nf)) {\n        a = ei\n        eptr += 1\n        if(eptr < ne) {\n          ei = e[eptr]\n          ea = abs(ei)\n        }\n      } else {\n        a = fi\n        fptr += 1\n        if(fptr < nf) {\n          fi = -f[fptr]\n          fa = abs(fi)\n        }\n      }\n      var x = a + b\n      var bv = x - a\n      var y = b - bv\n      var q0 = y\n      var q1 = x\n      var _x, _bv, _av, _br, _ar\n      while(eptr < ne && fptr < nf) {\n        if(ea < fa) {\n          a = ei\n          eptr += 1\n          if(eptr < ne) {\n            ei = e[eptr]\n            ea = abs(ei)\n          }\n        } else {\n          a = fi\n          fptr += 1\n          if(fptr < nf) {\n            fi = -f[fptr]\n            fa = abs(fi)\n          }\n        }\n        b = q0\n        x = a + b\n        bv = x - a\n        y = b - bv\n        if(y) {\n          g[count++] = y\n        }\n        _x = q1 + x\n        _bv = _x - q1\n        _av = _x - _bv\n        _br = x - _bv\n        _ar = q1 - _av\n        q0 = _ar + _br\n        q1 = _x\n      }\n      while(eptr < ne) {\n        a = ei\n        b = q0\n        x = a + b\n        bv = x - a\n        y = b - bv\n        if(y) {\n          g[count++] = y\n        }\n        _x = q1 + x\n        _bv = _x - q1\n        _av = _x - _bv\n        _br = x - _bv\n        _ar = q1 - _av\n        q0 = _ar + _br\n        q1 = _x\n        eptr += 1\n        if(eptr < ne) {\n          ei = e[eptr]\n        }\n      }\n      while(fptr < nf) {\n        a = fi\n        b = q0\n        x = a + b\n        bv = x - a\n        y = b - bv\n        if(y) {\n          g[count++] = y\n        } \n        _x = q1 + x\n        _bv = _x - q1\n        _av = _x - _bv\n        _br = x - _bv\n        _ar = q1 - _av\n        q0 = _ar + _br\n        q1 = _x\n        fptr += 1\n        if(fptr < nf) {\n          fi = -f[fptr]\n        }\n      }\n      if(q0) {\n        g[count++] = q0\n      }\n      if(q1) {\n        g[count++] = q1\n      }\n      if(!count) {\n        g[count++] = 0.0  \n      }\n      g.length = count\n      return g\n    }\n    });\n\n    var __moduleExports = createCommonjsModule(function (module) {\n    \"use strict\"\n\n    var twoProduct = __moduleExports$1\n    var robustSum = __moduleExports$2\n    var robustScale = __moduleExports$3\n    var robustSubtract = __moduleExports$5\n\n    var NUM_EXPAND = 5\n\n    var EPSILON     = 1.1102230246251565e-16\n    var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON\n    var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON\n\n    function cofactor(m, c) {\n      var result = new Array(m.length-1)\n      for(var i=1; i<m.length; ++i) {\n        var r = result[i-1] = new Array(m.length-1)\n        for(var j=0,k=0; j<m.length; ++j) {\n          if(j === c) {\n            continue\n          }\n          r[k++] = m[i][j]\n        }\n      }\n      return result\n    }\n\n    function matrix(n) {\n      var result = new Array(n)\n      for(var i=0; i<n; ++i) {\n        result[i] = new Array(n)\n        for(var j=0; j<n; ++j) {\n          result[i][j] = [\"m\", j, \"[\", (n-i-1), \"]\"].join(\"\")\n        }\n      }\n      return result\n    }\n\n    function sign(n) {\n      if(n & 1) {\n        return \"-\"\n      }\n      return \"\"\n    }\n\n    function generateSum(expr) {\n      if(expr.length === 1) {\n        return expr[0]\n      } else if(expr.length === 2) {\n        return [\"sum(\", expr[0], \",\", expr[1], \")\"].join(\"\")\n      } else {\n        var m = expr.length>>1\n        return [\"sum(\", generateSum(expr.slice(0, m)), \",\", generateSum(expr.slice(m)), \")\"].join(\"\")\n      }\n    }\n\n    function determinant(m) {\n      if(m.length === 2) {\n        return [[\"sum(prod(\", m[0][0], \",\", m[1][1], \"),prod(-\", m[0][1], \",\", m[1][0], \"))\"].join(\"\")]\n      } else {\n        var expr = []\n        for(var i=0; i<m.length; ++i) {\n          expr.push([\"scale(\", generateSum(determinant(cofactor(m, i))), \",\", sign(i), m[0][i], \")\"].join(\"\"))\n        }\n        return expr\n      }\n    }\n\n    function orientation(n) {\n      var pos = []\n      var neg = []\n      var m = matrix(n)\n      var args = []\n      for(var i=0; i<n; ++i) {\n        if((i&1)===0) {\n          pos.push.apply(pos, determinant(cofactor(m, i)))\n        } else {\n          neg.push.apply(neg, determinant(cofactor(m, i)))\n        }\n        args.push(\"m\" + i)\n      }\n      var posExpr = generateSum(pos)\n      var negExpr = generateSum(neg)\n      var funcName = \"orientation\" + n + \"Exact\"\n      var code = [\"function \", funcName, \"(\", args.join(), \"){var p=\", posExpr, \",n=\", negExpr, \",d=sub(p,n);\\\nreturn d[d.length-1];};return \", funcName].join(\"\")\n      var proc = new Function(\"sum\", \"prod\", \"scale\", \"sub\", code)\n      return proc(robustSum, twoProduct, robustScale, robustSubtract)\n    }\n\n    var orientation3Exact = orientation(3)\n    var orientation4Exact = orientation(4)\n\n    var CACHED = [\n      function orientation0() { return 0 },\n      function orientation1() { return 0 },\n      function orientation2(a, b) { \n        return b[0] - a[0]\n      },\n      function orientation3(a, b, c) {\n        var l = (a[1] - c[1]) * (b[0] - c[0])\n        var r = (a[0] - c[0]) * (b[1] - c[1])\n        var det = l - r\n        var s\n        if(l > 0) {\n          if(r <= 0) {\n            return det\n          } else {\n            s = l + r\n          }\n        } else if(l < 0) {\n          if(r >= 0) {\n            return det\n          } else {\n            s = -(l + r)\n          }\n        } else {\n          return det\n        }\n        var tol = ERRBOUND3 * s\n        if(det >= tol || det <= -tol) {\n          return det\n        }\n        return orientation3Exact(a, b, c)\n      },\n      function orientation4(a,b,c,d) {\n        var adx = a[0] - d[0]\n        var bdx = b[0] - d[0]\n        var cdx = c[0] - d[0]\n        var ady = a[1] - d[1]\n        var bdy = b[1] - d[1]\n        var cdy = c[1] - d[1]\n        var adz = a[2] - d[2]\n        var bdz = b[2] - d[2]\n        var cdz = c[2] - d[2]\n        var bdxcdy = bdx * cdy\n        var cdxbdy = cdx * bdy\n        var cdxady = cdx * ady\n        var adxcdy = adx * cdy\n        var adxbdy = adx * bdy\n        var bdxady = bdx * ady\n        var det = adz * (bdxcdy - cdxbdy) \n                + bdz * (cdxady - adxcdy)\n                + cdz * (adxbdy - bdxady)\n        var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)\n                      + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)\n                      + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)\n        var tol = ERRBOUND4 * permanent\n        if ((det > tol) || (-det > tol)) {\n          return det\n        }\n        return orientation4Exact(a,b,c,d)\n      }\n    ]\n\n    function slowOrient(args) {\n      var proc = CACHED[args.length]\n      if(!proc) {\n        proc = CACHED[args.length] = orientation(args.length)\n      }\n      return proc.apply(undefined, args)\n    }\n\n    function generateOrientationProc() {\n      while(CACHED.length <= NUM_EXPAND) {\n        CACHED.push(orientation(CACHED.length))\n      }\n      var args = []\n      var procArgs = [\"slow\"]\n      for(var i=0; i<=NUM_EXPAND; ++i) {\n        args.push(\"a\" + i)\n        procArgs.push(\"o\" + i)\n      }\n      var code = [\n        \"function getOrientation(\", args.join(), \"){switch(arguments.length){case 0:case 1:return 0;\"\n      ]\n      for(var i=2; i<=NUM_EXPAND; ++i) {\n        code.push(\"case \", i, \":return o\", i, \"(\", args.slice(0, i).join(), \");\")\n      }\n      code.push(\"}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation\")\n      procArgs.push(code.join(\"\"))\n\n      var proc = Function.apply(undefined, procArgs)\n      module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))\n      for(var i=0; i<=NUM_EXPAND; ++i) {\n        module.exports[i] = CACHED[i]\n      }\n    }\n\n    generateOrientationProc()\n    });\n\n    var robustPnp = createCommonjsModule(function (module) {\n    module.exports = robustPointInPolygon\n\n    var orient = __moduleExports\n\n    function robustPointInPolygon(vs, point) {\n      var x = point[0]\n      var y = point[1]\n      var n = vs.length\n      var inside = 1\n      var lim = n\n      for(var i = 0, j = n-1; i<lim; j=i++) {\n        var a = vs[i]\n        var b = vs[j]\n        var yi = a[1]\n        var yj = b[1]\n        if(yj < yi) {\n          if(yj < y && y < yi) {\n            var s = orient(a, b, point)\n            if(s === 0) {\n              return 0\n            } else {\n              inside ^= (0 < s)|0\n            }\n          } else if(y === yi) {\n            var c = vs[(i+1)%n]\n            var yk = c[1]\n            if(yi < yk) {\n              var s = orient(a, b, point)\n              if(s === 0) {\n                return 0\n              } else {\n                inside ^= (0 < s)|0\n              }\n            }\n          }\n        } else if(yi < yj) {\n          if(yi < y && y < yj) {\n            var s = orient(a, b, point)\n            if(s === 0) {\n              return 0\n            } else {\n              inside ^= (s < 0)|0\n            }\n          } else if(y === yi) {\n            var c = vs[(i+1)%n]\n            var yk = c[1]\n            if(yk < yi) {\n              var s = orient(a, b, point)\n              if(s === 0) {\n                return 0\n              } else {\n                inside ^= (s < 0)|0\n              }\n            }\n          }\n        } else if(y === yi) {\n          var x0 = Math.min(a[0], b[0])\n          var x1 = Math.max(a[0], b[0])\n          if(i === 0) {\n            while(j>0) {\n              var k = (j+n-1)%n\n              var p = vs[k]\n              if(p[1] !== y) {\n                break\n              }\n              var px = p[0]\n              x0 = Math.min(x0, px)\n              x1 = Math.max(x1, px)\n              j = k\n            }\n            if(j === 0) {\n              if(x0 <= x && x <= x1) {\n                return 0\n              }\n              return 1 \n            }\n            lim = j+1\n          }\n          var y0 = vs[(j+n-1)%n][1]\n          while(i+1<lim) {\n            var p = vs[i+1]\n            if(p[1] !== y) {\n              break\n            }\n            var px = p[0]\n            x0 = Math.min(x0, px)\n            x1 = Math.max(x1, px)\n            i += 1\n          }\n          if(x0 <= x && x <= x1) {\n            return 0\n          }\n          var y1 = vs[(i+1)%n][1]\n          if(x < x0 && (y0 < y !== y1 < y)) {\n            inside ^= 1\n          }\n        }\n      }\n      return 2 * inside - 1\n    }\n    });\n\n    function lasso() {\n\n        var items =[],\n            closePathDistance = 75,\n            closePathSelect = true,\n            isPathClosed = false,\n            hoverSelect = true,\n            targetArea,\n            on = {start:function(){}, draw: function(){}, end: function(){}};\n\n        // Function to execute on call\n        function lasso(_this) {\n\n            // add a new group for the lasso\n            var g = _this.append(\"g\")\n                .attr(\"class\",\"lasso\");\n            \n            // add the drawn path for the lasso\n            var dyn_path = g.append(\"path\")\n                .attr(\"class\",\"drawn\");\n            \n            // add a closed path\n            var close_path = g.append(\"path\")\n                .attr(\"class\",\"loop_close\");\n            \n            // add an origin node\n            var origin_node = g.append(\"circle\")\n                .attr(\"class\",\"origin\");\n\n            // The transformed lasso path for rendering\n            var tpath;\n\n            // The lasso origin for calculations\n            var origin;\n\n            // The transformed lasso origin for rendering\n            var torigin;\n\n            // Store off coordinates drawn\n            var drawnCoords;\n\n             // Apply drag behaviors\n            var drag = d3.drag()\n                .on(\"start\",dragstart)\n                .on(\"drag\",dragmove)\n                .on(\"end\",dragend);\n\n            // Call drag\n            targetArea.call(drag);\n\n            function dragstart() {\n                // Init coordinates\n                drawnCoords = [];\n\n                // Initialize paths\n                tpath = \"\";\n                dyn_path.attr(\"d\",null);\n                close_path.attr(\"d\",null);\n\n                // Set every item to have a false selection and reset their center point and counters\n                items.nodes().forEach(function(e) {            \n                    e.__lasso.possible = false;\n                    e.__lasso.selected = false;\n                    e.__lasso.hoverSelect = false;\n                    e.__lasso.loopSelect = false;\n                    \n                    var box = e.getBoundingClientRect();\n                    e.__lasso.lassoPoint = [Math.round(box.left + box.width/2),Math.round(box.top + box.height/2)];\n                });\n\n                // if hover is on, add hover function\n                if(hoverSelect) {\n                    items.on(\"mouseover.lasso\",function() {\n                        // if hovered, change lasso selection attribute to true\n                        this.__lasso.hoverSelect = true;\n                    });\n                }\n\n                // Run user defined start function\n                on.start();\n            }\n\n            function dragmove() {\n                // Get mouse position within body, used for calculations\n                var x,y;\n                if(d3.event.sourceEvent.type === \"touchmove\") {\n                    x = d3.event.sourceEvent.touches[0].clientX;\n                    y = d3.event.sourceEvent.touches[0].clientY;\n                }\n                else {\n                    x = d3.event.sourceEvent.clientX;\n                    y = d3.event.sourceEvent.clientY;\n                }\n                \n\n                // Get mouse position within drawing area, used for rendering\n                var tx = d3.mouse(this)[0];\n                var ty = d3.mouse(this)[1];\n\n                // Initialize the path or add the latest point to it\n                if (tpath===\"\") {\n                    tpath = tpath + \"M \" + tx + \" \" + ty;\n                    origin = [x,y];\n                    torigin = [tx,ty];\n                    // Draw origin node\n                    origin_node\n                        .attr(\"cx\",tx)\n                        .attr(\"cy\",ty)\n                        .attr(\"r\",7)\n                        .attr(\"display\",null);\n                }\n                else {\n                    tpath = tpath + \" L \" + tx + \" \" + ty;\n                }\n\n                drawnCoords.push([x,y]);\n\n                // Calculate the current distance from the lasso origin\n                var distance = Math.sqrt(Math.pow(x-origin[0],2)+Math.pow(y-origin[1],2));\n\n                // Set the closed path line\n                var close_draw_path = \"M \" + tx + \" \" + ty + \" L \" + torigin[0] + \" \" + torigin[1];\n\n                // Draw the lines\n                dyn_path.attr(\"d\",tpath);\n\n                close_path.attr(\"d\",close_draw_path);\n\n                // Check if the path is closed\n                isPathClosed = distance<=closePathDistance ? true : false;\n\n                // If within the closed path distance parameter, show the closed path. otherwise, hide it\n                if(isPathClosed && closePathSelect) {\n                    close_path.attr(\"display\",null);\n                }\n                else {\n                    close_path.attr(\"display\",\"none\");\n                }\n\n                items.nodes().forEach(function(n) {\n                    n.__lasso.loopSelect = (isPathClosed && closePathSelect) ? (robustPnp(drawnCoords,n.__lasso.lassoPoint) < 1) : false; \n                    n.__lasso.possible = n.__lasso.hoverSelect || n.__lasso.loopSelect; \n                });\n\n                on.draw();\n            }\n\n            function dragend() {\n                // Remove mouseover tagging function\n                items.on(\"mouseover.lasso\",null);\n\n                items.nodes().forEach(function(n) {\n                    n.__lasso.selected = n.__lasso.possible;\n                    n.__lasso.possible = false;\n                });\n\n                // Clear lasso\n                dyn_path.attr(\"d\",null);\n                close_path.attr(\"d\",null);\n                origin_node.attr(\"display\",\"none\");\n\n                // Run user defined end function\n                on.end();\n            }\n        }\n\n        // Set or get list of items for lasso to select\n        lasso.items  = function(_) {\n            if (!arguments.length) return items;\n            items = _;\n            var nodes = items.nodes();\n            nodes.forEach(function(n) {\n                n.__lasso = {\n                    \"possible\": false,\n                    \"selected\": false\n                };\n            });\n            return lasso;\n        };\n\n        // Return possible items\n        lasso.possibleItems = function() {\n            return items.filter(function() {\n                return this.__lasso.possible;\n            });\n        }\n\n        // Return selected items\n        lasso.selectedItems = function() {\n            return items.filter(function() {\n                return this.__lasso.selected;\n            });\n        }\n\n        // Return not possible items\n        lasso.notPossibleItems = function() {\n            return items.filter(function() {\n                return !this.__lasso.possible;\n            });\n        }\n\n        // Return not selected items\n        lasso.notSelectedItems = function() {\n            return items.filter(function() {\n                return !this.__lasso.selected;\n            });\n        }\n\n        // Distance required before path auto closes loop\n        lasso.closePathDistance  = function(_) {\n            if (!arguments.length) return closePathDistance;\n            closePathDistance = _;\n            return lasso;\n        };\n\n        // Option to loop select or not\n        lasso.closePathSelect = function(_) {\n            if (!arguments.length) return closePathSelect;\n            closePathSelect = _===true ? true : false;\n            return lasso;\n        };\n\n        // Not sure what this is for\n        lasso.isPathClosed = function(_) {\n            if (!arguments.length) return isPathClosed;\n            isPathClosed = _===true ? true : false;\n            return lasso;\n        };\n\n        // Option to select on hover or not\n        lasso.hoverSelect = function(_) {\n            if (!arguments.length) return hoverSelect;\n            hoverSelect = _===true ? true : false;\n            return lasso;\n        };\n\n        // Events\n        lasso.on = function(type,_) {\n            if(!arguments.length) return on;\n            if(arguments.length===1) return on[type];\n            var types = [\"start\",\"draw\",\"end\"];\n            if(types.indexOf(type)>-1) {\n                on[type] = _;\n            }\n            return lasso;\n        };\n\n        // Area where lasso can be triggered from\n        lasso.targetArea = function(_) {\n            if(!arguments.length) return targetArea;\n            targetArea = _;\n            return lasso;\n        }\n\n\n        \n        return lasso;\n    };\n\n    exports.lasso = lasso;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));"],"names":[],"sourceRoot":""}