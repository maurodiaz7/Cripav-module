(self["webpackChunkjupyter_d3_widget"] = self["webpackChunkjupyter_d3_widget"] || []).push([["vendors-node_modules_deck_gl_core_dist_esm_index_js"],{

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/controller.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Controller)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _transition_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition-manager */ "./node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");



const NO_TRANSITION_PROPS = {
  transitionDuration: 0
};
const DEFAULT_INERTIA = 300;

const INERTIA_EASING = t => 1 - (1 - t) * (1 - t);

const EVENT_TYPES = {
  WHEEL: ['wheel'],
  PAN: ['panstart', 'panmove', 'panend'],
  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
  TRIPLE_PAN: ['tripanstart', 'tripanmove', 'tripanend'],
  DOUBLE_TAP: ['doubletap'],
  KEYBOARD: ['keydown']
};
const pinchEventWorkaround = {};
class Controller {
  constructor(opts) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "state", {});

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transitionManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "eventManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onViewStateChange", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onStateChange", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "makeViewport", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_controllerState", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_events", {});

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_interactionState", {
      isDragging: false
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_customEvents", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_eventStartBlocked", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_panMove", false);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "invertPan", false);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dragMode", 'rotate');

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "inertia", 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "scrollZoom", true);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dragPan", true);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dragRotate", true);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "doubleClickZoom", true);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "touchZoom", true);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "touchRotate", false);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "keyboard", true);

    this.transitionManager = new _transition_manager__WEBPACK_IMPORTED_MODULE_1__["default"]({ ...opts,
      getControllerState: props => new this.ControllerState(props),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    });
    this.handleEvent = this.handleEvent.bind(this);
    this.eventManager = opts.eventManager;

    this.onViewStateChange = opts.onViewStateChange || (() => {});

    this.onStateChange = opts.onStateChange || (() => {});

    this.makeViewport = opts.makeViewport;
  }

  set events(customEvents) {
    this.toggleEvents(this._customEvents, false);
    this.toggleEvents(customEvents, true);
    this._customEvents = customEvents;

    if (this.props) {
      this.setProps(this.props);
    }
  }

  finalize() {
    for (const eventName in this._events) {
      if (this._events[eventName]) {
        var _this$eventManager;

        (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
      }
    }

    this.transitionManager.finalize();
  }

  handleEvent(event) {
    this._controllerState = undefined;
    const eventStartBlocked = this._eventStartBlocked;

    switch (event.type) {
      case 'panstart':
        return eventStartBlocked ? false : this._onPanStart(event);

      case 'panmove':
        return this._onPan(event);

      case 'panend':
        return this._onPanEnd(event);

      case 'pinchstart':
        return eventStartBlocked ? false : this._onPinchStart(event);

      case 'pinchmove':
        return this._onPinch(event);

      case 'pinchend':
        return this._onPinchEnd(event);

      case 'tripanstart':
        return eventStartBlocked ? false : this._onTriplePanStart(event);

      case 'tripanmove':
        return this._onTriplePan(event);

      case 'tripanend':
        return this._onTriplePanEnd(event);

      case 'doubletap':
        return this._onDoubleTap(event);

      case 'wheel':
        return this._onWheel(event);

      case 'keydown':
        return this._onKeyDown(event);

      default:
        return false;
    }
  }

  get controllerState() {
    this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    });
    return this._controllerState;
  }

  getCenter(event) {
    const {
      x,
      y
    } = this.props;
    const {
      offsetCenter
    } = event;
    return [offsetCenter.x - x, offsetCenter.y - y];
  }

  isPointInBounds(pos, event) {
    const {
      width,
      height
    } = this.props;

    if (event && event.handled) {
      return false;
    }

    const inside = pos[0] >= 0 && pos[0] <= width && pos[1] >= 0 && pos[1] <= height;

    if (inside && event) {
      event.stopPropagation();
    }

    return inside;
  }

  isFunctionKeyPressed(event) {
    const {
      srcEvent
    } = event;
    return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
  }

  isDragging() {
    return this._interactionState.isDragging || false;
  }

  blockEvents(timeout) {
    const timer = setTimeout(() => {
      if (this._eventStartBlocked === timer) {
        this._eventStartBlocked = null;
      }
    }, timeout);
    this._eventStartBlocked = timer;
  }

  setProps(props) {
    if (props.dragMode) {
      this.dragMode = props.dragMode;
    }

    this.props = props;

    if (!('transitionInterpolator' in props)) {
      props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
    }

    this.transitionManager.processViewStateChange(props);
    const {
      inertia
    } = props;
    this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
    const {
      scrollZoom = true,
      dragPan = true,
      dragRotate = true,
      doubleClickZoom = true,
      touchZoom = true,
      touchRotate = false,
      keyboard = true
    } = props;
    const isInteractive = Boolean(this.onViewStateChange);
    this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
    this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
    this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
    this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
    this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
    this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
    this.scrollZoom = scrollZoom;
    this.dragPan = dragPan;
    this.dragRotate = dragRotate;
    this.doubleClickZoom = doubleClickZoom;
    this.touchZoom = touchZoom;
    this.touchRotate = touchRotate;
    this.keyboard = keyboard;
  }

  updateTransition() {
    this.transitionManager.updateTransition();
  }

  toggleEvents(eventNames, enabled) {
    if (this.eventManager) {
      eventNames.forEach(eventName => {
        if (this._events[eventName] !== enabled) {
          this._events[eventName] = enabled;

          if (enabled) {
            this.eventManager.on(eventName, this.handleEvent);
          } else {
            this.eventManager.off(eventName, this.handleEvent);
          }
        }
      });
    }
  }

  updateViewport(newControllerState, extraProps = null, interactionState = {}) {
    const viewState = { ...newControllerState.getViewportProps(),
      ...extraProps
    };
    const changed = this.controllerState !== newControllerState;
    this.state = newControllerState.getState();

    this._setInteractionState(interactionState);

    if (changed) {
      const oldViewState = this.controllerState && this.controllerState.getViewportProps();

      if (this.onViewStateChange) {
        this.onViewStateChange({
          viewState,
          interactionState: this._interactionState,
          oldViewState
        });
      }
    }
  }

  _onTransition(params) {
    this.onViewStateChange({ ...params,
      interactionState: this._interactionState
    });
  }

  _setInteractionState(newStates) {
    Object.assign(this._interactionState, newStates);
    this.onStateChange(this._interactionState);
  }

  _onPanStart(event) {
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;

    if (this.invertPan || this.dragMode === 'pan') {
      alternateMode = !alternateMode;
    }

    const newControllerState = this.controllerState[alternateMode ? 'panStart' : 'rotateStart']({
      pos
    });
    this._panMove = alternateMode;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }

  _onPan(event) {
    if (!this.isDragging()) {
      return false;
    }

    return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
  }

  _onPanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }

    return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
  }

  _onPanMove(event) {
    if (!this.dragPan) {
      return false;
    }

    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.pan({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: true
    });
    return true;
  }

  _onPanMoveEnd(event) {
    const {
      inertia
    } = this;

    if (this.dragPan && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.pan({
        pos: endPos
      }).panEnd();
      this.updateViewport(newControllerState, { ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: true
      });
    } else {
      const newControllerState = this.controllerState.panEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false
      });
    }

    return true;
  }

  _onPanRotate(event) {
    if (!this.dragRotate) {
      return false;
    }

    const pos = this.getCenter(event);
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }

  _onPanRotateEnd(event) {
    const {
      inertia
    } = this;

    if (this.dragRotate && inertia && event.velocity) {
      const pos = this.getCenter(event);
      const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      }).rotateEnd();
      this.updateViewport(newControllerState, { ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }

    return true;
  }

  _onWheel(event) {
    if (!this.scrollZoom) {
      return false;
    }

    event.srcEvent.preventDefault();
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const {
      speed = 0.01,
      smooth = false
    } = this.scrollZoom === true ? {} : this.scrollZoom;
    const {
      delta
    } = event;
    let scale = 2 / (1 + Math.exp(-Math.abs(delta * speed)));

    if (delta < 0 && scale !== 0) {
      scale = 1 / scale;
    }

    const newControllerState = this.controllerState.zoom({
      pos,
      scale
    });
    this.updateViewport(newControllerState, { ...this._getTransitionProps({
        around: pos
      }),
      transitionDuration: smooth ? 250 : 1
    }, {
      isZooming: true,
      isPanning: true
    });
    return true;
  }

  _onTriplePanStart(event) {
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const newControllerState = this.controllerState.rotateStart({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }

  _onTriplePan(event) {
    if (!this.touchRotate) {
      return false;
    }

    if (!this.isDragging()) {
      return false;
    }

    const pos = this.getCenter(event);
    pos[0] -= event.deltaX;
    const newControllerState = this.controllerState.rotate({
      pos
    });
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isRotating: true
    });
    return true;
  }

  _onTriplePanEnd(event) {
    if (!this.isDragging()) {
      return false;
    }

    const {
      inertia
    } = this;

    if (this.touchRotate && inertia && event.velocityY) {
      const pos = this.getCenter(event);
      const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
      const newControllerState = this.controllerState.rotate({
        pos: endPos
      });
      this.updateViewport(newControllerState, { ...this._getTransitionProps(),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isRotating: true
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isRotating: false
      });
    }

    return true;
  }

  _onPinchStart(event) {
    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const newControllerState = this.controllerState.zoomStart({
      pos
    }).rotateStart({
      pos
    });
    pinchEventWorkaround._startPinchRotation = event.rotation;
    pinchEventWorkaround._lastPinchEvent = event;
    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true
    });
    return true;
  }

  _onPinch(event) {
    if (!this.touchZoom && !this.touchRotate) {
      return false;
    }

    if (!this.isDragging()) {
      return false;
    }

    let newControllerState = this.controllerState;

    if (this.touchZoom) {
      const {
        scale
      } = event;
      const pos = this.getCenter(event);
      newControllerState = newControllerState.zoom({
        pos,
        scale
      });
    }

    if (this.touchRotate) {
      const {
        rotation
      } = event;
      newControllerState = newControllerState.rotate({
        deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
      });
    }

    this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
      isDragging: true,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    });
    pinchEventWorkaround._lastPinchEvent = event;
    return true;
  }

  _onPinchEnd(event) {
    if (!this.isDragging()) {
      return false;
    }

    const {
      inertia
    } = this;
    const {
      _lastPinchEvent
    } = pinchEventWorkaround;

    if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
      const pos = this.getCenter(event);
      let newControllerState = this.controllerState.rotateEnd();
      const z = Math.log2(event.scale);

      const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);

      const endScale = Math.pow(2, z + velocityZ * inertia / 2);
      newControllerState = newControllerState.zoom({
        pos,
        scale: endScale
      }).zoomEnd();
      this.updateViewport(newControllerState, { ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: inertia,
        transitionEasing: INERTIA_EASING
      }, {
        isDragging: false,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: false
      });
      this.blockEvents(inertia);
    } else {
      const newControllerState = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(newControllerState, null, {
        isDragging: false,
        isPanning: false,
        isZooming: false,
        isRotating: false
      });
    }

    pinchEventWorkaround._startPinchRotation = null;
    pinchEventWorkaround._lastPinchEvent = null;
    return true;
  }

  _onDoubleTap(event) {
    if (!this.doubleClickZoom) {
      return false;
    }

    const pos = this.getCenter(event);

    if (!this.isPointInBounds(pos, event)) {
      return false;
    }

    const isZoomOut = this.isFunctionKeyPressed(event);
    const newControllerState = this.controllerState.zoom({
      pos,
      scale: isZoomOut ? 0.5 : 2
    });
    this.updateViewport(newControllerState, this._getTransitionProps({
      around: pos
    }), {
      isZooming: true,
      isPanning: true
    });
    this.blockEvents(100);
    return true;
  }

  _onKeyDown(event) {
    if (!this.keyboard) {
      return false;
    }

    const funcKey = this.isFunctionKeyPressed(event);
    const {
      zoomSpeed,
      moveSpeed,
      rotateSpeedX,
      rotateSpeedY
    } = this.keyboard === true ? {} : this.keyboard;
    const {
      controllerState
    } = this;
    let newControllerState;
    const interactionState = {};

    switch (event.srcEvent.code) {
      case 'Minus':
        newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
        interactionState.isZooming = true;
        break;

      case 'Equal':
        newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
        interactionState.isZooming = true;
        break;

      case 'ArrowLeft':
        if (funcKey) {
          newControllerState = controllerState.rotateLeft(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveLeft(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      case 'ArrowRight':
        if (funcKey) {
          newControllerState = controllerState.rotateRight(rotateSpeedX);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveRight(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      case 'ArrowUp':
        if (funcKey) {
          newControllerState = controllerState.rotateUp(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveUp(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      case 'ArrowDown':
        if (funcKey) {
          newControllerState = controllerState.rotateDown(rotateSpeedY);
          interactionState.isRotating = true;
        } else {
          newControllerState = controllerState.moveDown(moveSpeed);
          interactionState.isPanning = true;
        }

        break;

      default:
        return false;
    }

    this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
    return true;
  }

  _getTransitionProps(opts) {
    const {
      transition
    } = this;

    if (!transition || !transition.transitionInterpolator) {
      return NO_TRANSITION_PROPS;
    }

    return opts ? { ...transition,
      transitionInterpolator: new _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_2__["default"]({ ...opts,
        ...transition.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : transition;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FirstPersonController)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js");
/* harmony import */ var _view_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view-state */ "./node_modules/@deck.gl/core/dist/esm/controllers/view-state.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");






const MOVEMENT_SPEED = 20;

class FirstPersonState extends _view_state__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(options) {
    const {
      width,
      height,
      position = [0, 0, 0],
      bearing = 0,
      pitch = 0,
      longitude = null,
      latitude = null,
      maxPitch = 90,
      minPitch = -90,
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition
    } = options;
    super({
      width,
      height,
      position,
      bearing,
      pitch,
      longitude,
      latitude,
      maxPitch,
      minPitch
    }, {
      startRotatePos,
      startBearing,
      startPitch,
      startZoomPosition
    });
  }

  panStart() {
    return this;
  }

  pan() {
    return this;
  }

  panEnd() {
    return this;
  }

  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }

  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();
    const {
      width,
      height
    } = this.getViewportProps();

    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {
      return this;
    }

    let newRotation;

    if (pos) {
      const deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;
      newRotation = {
        bearing: startBearing - deltaScaleX * 180,
        pitch: startPitch - deltaScaleY * 90
      };
    } else {
      newRotation = {
        bearing: startBearing - deltaAngleX,
        pitch: startPitch - deltaAngleY
      };
    }

    return this._getUpdatedState(newRotation);
  }

  rotateEnd() {
    return this._getUpdatedState({
      startRotatePos: null,
      startBearing: null,
      startPitch: null
    });
  }

  zoomStart() {
    return this._getUpdatedState({
      startZoomPosition: this.getViewportProps().position
    });
  }

  zoom({
    scale
  }) {
    let {
      startZoomPosition
    } = this.getState();

    if (!startZoomPosition) {
      startZoomPosition = this.getViewportProps().position;
    }

    const direction = this.getDirection();
    return this._move(direction, Math.log2(scale) * MOVEMENT_SPEED, startZoomPosition);
  }

  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null
    });
  }

  moveLeft(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: Math.PI / 2
    }), speed);
  }

  moveRight(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.rotateZ({
      radians: -Math.PI / 2
    }), speed);
  }

  moveUp(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction, speed);
  }

  moveDown(speed = MOVEMENT_SPEED) {
    const direction = this.getDirection(true);
    return this._move(direction.negate(), speed);
  }

  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }

  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }

  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }

  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }

  zoomIn(speed = 2) {
    return this.zoom({
      scale: speed
    });
  }

  zoomOut(speed = 2) {
    return this.zoom({
      scale: 1 / speed
    });
  }

  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;

    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }

    if (longitude !== null && fromProps.longitude !== null && Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }

    return props;
  }

  _move(direction, speed, fromPosition = this.getViewportProps().position) {
    const delta = direction.scale(speed);
    return this._getUpdatedState({
      position: new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"](fromPosition).add(delta)
    });
  }

  getDirection(use2D = false) {
    const spherical = new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"]({
      bearing: this.getViewportProps().bearing,
      pitch: use2D ? 90 : 90 + this.getViewportProps().pitch
    });
    const direction = spherical.toVector3().normalize();
    return direction;
  }

  _getUpdatedState(newProps) {
    return new FirstPersonState({ ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }

  applyConstraints(props) {
    const {
      pitch,
      maxPitch,
      minPitch,
      longitude,
      bearing
    } = props;
    props.pitch = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)(pitch, minPitch, maxPitch);

    if (longitude !== null && (longitude < -180 || longitude > 180)) {
      props.longitude = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_5__.mod)(longitude + 180, 360) - 180;
    }

    if (bearing < -180 || bearing > 180) {
      props.bearing = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_5__.mod)(bearing + 180, 360) - 180;
    }

    return props;
  }

}

class FirstPersonController extends _controller__WEBPACK_IMPORTED_MODULE_6__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ControllerState", FirstPersonState);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_7__["default"](['position', 'pitch', 'bearing'])
    });
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GlobeController)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js");
/* harmony import */ var _map_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");







class GlobeState extends _map_controller__WEBPACK_IMPORTED_MODULE_1__.MapState {
  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(zoom, minZoom, maxZoom);
    const {
      longitude,
      latitude
    } = props;

    if (longitude < -180 || longitude > 180) {
      props.longitude = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_3__.mod)(longitude + 180, 360) - 180;
    }

    props.latitude = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(latitude, -89, 89);
    return props;
  }

}

class GlobeController extends _controller__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ControllerState", GlobeState);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_5__["default"](['longitude', 'latitude', 'zoom'])
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dragMode", 'pan');
  }

  setProps(props) {
    super.setProps(props);
    this.dragRotate = false;
    this.touchRotate = false;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MapState": () => (/* binding */ MapState),
/* harmony export */   "default": () => (/* binding */ MapController)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js");
/* harmony import */ var _view_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./view-state */ "./node_modules/@deck.gl/core/dist/esm/controllers/view-state.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");







const PITCH_MOUSE_THRESHOLD = 5;
const PITCH_ACCEL = 1.2;
class MapState extends _view_state__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(options) {
    const {
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing = 0,
      pitch = 0,
      altitude = 1.5,
      position = [0, 0, 0],
      maxZoom = 20,
      minZoom = 0,
      maxPitch = 60,
      minPitch = 0,
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom,
      normalize = true
    } = options;
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(Number.isFinite(longitude));
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(Number.isFinite(latitude));
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(Number.isFinite(zoom));
    super({
      width,
      height,
      latitude,
      longitude,
      zoom,
      bearing,
      pitch,
      altitude,
      maxZoom,
      minZoom,
      maxPitch,
      minPitch,
      normalize,
      position
    }, {
      startPanLngLat,
      startZoomLngLat,
      startRotatePos,
      startBearing,
      startPitch,
      startZoom
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "makeViewport", void 0);

    this.makeViewport = options.makeViewport;
  }

  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanLngLat: this._unproject(pos)
    });
  }

  pan({
    pos,
    startPos
  }) {
    const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);

    if (!startPanLngLat) {
      return this;
    }

    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanLngLat, pos);
    return this._getUpdatedState(newProps);
  }

  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }

  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }

  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startBearing,
      startPitch
    } = this.getState();

    if (!startRotatePos || startBearing === undefined || startPitch === undefined) {
      return this;
    }

    let newRotation;

    if (pos) {
      newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
    } else {
      newRotation = {
        bearing: startBearing + deltaAngleX,
        pitch: startPitch + deltaAngleY
      };
    }

    return this._getUpdatedState(newRotation);
  }

  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }

  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }

  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomLngLat
    } = this.getState();

    if (!startZoomLngLat) {
      startZoom = this.getViewportProps().zoom;
      startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
    }

    if (!startZoomLngLat) {
      return this;
    }

    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();
    let zoom = startZoom + Math.log2(scale);
    zoom = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)(zoom, minZoom, maxZoom);
    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(),
      zoom
    });
    return this._getUpdatedState({
      zoom,
      ...zoomedViewport.panByPosition(startZoomLngLat, pos)
    });
  }

  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }

  zoomIn(speed = 2) {
    return this._zoomFromCenter(speed);
  }

  zoomOut(speed = 2) {
    return this._zoomFromCenter(1 / speed);
  }

  moveLeft(speed = 100) {
    return this._panFromCenter([speed, 0]);
  }

  moveRight(speed = 100) {
    return this._panFromCenter([-speed, 0]);
  }

  moveUp(speed = 100) {
    return this._panFromCenter([0, speed]);
  }

  moveDown(speed = 100) {
    return this._panFromCenter([0, -speed]);
  }

  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - speed
    });
  }

  rotateRight(speed = 15) {
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + speed
    });
  }

  rotateUp(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + speed
    });
  }

  rotateDown(speed = 10) {
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - speed
    });
  }

  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps()
    };
    const {
      bearing,
      longitude
    } = props;

    if (Math.abs(bearing - fromProps.bearing) > 180) {
      props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
    }

    if (Math.abs(longitude - fromProps.longitude) > 180) {
      props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
    }

    return props;
  }

  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom
    } = props;
    props.zoom = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)(zoom, minZoom, maxZoom);
    const {
      maxPitch,
      minPitch,
      pitch
    } = props;
    props.pitch = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)(pitch, minPitch, maxPitch);
    const {
      normalize = true
    } = props;

    if (normalize) {
      Object.assign(props, (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.normalizeViewportProps)(props));
    }

    return props;
  }

  _zoomFromCenter(scale) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.zoom({
      pos: [width / 2, height / 2],
      scale
    });
  }

  _panFromCenter(offset) {
    const {
      width,
      height
    } = this.getViewportProps();
    return this.pan({
      startPos: [width / 2, height / 2],
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }

  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }

  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }

  _getNewRotation(pos, startPos, startPitch, startBearing) {
    const deltaX = pos[0] - startPos[0];
    const deltaY = pos[1] - startPos[1];
    const centerY = pos[1];
    const startY = startPos[1];
    const {
      width,
      height
    } = this.getViewportProps();
    const deltaScaleX = deltaX / width;
    let deltaScaleY = 0;

    if (deltaY > 0) {
      if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
      }
    } else if (deltaY < 0) {
      if (startY > PITCH_MOUSE_THRESHOLD) {
        deltaScaleY = 1 - centerY / startY;
      }
    }

    deltaScaleY = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)(deltaScaleY, -1, 1);
    const {
      minPitch,
      maxPitch
    } = this.getViewportProps();
    const bearing = startBearing + 180 * deltaScaleX;
    let pitch = startPitch;

    if (deltaScaleY > 0) {
      pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
    } else if (deltaScaleY < 0) {
      pitch = startPitch - deltaScaleY * (minPitch - startPitch);
    }

    return {
      pitch,
      bearing
    };
  }

}
class MapController extends _controller__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ControllerState", MapState);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_6__["default"]({
        transitionProps: {
          compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch', 'position'],
          required: ['longitude', 'latitude', 'zoom']
        }
      })
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dragMode", 'pan');
  }

  setProps(props) {
    props.position = props.position || [0, 0, 0];
    const oldProps = this.props;
    super.setProps(props);
    const dimensionChanged = !oldProps || oldProps.height !== props.height;

    if (dimensionChanged) {
      this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...props,
        ...this.state
      }));
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitState": () => (/* binding */ OrbitState),
/* harmony export */   "default": () => (/* binding */ OrbitController)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js");
/* harmony import */ var _view_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view-state */ "./node_modules/@deck.gl/core/dist/esm/controllers/view-state.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");






class OrbitState extends _view_state__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(options) {
    const {
      width,
      height,
      rotationX = 0,
      rotationOrbit = 0,
      target = [0, 0, 0],
      zoom = 0,
      minRotationX = -90,
      maxRotationX = 90,
      minZoom = -Infinity,
      maxZoom = Infinity,
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    } = options;
    super({
      width,
      height,
      rotationX,
      rotationOrbit,
      target,
      zoom,
      minRotationX,
      maxRotationX,
      minZoom,
      maxZoom
    }, {
      startPanPosition,
      startRotatePos,
      startRotationX,
      startRotationOrbit,
      startZoomPosition,
      startZoom
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "makeViewport", void 0);

    this.makeViewport = options.makeViewport;
  }

  panStart({
    pos
  }) {
    return this._getUpdatedState({
      startPanPosition: this._unproject(pos)
    });
  }

  pan({
    pos,
    startPosition
  }) {
    const startPanPosition = this.getState().startPanPosition || startPosition;

    if (!startPanPosition) {
      return this;
    }

    const viewport = this.makeViewport(this.getViewportProps());
    const newProps = viewport.panByPosition(startPanPosition, pos);
    return this._getUpdatedState(newProps);
  }

  panEnd() {
    return this._getUpdatedState({
      startPanPosition: null
    });
  }

  rotateStart({
    pos
  }) {
    return this._getUpdatedState({
      startRotatePos: pos,
      startRotationX: this.getViewportProps().rotationX,
      startRotationOrbit: this.getViewportProps().rotationOrbit
    });
  }

  rotate({
    pos,
    deltaAngleX = 0,
    deltaAngleY = 0
  }) {
    const {
      startRotatePos,
      startRotationX,
      startRotationOrbit
    } = this.getState();
    const {
      width,
      height
    } = this.getViewportProps();

    if (!startRotatePos || startRotationX === undefined || startRotationOrbit === undefined) {
      return this;
    }

    let newRotation;

    if (pos) {
      let deltaScaleX = (pos[0] - startRotatePos[0]) / width;
      const deltaScaleY = (pos[1] - startRotatePos[1]) / height;

      if (startRotationX < -90 || startRotationX > 90) {
        deltaScaleX *= -1;
      }

      newRotation = {
        rotationX: startRotationX + deltaScaleY * 180,
        rotationOrbit: startRotationOrbit + deltaScaleX * 180
      };
    } else {
      newRotation = {
        rotationX: startRotationX + deltaAngleY,
        rotationOrbit: startRotationOrbit + deltaAngleX
      };
    }

    return this._getUpdatedState(newRotation);
  }

  rotateEnd() {
    return this._getUpdatedState({
      startRotationX: null,
      startRotationOrbit: null
    });
  }

  shortestPathFrom(viewState) {
    const fromProps = viewState.getViewportProps();
    const props = { ...this.getViewportProps()
    };
    const {
      rotationOrbit
    } = props;

    if (Math.abs(rotationOrbit - fromProps.rotationOrbit) > 180) {
      props.rotationOrbit = rotationOrbit < 0 ? rotationOrbit + 360 : rotationOrbit - 360;
    }

    return props;
  }

  zoomStart({
    pos
  }) {
    return this._getUpdatedState({
      startZoomPosition: this._unproject(pos),
      startZoom: this.getViewportProps().zoom
    });
  }

  zoom({
    pos,
    startPos,
    scale
  }) {
    let {
      startZoom,
      startZoomPosition
    } = this.getState();

    if (!startZoomPosition) {
      startZoom = this.getViewportProps().zoom;
      startZoomPosition = this._unproject(startPos) || this._unproject(pos);
    }

    if (!startZoomPosition) {
      return this;
    }

    const newZoom = this._calculateNewZoom({
      scale,
      startZoom
    });

    const zoomedViewport = this.makeViewport({ ...this.getViewportProps(),
      zoom: newZoom
    });
    return this._getUpdatedState({
      zoom: newZoom,
      ...zoomedViewport.panByPosition(startZoomPosition, pos)
    });
  }

  zoomEnd() {
    return this._getUpdatedState({
      startZoomPosition: null,
      startZoom: null
    });
  }

  zoomIn(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: speed
      })
    });
  }

  zoomOut(speed = 2) {
    return this._getUpdatedState({
      zoom: this._calculateNewZoom({
        scale: 1 / speed
      })
    });
  }

  moveLeft(speed = 50) {
    return this._panFromCenter([-speed, 0]);
  }

  moveRight(speed = 50) {
    return this._panFromCenter([speed, 0]);
  }

  moveUp(speed = 50) {
    return this._panFromCenter([0, -speed]);
  }

  moveDown(speed = 50) {
    return this._panFromCenter([0, speed]);
  }

  rotateLeft(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit - speed
    });
  }

  rotateRight(speed = 15) {
    return this._getUpdatedState({
      rotationOrbit: this.getViewportProps().rotationOrbit + speed
    });
  }

  rotateUp(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX - speed
    });
  }

  rotateDown(speed = 10) {
    return this._getUpdatedState({
      rotationX: this.getViewportProps().rotationX + speed
    });
  }

  _unproject(pos) {
    const viewport = this.makeViewport(this.getViewportProps());
    return pos && viewport.unproject(pos);
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();

    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }

    const zoom = startZoom + Math.log2(scale);
    return (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(zoom, minZoom, maxZoom);
  }

  _panFromCenter(offset) {
    const {
      width,
      height,
      target
    } = this.getViewportProps();
    return this.pan({
      startPosition: target,
      pos: [width / 2 + offset[0], height / 2 + offset[1]]
    });
  }

  _getUpdatedState(newProps) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...newProps
    });
  }

  applyConstraints(props) {
    const {
      maxZoom,
      minZoom,
      zoom,
      maxRotationX,
      minRotationX,
      rotationOrbit
    } = props;
    props.zoom = Array.isArray(zoom) ? [(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(zoom[0], minZoom, maxZoom), (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(zoom[1], minZoom, maxZoom)] : (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(zoom, minZoom, maxZoom);
    props.rotationX = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(props.rotationX, minRotationX, maxRotationX);

    if (rotationOrbit < -180 || rotationOrbit > 180) {
      props.rotationOrbit = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_3__.mod)(rotationOrbit + 180, 360) - 180;
    }

    return props;
  }

}
class OrbitController extends _controller__WEBPACK_IMPORTED_MODULE_4__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ControllerState", OrbitState);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_5__["default"]({
        transitionProps: {
          compare: ['target', 'zoom', 'rotationX', 'rotationOrbit'],
          required: ['target', 'zoom']
        }
      })
    });
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrthographicController)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js");
/* harmony import */ var _orbit_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./orbit-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");






class OrthographicState extends _orbit_controller__WEBPACK_IMPORTED_MODULE_1__.OrbitState {
  constructor(props) {
    super(props);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "zoomAxis", void 0);

    this.zoomAxis = props.zoomAxis || 'all';
  }

  _calculateNewZoom({
    scale,
    startZoom
  }) {
    const {
      maxZoom,
      minZoom
    } = this.getViewportProps();

    if (startZoom === undefined) {
      startZoom = this.getViewportProps().zoom;
    }

    let deltaZoom = Math.log2(scale);

    if (Array.isArray(startZoom)) {
      let [newZoomX, newZoomY] = startZoom;

      switch (this.zoomAxis) {
        case 'X':
          newZoomX = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(newZoomX + deltaZoom, minZoom, maxZoom);
          break;

        case 'Y':
          newZoomY = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(newZoomY + deltaZoom, minZoom, maxZoom);
          break;

        default:
          let z = Math.min(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z < minZoom) {
            deltaZoom += minZoom - z;
          }

          z = Math.max(newZoomX + deltaZoom, newZoomY + deltaZoom);

          if (z > maxZoom) {
            deltaZoom += maxZoom - z;
          }

          newZoomX += deltaZoom;
          newZoomY += deltaZoom;
      }

      return [newZoomX, newZoomY];
    }

    return (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)(startZoom + deltaZoom, minZoom, maxZoom);
  }

}

class OrthographicController extends _controller__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ControllerState", OrthographicState);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_4__["default"](['target', 'zoom'])
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dragMode", 'pan');
  }

  _onPanRotate() {
    return false;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TRANSITION_EVENTS": () => (/* binding */ TRANSITION_EVENTS),
/* harmony export */   "default": () => (/* binding */ TransitionManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _transitions_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transitions/transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition.js");



const noop = () => {};

const TRANSITION_EVENTS = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
};

const DEFAULT_EASING = t => t;

const DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
class TransitionManager {
  constructor(opts) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "getControllerState", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "propsInTransition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onViewStateChange", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onStateChange", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_onTransitionUpdate", transition => {
      const {
        time,
        settings: {
          interpolator,
          startProps,
          endProps,
          duration,
          easing
        }
      } = transition;
      const t = easing(time / duration);
      const viewport = interpolator.interpolateProps(startProps, endProps, t);
      this.propsInTransition = this.getControllerState({ ...this.props,
        ...viewport
      }).getViewportProps();
      this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    });

    this.getControllerState = opts.getControllerState;
    this.propsInTransition = null;
    this.transition = new _transitions_transition__WEBPACK_IMPORTED_MODULE_1__["default"](opts.timeline);
    this.onViewStateChange = opts.onViewStateChange || noop;
    this.onStateChange = opts.onStateChange || noop;
  }

  finalize() {
    this.transition.cancel();
  }

  getViewportInTransition() {
    return this.propsInTransition;
  }

  processViewStateChange(nextProps) {
    let transitionTriggered = false;
    const currentProps = this.props;
    this.props = nextProps;

    if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
      return false;
    }

    if (this._isTransitionEnabled(nextProps)) {
      let startProps = currentProps;

      if (this.transition.inProgress) {
        const {
          interruption,
          endProps
        } = this.transition.settings;
        startProps = { ...currentProps,
          ...(interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps)
        };
      }

      this._triggerTransition(startProps, nextProps);

      transitionTriggered = true;
    } else {
      this.transition.cancel();
    }

    return transitionTriggered;
  }

  updateTransition() {
    this.transition.update();
  }

  _isTransitionEnabled(props) {
    const {
      transitionDuration,
      transitionInterpolator
    } = props;
    return (transitionDuration > 0 || transitionDuration === 'auto') && Boolean(transitionInterpolator);
  }

  _isUpdateDueToCurrentTransition(props) {
    if (this.transition.inProgress && this.propsInTransition) {
      return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
    }

    return false;
  }

  _shouldIgnoreViewportChange(currentProps, nextProps) {
    if (this.transition.inProgress) {
      return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
    }

    if (this._isTransitionEnabled(nextProps)) {
      return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
    }

    return true;
  }

  _triggerTransition(startProps, endProps) {
    const startViewstate = this.getControllerState(startProps);
    const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
    const transitionInterpolator = endProps.transitionInterpolator;
    const duration = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;

    if (duration === 0) {
      return;
    }

    const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
    this.propsInTransition = {};
    const transitionSettings = {
      duration,
      easing: endProps.transitionEasing || DEFAULT_EASING,
      interpolator: transitionInterpolator,
      interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
      startProps: initialProps.start,
      endProps: initialProps.end,
      onStart: endProps.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
    };
    this.transition.start(transitionSettings);
    this.onStateChange({
      inTransition: true
    });
    this.updateTransition();
  }

  _onTransitionEnd(callback) {
    return transition => {
      this.propsInTransition = null;
      this.onStateChange({
        inTransition: false,
        isZooming: false,
        isPanning: false,
        isRotating: false
      });
      callback === null || callback === void 0 ? void 0 : callback(transition);
    };
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/controllers/view-state.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/controllers/view-state.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ViewState)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

class ViewState {
  constructor(props, state) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_viewportProps", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_state", void 0);

    this._viewportProps = this.applyConstraints(props);
    this._state = state;
  }

  getViewportProps() {
    return this._viewportProps;
  }

  getState() {
    return this._state;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/debug/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/debug/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debug),
/* harmony export */   "register": () => (/* binding */ register)
/* harmony export */ });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _loggers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loggers */ "./node_modules/@deck.gl/core/dist/esm/debug/loggers.js");


let loggers = {};

if (true) {
  loggers = (0,_loggers__WEBPACK_IMPORTED_MODULE_0__.getLoggers)(_utils_log__WEBPACK_IMPORTED_MODULE_1__["default"]);
}

function register(handlers) {
  loggers = handlers;
}
function debug(eventType, arg1, arg2, arg3) {
  if (_utils_log__WEBPACK_IMPORTED_MODULE_1__["default"].level > 0 && loggers[eventType]) {
    loggers[eventType].call(null, arg1, arg2, arg3);
  }
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/debug/loggers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/debug/loggers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getLoggers": () => (/* binding */ getLoggers)
/* harmony export */ });
const logState = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
};
const LOG_LEVEL_MAJOR_UPDATE = 1;
const LOG_LEVEL_MINOR_UPDATE = 2;
const LOG_LEVEL_UPDATE_DETAIL = 3;
const LOG_LEVEL_INFO = 4;
const LOG_LEVEL_DRAW = 2;
const getLoggers = log => ({
  'layer.changeFlag': (layer, key, flags) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
  },
  'layer.initialize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
  },
  'layer.update': (layer, needsUpdate) => {
    if (needsUpdate) {
      const flags = layer.getChangeFlags();
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter(key => flags[key]).join(', ')))();
    } else {
      log.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
    }
  },
  'layer.matched': (layer, changed) => {
    if (changed) {
      log.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
    }
  },
  'layer.finalize': layer => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
  },
  'compositeLayer.renderLayers': (layer, updated, subLayers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
    } else {
      log.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
    }
  },
  'layerManager.setLayers': (layerManager, updated, layers) => {
    if (updated) {
      log.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
    }
  },
  'layerManager.activateViewport': (layerManager, viewport) => {
    log.log(LOG_LEVEL_UPDATE_DETAIL, 'Viewport changed', viewport)();
  },
  'attributeManager.invalidate': (attributeManager, trigger, attributeNames) => {
    log.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
  },
  'attributeManager.updateStart': attributeManager => {
    logState.attributeUpdateMessages.length = 0;
    logState.attributeManagerUpdateStart = Date.now();
  },
  'attributeManager.updateEnd': (attributeManager, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
    log.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();

    for (const updateMessage of logState.attributeUpdateMessages) {
      log.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
    }

    log.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
  },
  'attribute.updateStart': attribute => {
    logState.attributeUpdateStart = Date.now();
  },
  'attribute.allocate': (attribute, numInstances) => {
    const message = "".concat(attribute.id, " allocated ").concat(numInstances);
    logState.attributeUpdateMessages.push(message);
  },
  'attribute.updateEnd': (attribute, numInstances) => {
    const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
    const message = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
    logState.attributeUpdateMessages.push(message);
  },
  'deckRenderer.renderLayers': (deckRenderer, renderStats, opts) => {
    const {
      pass,
      redrawReason,
      stats
    } = opts;

    for (const status of renderStats) {
      const {
        totalCount,
        visibleCount,
        compositeCount,
        pickableCount
      } = status;
      const primitiveCount = totalCount - compositeCount;
      const hiddenCount = primitiveCount - visibleCount;
      log.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();

      if (stats) {
        stats.get('Redraw Layers').add(visibleCount);
      }
    }
  }
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AmbientLight": () => (/* binding */ AmbientLight)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
let idCount = 0;
class AmbientLight {
  constructor(props = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "color", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "intensity", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", 'ambient');

    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    this.id = props.id || "ambient-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CameraLight)
/* harmony export */ });
/* harmony import */ var _point_light__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./point-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js");
/* harmony import */ var _shaderlib_project_viewport_uniforms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shaderlib/project/viewport-uniforms */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js");


class CameraLight extends _point_light__WEBPACK_IMPORTED_MODULE_0__.PointLight {
  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin,
      modelMatrix
    } = layer.props;
    const {
      project_uCameraPosition
    } = (0,_shaderlib_project_viewport_uniforms__WEBPACK_IMPORTED_MODULE_1__.getUniformsFromViewport)({
      viewport,
      modelMatrix,
      coordinateSystem,
      coordinateOrigin
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = project_uCameraPosition;
    return projectedLight;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DirectionalLight": () => (/* binding */ DirectionalLight)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");


const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];
let idCount = 0;
class DirectionalLight {
  constructor(props = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "color", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "intensity", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", 'directional');

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "direction", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadow", void 0);

    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      direction = DEFAULT_LIGHT_DIRECTION
    } = props;
    const {
      _shadow = false
    } = props;
    this.id = props.id || "directional-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'directional';
    this.direction = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__["default"](direction).normalize().toArray();
    this.shadow = _shadow;
  }

  getProjectedLight(opts) {
    return this;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LightingEffect)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _ambient_light__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ambient-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js");
/* harmony import */ var _directional_light__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./directional-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var _passes_shadow_pass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../passes/shadow-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js");
/* harmony import */ var _shaderlib_shadow_shadow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../shaderlib/shadow/shadow */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js");







const DEFAULT_AMBIENT_LIGHT_PROPS = {
  color: [255, 255, 255],
  intensity: 1.0
};
const DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
  color: [255, 255, 255],
  intensity: 1.0,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}];
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 200 / 255];
class LightingEffect {
  constructor(props = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", 'lighting-effect');

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadowColor", DEFAULT_SHADOW_COLOR);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadow", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "ambientLight", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "directionalLights", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pointLights", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadowPasses", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadowMaps", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "dummyShadowMap", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "programManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadowMatrices", void 0);

    this.setProps(props);
  }

  setProps(props) {
    this.ambientLight = null;
    this.directionalLights = [];
    this.pointLights = [];

    for (const key in props) {
      const lightSource = props[key];

      switch (lightSource.type) {
        case 'ambient':
          this.ambientLight = lightSource;
          break;

        case 'directional':
          this.directionalLights.push(lightSource);
          break;

        case 'point':
          this.pointLights.push(lightSource);
          break;

        default:
      }
    }

    this._applyDefaultLights();

    this.shadow = this.directionalLights.some(light => light.shadow);
    this.props = props;
  }

  preRender(gl, {
    layers,
    layerFilter,
    viewports,
    onViewportActive,
    views
  }) {
    if (!this.shadow) return;
    this.shadowMatrices = this._calculateMatrices();

    if (this.shadowPasses.length === 0) {
      this._createShadowPasses(gl);
    }

    if (!this.programManager) {
      this.programManager = _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["default"].getDefaultProgramManager(gl);

      if (_shaderlib_shadow_shadow__WEBPACK_IMPORTED_MODULE_2__["default"]) {
        this.programManager.addDefaultModule(_shaderlib_shadow_shadow__WEBPACK_IMPORTED_MODULE_2__["default"]);
      }
    }

    if (!this.dummyShadowMap) {
      this.dummyShadowMap = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, {
        width: 1,
        height: 1
      });
    }

    for (let i = 0; i < this.shadowPasses.length; i++) {
      const shadowPass = this.shadowPasses[i];
      shadowPass.render({
        layers,
        layerFilter,
        viewports,
        onViewportActive,
        views,
        moduleParameters: {
          shadowLightId: i,
          dummyShadowMap: this.dummyShadowMap,
          shadowMatrices: this.shadowMatrices
        }
      });
    }
  }

  getModuleParameters(layer) {
    const parameters = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    parameters.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map(directionalLight => directionalLight.getProjectedLight({
        layer
      })),
      pointLights: this.pointLights.map(pointLight => pointLight.getProjectedLight({
        layer
      }))
    };
    return parameters;
  }

  cleanup() {
    for (const shadowPass of this.shadowPasses) {
      shadowPass.delete();
    }

    this.shadowPasses.length = 0;
    this.shadowMaps.length = 0;

    if (this.dummyShadowMap) {
      this.dummyShadowMap.delete();
      this.dummyShadowMap = null;
    }

    if (this.shadow && this.programManager) {
      this.programManager.removeDefaultModule(_shaderlib_shadow_shadow__WEBPACK_IMPORTED_MODULE_2__["default"]);
      this.programManager = null;
    }
  }

  _calculateMatrices() {
    const lightMatrices = [];

    for (const light of this.directionalLights) {
      const viewMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_4__["default"]().lookAt({
        eye: new _math_gl_core__WEBPACK_IMPORTED_MODULE_5__["default"](light.direction).negate()
      });
      lightMatrices.push(viewMatrix);
    }

    return lightMatrices;
  }

  _createShadowPasses(gl) {
    for (let i = 0; i < this.directionalLights.length; i++) {
      const shadowPass = new _passes_shadow_pass__WEBPACK_IMPORTED_MODULE_6__["default"](gl);
      this.shadowPasses[i] = shadowPass;
      this.shadowMaps[i] = shadowPass.shadowMap;
    }
  }

  _applyDefaultLights() {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = this;

    if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
      this.ambientLight = new _ambient_light__WEBPACK_IMPORTED_MODULE_7__.AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
      this.directionalLights.push(new _directional_light__WEBPACK_IMPORTED_MODULE_8__.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new _directional_light__WEBPACK_IMPORTED_MODULE_8__.DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointLight": () => (/* binding */ PointLight)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _shaderlib_project_project_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../shaderlib/project/project-functions */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");



const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_ATTENUATION = [0, 0, 1];
const DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];
let idCount = 0;
class PointLight {
  constructor(props = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "color", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "intensity", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", 'point');

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "position", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attenuation", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "projectedLight", void 0);

    const {
      color = DEFAULT_LIGHT_COLOR
    } = props;
    const {
      intensity = DEFAULT_LIGHT_INTENSITY
    } = props;
    const {
      position = DEFAULT_LIGHT_POSITION
    } = props;
    this.id = props.id || "point-".concat(idCount++);
    this.color = color;
    this.intensity = intensity;
    this.type = 'point';
    this.position = position;
    this.attenuation = getAttenuation(props);
    this.projectedLight = { ...this
    };
  }

  getProjectedLight({
    layer
  }) {
    const {
      projectedLight
    } = this;
    const viewport = layer.context.viewport;
    const {
      coordinateSystem,
      coordinateOrigin
    } = layer.props;
    const position = (0,_shaderlib_project_project_functions__WEBPACK_IMPORTED_MODULE_1__.projectPosition)(this.position, {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      fromCoordinateSystem: viewport.isGeospatial ? _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.LNGLAT : _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.CARTESIAN,
      fromCoordinateOrigin: [0, 0, 0]
    });
    projectedLight.color = this.color;
    projectedLight.intensity = this.intensity;
    projectedLight.position = position;
    return projectedLight;
  }

}

function getAttenuation(props) {
  if (props.attenuation) {
    return props.attenuation;
  }

  if ('intensity' in props) {
    return [0, 0, props.intensity || 0];
  }

  return DEFAULT_ATTENUATION;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SunLight)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _directional_light__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./directional-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js");
/* harmony import */ var _math_gl_sun__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/sun */ "./node_modules/@math.gl/sun/dist/esm/index.js");



class SunLight extends _directional_light__WEBPACK_IMPORTED_MODULE_2__.DirectionalLight {
  constructor(opts) {
    super(opts);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "timestamp", void 0);

    this.timestamp = opts.timestamp;
  }

  getProjectedLight({
    layer
  }) {
    const {
      viewport
    } = layer.context;
    const isGlobe = viewport.resolution && viewport.resolution > 0;

    if (isGlobe) {
      const [x, y, z] = (0,_math_gl_sun__WEBPACK_IMPORTED_MODULE_1__.getSunDirection)(this.timestamp, 0, 0);
      this.direction = [x, -z, y];
    } else {
      const {
        latitude,
        longitude
      } = viewport;
      this.direction = (0,_math_gl_sun__WEBPACK_IMPORTED_MODULE_1__.getSunDirection)(this.timestamp, latitude, longitude);
    }

    return this;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PostProcessEffect)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _passes_screen_pass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../passes/screen-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js");



class PostProcessEffect {
  constructor(module, props = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "module", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "passes", void 0);

    this.id = "".concat(module.name, "-pass");
    this.props = props;
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__.normalizeShaderModule)(module);
    this.module = module;
  }

  setProps(props) {
    this.props = props;
  }

  preRender() {}

  postRender(gl, params) {
    const passes = this.passes || createPasses(gl, this.module, this.id);
    this.passes = passes;
    const {
      target
    } = params;
    let inputBuffer = params.inputBuffer;
    let outputBuffer = params.swapBuffer;

    for (let index = 0; index < this.passes.length; index++) {
      if (target && index === this.passes.length - 1) {
        outputBuffer = target;
      }

      this.passes[index].render({
        inputBuffer,
        outputBuffer,
        moduleSettings: this.props
      });
      const switchBuffer = outputBuffer;
      outputBuffer = inputBuffer;
      inputBuffer = switchBuffer;
    }

    return inputBuffer;
  }

  cleanup() {
    if (this.passes) {
      for (const pass of this.passes) {
        pass.delete();
      }

      this.passes = undefined;
    }
  }

}

function createPasses(gl, module, id) {
  if (!module.passes) {
    const fs = getFragmentShaderForRenderPass(module);
    const pass = new _passes_screen_pass__WEBPACK_IMPORTED_MODULE_2__["default"](gl, {
      id,
      module,
      fs
    });
    return [pass];
  }

  return module.passes.map((pass, index) => {
    const fs = getFragmentShaderForRenderPass(module, pass);
    const idn = "".concat(id, "-").concat(index);
    return new _passes_screen_pass__WEBPACK_IMPORTED_MODULE_2__["default"](gl, {
      id: idn,
      module,
      fs
    });
  });
}

const FILTER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = texture2D(texture, texCoord);\n  gl_FragColor = ".concat(func, "(gl_FragColor, texSize, texCoord);\n}\n");

const SAMPLER_FS_TEMPLATE = func => "uniform sampler2D texture;\nuniform vec2 texSize;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main() {\n  vec2 texCoord = coordinate;\n\n  gl_FragColor = ".concat(func, "(texture, texSize, texCoord);\n}\n");

function getFragmentShaderForRenderPass(module, pass = module) {
  if (pass.filter) {
    const func = typeof pass.filter === 'string' ? pass.filter : "".concat(module.name, "_filterColor");
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    const func = typeof pass.sampler === 'string' ? pass.sampler : "".concat(module.name, "_sampleColor");
    return SAMPLER_FS_TEMPLATE(func);
  }

  return null;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AmbientLight": () => (/* reexport safe */ _effects_lighting_ambient_light__WEBPACK_IMPORTED_MODULE_3__.AmbientLight),
/* harmony export */   "AttributeManager": () => (/* reexport safe */ _lib_attribute_attribute_manager__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   "COORDINATE_SYSTEM": () => (/* reexport safe */ _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM),
/* harmony export */   "CompositeLayer": () => (/* reexport safe */ _lib_composite_layer__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   "Controller": () => (/* reexport safe */ _controllers_controller__WEBPACK_IMPORTED_MODULE_34__["default"]),
/* harmony export */   "Deck": () => (/* reexport safe */ _lib_deck__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   "DeckRenderer": () => (/* reexport safe */ _lib_deck_renderer__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   "DirectionalLight": () => (/* reexport safe */ _effects_lighting_directional_light__WEBPACK_IMPORTED_MODULE_4__.DirectionalLight),
/* harmony export */   "FirstPersonController": () => (/* reexport safe */ _controllers_first_person_controller__WEBPACK_IMPORTED_MODULE_37__["default"]),
/* harmony export */   "FirstPersonView": () => (/* reexport safe */ _views_first_person_view__WEBPACK_IMPORTED_MODULE_30__["default"]),
/* harmony export */   "FirstPersonViewport": () => (/* reexport safe */ _viewports_first_person_viewport__WEBPACK_IMPORTED_MODULE_22__["default"]),
/* harmony export */   "FlyToInterpolator": () => (/* reexport safe */ _transitions_fly_to_interpolator__WEBPACK_IMPORTED_MODULE_44__["default"]),
/* harmony export */   "Layer": () => (/* reexport safe */ _lib_layer__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   "LayerExtension": () => (/* reexport safe */ _lib_layer_extension__WEBPACK_IMPORTED_MODULE_40__["default"]),
/* harmony export */   "LayerManager": () => (/* reexport safe */ _lib_layer_manager__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   "LightingEffect": () => (/* reexport safe */ _effects_lighting_lighting_effect__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "LinearInterpolator": () => (/* reexport safe */ _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_43__["default"]),
/* harmony export */   "MapController": () => (/* reexport safe */ _controllers_map_controller__WEBPACK_IMPORTED_MODULE_35__["default"]),
/* harmony export */   "MapView": () => (/* reexport safe */ _views_map_view__WEBPACK_IMPORTED_MODULE_29__["default"]),
/* harmony export */   "OPERATION": () => (/* reexport safe */ _lib_constants__WEBPACK_IMPORTED_MODULE_1__.OPERATION),
/* harmony export */   "OrbitController": () => (/* reexport safe */ _controllers_orbit_controller__WEBPACK_IMPORTED_MODULE_38__["default"]),
/* harmony export */   "OrbitView": () => (/* reexport safe */ _views_orbit_view__WEBPACK_IMPORTED_MODULE_31__["default"]),
/* harmony export */   "OrbitViewport": () => (/* reexport safe */ _viewports_orbit_viewport__WEBPACK_IMPORTED_MODULE_20__["default"]),
/* harmony export */   "OrthographicController": () => (/* reexport safe */ _controllers_orthographic_controller__WEBPACK_IMPORTED_MODULE_39__["default"]),
/* harmony export */   "OrthographicView": () => (/* reexport safe */ _views_orthographic_view__WEBPACK_IMPORTED_MODULE_32__["default"]),
/* harmony export */   "OrthographicViewport": () => (/* reexport safe */ _viewports_orthographic_viewport__WEBPACK_IMPORTED_MODULE_21__["default"]),
/* harmony export */   "PointLight": () => (/* reexport safe */ _effects_lighting_point_light__WEBPACK_IMPORTED_MODULE_5__.PointLight),
/* harmony export */   "PostProcessEffect": () => (/* reexport safe */ _effects_post_process_effect__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "TRANSITION_EVENTS": () => (/* reexport safe */ _controllers_transition_manager__WEBPACK_IMPORTED_MODULE_41__.TRANSITION_EVENTS),
/* harmony export */   "Tesselator": () => (/* reexport safe */ _utils_tesselator__WEBPACK_IMPORTED_MODULE_49__["default"]),
/* harmony export */   "TransitionInterpolator": () => (/* reexport safe */ _transitions_transition_interpolator__WEBPACK_IMPORTED_MODULE_42__["default"]),
/* harmony export */   "UNIT": () => (/* reexport safe */ _lib_constants__WEBPACK_IMPORTED_MODULE_1__.UNIT),
/* harmony export */   "VERSION": () => (/* reexport safe */ _lib_init__WEBPACK_IMPORTED_MODULE_0__.VERSION),
/* harmony export */   "View": () => (/* reexport safe */ _views_view__WEBPACK_IMPORTED_MODULE_28__["default"]),
/* harmony export */   "Viewport": () => (/* reexport safe */ _viewports_viewport__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   "WebMercatorViewport": () => (/* reexport safe */ _viewports_web_mercator_viewport__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   "_CameraLight": () => (/* reexport safe */ _effects_lighting_camera_light__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "_GlobeController": () => (/* reexport safe */ _controllers_globe_controller__WEBPACK_IMPORTED_MODULE_36__["default"]),
/* harmony export */   "_GlobeView": () => (/* reexport safe */ _views_globe_view__WEBPACK_IMPORTED_MODULE_33__["default"]),
/* harmony export */   "_GlobeViewport": () => (/* reexport safe */ _viewports_globe_viewport__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   "_LayersPass": () => (/* reexport safe */ _passes_layers_pass__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "_PickLayersPass": () => (/* reexport safe */ _passes_pick_layers_pass__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "_SunLight": () => (/* reexport safe */ _effects_lighting_sun_light__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "_compareProps": () => (/* reexport safe */ _lifecycle_props__WEBPACK_IMPORTED_MODULE_55__.compareProps),
/* harmony export */   "_count": () => (/* reexport safe */ _utils_count__WEBPACK_IMPORTED_MODULE_51__.count),
/* harmony export */   "_deepEqual": () => (/* reexport safe */ _utils_deep_equal__WEBPACK_IMPORTED_MODULE_52__.deepEqual),
/* harmony export */   "_fillArray": () => (/* reexport safe */ _utils_flatten__WEBPACK_IMPORTED_MODULE_50__.fillArray),
/* harmony export */   "_flatten": () => (/* reexport safe */ _utils_flatten__WEBPACK_IMPORTED_MODULE_50__.flatten),
/* harmony export */   "_memoize": () => (/* reexport safe */ _utils_memoize__WEBPACK_IMPORTED_MODULE_53__["default"]),
/* harmony export */   "_mergeShaders": () => (/* reexport safe */ _utils_shader__WEBPACK_IMPORTED_MODULE_54__.mergeShaders),
/* harmony export */   "assert": () => (/* reexport safe */ _utils_assert__WEBPACK_IMPORTED_MODULE_46__["default"]),
/* harmony export */   "createIterable": () => (/* reexport safe */ _utils_iterable_utils__WEBPACK_IMPORTED_MODULE_47__.createIterable),
/* harmony export */   "fp64LowPart": () => (/* reexport safe */ _utils_math_utils__WEBPACK_IMPORTED_MODULE_48__.fp64LowPart),
/* harmony export */   "gouraudLighting": () => (/* reexport safe */ _shaderlib__WEBPACK_IMPORTED_MODULE_26__.gouraudLighting),
/* harmony export */   "log": () => (/* reexport safe */ _utils_log__WEBPACK_IMPORTED_MODULE_45__["default"]),
/* harmony export */   "phongLighting": () => (/* reexport safe */ _shaderlib__WEBPACK_IMPORTED_MODULE_26__.phongLighting),
/* harmony export */   "picking": () => (/* reexport safe */ _shaderlib__WEBPACK_IMPORTED_MODULE_23__["default"]),
/* harmony export */   "project": () => (/* reexport safe */ _shaderlib__WEBPACK_IMPORTED_MODULE_24__["default"]),
/* harmony export */   "project32": () => (/* reexport safe */ _shaderlib__WEBPACK_IMPORTED_MODULE_25__["default"]),
/* harmony export */   "shadow": () => (/* reexport safe */ _shaderlib__WEBPACK_IMPORTED_MODULE_27__["default"])
/* harmony export */ });
/* harmony import */ var _lib_init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/init */ "./node_modules/@deck.gl/core/dist/esm/lib/init.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");
/* harmony import */ var _effects_lighting_lighting_effect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./effects/lighting/lighting-effect */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js");
/* harmony import */ var _effects_lighting_ambient_light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./effects/lighting/ambient-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js");
/* harmony import */ var _effects_lighting_directional_light__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./effects/lighting/directional-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js");
/* harmony import */ var _effects_lighting_point_light__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./effects/lighting/point-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/point-light.js");
/* harmony import */ var _effects_lighting_camera_light__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./effects/lighting/camera-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/camera-light.js");
/* harmony import */ var _effects_lighting_sun_light__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./effects/lighting/sun-light */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/sun-light.js");
/* harmony import */ var _effects_post_process_effect__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./effects/post-process-effect */ "./node_modules/@deck.gl/core/dist/esm/effects/post-process-effect.js");
/* harmony import */ var _passes_layers_pass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./passes/layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js");
/* harmony import */ var _passes_pick_layers_pass__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./passes/pick-layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js");
/* harmony import */ var _lib_deck__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/deck */ "./node_modules/@deck.gl/core/dist/esm/lib/deck.js");
/* harmony import */ var _lib_layer_manager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/layer-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js");
/* harmony import */ var _lib_attribute_attribute_manager__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/attribute/attribute-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js");
/* harmony import */ var _lib_layer__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/layer */ "./node_modules/@deck.gl/core/dist/esm/lib/layer.js");
/* harmony import */ var _lib_composite_layer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/composite-layer */ "./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js");
/* harmony import */ var _lib_deck_renderer__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/deck-renderer */ "./node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js");
/* harmony import */ var _viewports_viewport__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./viewports/viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _viewports_web_mercator_viewport__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./viewports/web-mercator-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js");
/* harmony import */ var _viewports_globe_viewport__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./viewports/globe-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js");
/* harmony import */ var _viewports_orbit_viewport__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./viewports/orbit-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js");
/* harmony import */ var _viewports_orthographic_viewport__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./viewports/orthographic-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js");
/* harmony import */ var _viewports_first_person_viewport__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./viewports/first-person-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js");
/* harmony import */ var _shaderlib__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./shaderlib */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js");
/* harmony import */ var _shaderlib__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./shaderlib */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js");
/* harmony import */ var _shaderlib__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./shaderlib */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js");
/* harmony import */ var _shaderlib__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./shaderlib */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js");
/* harmony import */ var _shaderlib__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./shaderlib */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js");
/* harmony import */ var _views_view__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./views/view */ "./node_modules/@deck.gl/core/dist/esm/views/view.js");
/* harmony import */ var _views_map_view__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./views/map-view */ "./node_modules/@deck.gl/core/dist/esm/views/map-view.js");
/* harmony import */ var _views_first_person_view__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./views/first-person-view */ "./node_modules/@deck.gl/core/dist/esm/views/first-person-view.js");
/* harmony import */ var _views_orbit_view__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./views/orbit-view */ "./node_modules/@deck.gl/core/dist/esm/views/orbit-view.js");
/* harmony import */ var _views_orthographic_view__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./views/orthographic-view */ "./node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js");
/* harmony import */ var _views_globe_view__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./views/globe-view */ "./node_modules/@deck.gl/core/dist/esm/views/globe-view.js");
/* harmony import */ var _controllers_controller__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./controllers/controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/controller.js");
/* harmony import */ var _controllers_map_controller__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./controllers/map-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js");
/* harmony import */ var _controllers_globe_controller__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./controllers/globe-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js");
/* harmony import */ var _controllers_first_person_controller__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./controllers/first-person-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js");
/* harmony import */ var _controllers_orbit_controller__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./controllers/orbit-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js");
/* harmony import */ var _controllers_orthographic_controller__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./controllers/orthographic-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js");
/* harmony import */ var _lib_layer_extension__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./lib/layer-extension */ "./node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js");
/* harmony import */ var _controllers_transition_manager__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./controllers/transition-manager */ "./node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js");
/* harmony import */ var _transitions_transition_interpolator__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./transitions/transition-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js");
/* harmony import */ var _transitions_linear_interpolator__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./transitions/linear-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js");
/* harmony import */ var _transitions_fly_to_interpolator__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./transitions/fly-to-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _utils_iterable_utils__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./utils/iterable-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _utils_tesselator__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./utils/tesselator */ "./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js");
/* harmony import */ var _utils_flatten__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./utils/flatten */ "./node_modules/@deck.gl/core/dist/esm/utils/flatten.js");
/* harmony import */ var _utils_count__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./utils/count */ "./node_modules/@deck.gl/core/dist/esm/utils/count.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");
/* harmony import */ var _utils_memoize__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./utils/memoize */ "./node_modules/@deck.gl/core/dist/esm/utils/memoize.js");
/* harmony import */ var _utils_shader__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./utils/shader */ "./node_modules/@deck.gl/core/dist/esm/utils/shader.js");
/* harmony import */ var _lifecycle_props__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./lifecycle/props */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/props.js");






















































/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AttributeManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _attribute__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./attribute */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _utils_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/memoize */ "./node_modules/@deck.gl/core/dist/esm/utils/memoize.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../debug */ "./node_modules/@deck.gl/core/dist/esm/debug/index.js");
/* harmony import */ var _attribute_transition_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attribute-transition-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js");







const TRACE_INVALIDATE = 'attributeManager.invalidate';
const TRACE_UPDATE_START = 'attributeManager.updateStart';
const TRACE_UPDATE_END = 'attributeManager.updateEnd';
const TRACE_ATTRIBUTE_UPDATE_START = 'attribute.updateStart';
const TRACE_ATTRIBUTE_ALLOCATE = 'attribute.allocate';
const TRACE_ATTRIBUTE_UPDATE_END = 'attribute.updateEnd';
class AttributeManager {
  constructor(gl, {
    id = 'attribute-manager',
    stats,
    timeline
  } = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attributes", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "updateTriggers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "needsRedraw", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "userData", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "stats", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attributeTransitionManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "mergeBoundsMemoized", (0,_utils_memoize__WEBPACK_IMPORTED_MODULE_1__["default"])(_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.mergeBounds));

    this.id = id;
    this.gl = gl;
    this.attributes = {};
    this.updateTriggers = {};
    this.needsRedraw = true;
    this.userData = {};
    this.stats = stats;
    this.attributeTransitionManager = new _attribute_transition_manager__WEBPACK_IMPORTED_MODULE_3__["default"](gl, {
      id: "".concat(id, "-transitions"),
      timeline
    });
    Object.seal(this);
  }

  finalize() {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].delete();
    }

    this.attributeTransitionManager.finalize();
  }

  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this.needsRedraw;
    this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
    return redraw && this.id;
  }

  setNeedsRedraw() {
    this.needsRedraw = true;
  }

  add(attributes) {
    this._add(attributes);
  }

  addInstanced(attributes) {
    this._add(attributes, {
      instanced: 1
    });
  }

  remove(attributeNameArray) {
    for (const name of attributeNameArray) {
      if (this.attributes[name] !== undefined) {
        this.attributes[name].delete();
        delete this.attributes[name];
      }
    }
  }

  invalidate(triggerName, dataRange) {
    const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);

    (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
  }

  invalidateAll(dataRange) {
    for (const attributeName in this.attributes) {
      this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
    }

    (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_INVALIDATE, this, 'all');
  }

  update({
    data,
    numInstances,
    startIndices = null,
    transitions,
    props = {},
    buffers = {},
    context = {}
  }) {
    let updated = false;
    (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_UPDATE_START, this);

    if (this.stats) {
      this.stats.get('Update Attributes').timeStart();
    }

    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      const accessorName = attribute.settings.accessor;
      attribute.startIndices = startIndices;
      attribute.numInstances = numInstances;

      if (props[attributeName]) {
        _utils_log__WEBPACK_IMPORTED_MODULE_5__["default"].removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
      }

      if (attribute.setExternalBuffer(buffers[attributeName])) {} else if (attribute.setBinaryValue(typeof accessorName === 'string' ? buffers[accessorName] : undefined, data.startIndices)) {} else if (typeof accessorName === 'string' && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {} else if (attribute.needsUpdate()) {
        updated = true;

        this._updateAttribute({
          attribute,
          numInstances,
          data,
          props,
          context
        });
      }

      this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
    }

    if (updated) {
      (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_UPDATE_END, this, numInstances);
    }

    if (this.stats) {
      this.stats.get('Update Attributes').timeEnd();
    }

    this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances,
      transitions
    });
  }

  updateTransition() {
    const {
      attributeTransitionManager
    } = this;
    const transitionUpdated = attributeTransitionManager.run();
    this.needsRedraw = this.needsRedraw || transitionUpdated;
    return transitionUpdated;
  }

  getAttributes() {
    return this.attributes;
  }

  getBounds(attributeNames) {
    const bounds = attributeNames.map(attributeName => {
      var _this$attributes$attr;

      return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
    });
    return this.mergeBoundsMemoized(bounds);
  }

  getChangedAttributes(opts = {
    clearChangedFlags: false
  }) {
    const {
      attributes,
      attributeTransitionManager
    } = this;
    const changedAttributes = { ...attributeTransitionManager.getAttributes()
    };

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];

      if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
        changedAttributes[attributeName] = attribute;
      }
    }

    return changedAttributes;
  }

  getShaderAttributes(attributes, excludeAttributes = {}) {
    if (!attributes) {
      attributes = this.getAttributes();
    }

    const shaderAttributes = {};

    for (const attributeName in attributes) {
      if (!excludeAttributes[attributeName]) {
        Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
      }
    }

    return shaderAttributes;
  }

  _add(attributes, extraProps = {}) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
    }

    this._mapUpdateTriggersToAttributes();
  }

  _createAttribute(name, attribute, extraProps) {
    const props = { ...attribute,
      id: name,
      size: attribute.isIndexed && 1 || attribute.size || 1,
      divisor: extraProps.instanced ? 1 : attribute.divisor || 0
    };
    return new _attribute__WEBPACK_IMPORTED_MODULE_6__["default"](this.gl, props);
  }

  _mapUpdateTriggersToAttributes() {
    const triggers = {};

    for (const attributeName in this.attributes) {
      const attribute = this.attributes[attributeName];
      attribute.getUpdateTriggers().forEach(triggerName => {
        if (!triggers[triggerName]) {
          triggers[triggerName] = [];
        }

        triggers[triggerName].push(attributeName);
      });
    }

    this.updateTriggers = triggers;
  }

  _invalidateTrigger(triggerName, dataRange) {
    const {
      attributes,
      updateTriggers
    } = this;
    const invalidatedAttributes = updateTriggers[triggerName];

    if (invalidatedAttributes) {
      invalidatedAttributes.forEach(name => {
        const attribute = attributes[name];

        if (attribute) {
          attribute.setNeedsUpdate(attribute.id, dataRange);
        }
      });
    }

    return invalidatedAttributes;
  }

  _updateAttribute(opts) {
    const {
      attribute,
      numInstances
    } = opts;
    (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_ATTRIBUTE_UPDATE_START, attribute);

    if (attribute.constant) {
      attribute.setConstantValue(attribute.value);
      return;
    }

    if (attribute.allocate(numInstances)) {
      (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
    }

    const updated = attribute.updateBuffer(opts);

    if (updated) {
      this.needsRedraw = true;
      (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AttributeTransitionManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/transform/transform.js");
/* harmony import */ var _transitions_gpu_interpolation_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../transitions/gpu-interpolation-transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js");
/* harmony import */ var _transitions_gpu_spring_transition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../transitions/gpu-spring-transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");





const TRANSITION_TYPES = {
  interpolation: _transitions_gpu_interpolation_transition__WEBPACK_IMPORTED_MODULE_1__["default"],
  spring: _transitions_gpu_spring_transition__WEBPACK_IMPORTED_MODULE_2__["default"]
};
class AttributeTransitionManager {
  constructor(gl, {
    id,
    timeline
  }) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isSupported", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "timeline", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transitions", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "needsRedraw", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "numInstances", void 0);

    this.id = id;
    this.gl = gl;
    this.timeline = timeline;
    this.transitions = {};
    this.needsRedraw = false;
    this.numInstances = 1;
    this.isSupported = _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"].isSupported(gl);
  }

  finalize() {
    for (const attributeName in this.transitions) {
      this._removeTransition(attributeName);
    }
  }

  update({
    attributes,
    transitions,
    numInstances
  }) {
    this.numInstances = numInstances || 1;

    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const settings = attribute.getTransitionSetting(transitions);
      if (!settings) continue;

      this._updateAttribute(attributeName, attribute, settings);
    }

    for (const attributeName in this.transitions) {
      const attribute = attributes[attributeName];

      if (!attribute || !attribute.getTransitionSetting(transitions)) {
        this._removeTransition(attributeName);
      }
    }
  }

  hasAttribute(attributeName) {
    const transition = this.transitions[attributeName];
    return transition && transition.inProgress;
  }

  getAttributes() {
    const animatedAttributes = {};

    for (const attributeName in this.transitions) {
      const transition = this.transitions[attributeName];

      if (transition.inProgress) {
        animatedAttributes[attributeName] = transition.attributeInTransition;
      }
    }

    return animatedAttributes;
  }

  run() {
    if (!this.isSupported || this.numInstances === 0) {
      return false;
    }

    for (const attributeName in this.transitions) {
      const updated = this.transitions[attributeName].update();

      if (updated) {
        this.needsRedraw = true;
      }
    }

    const needsRedraw = this.needsRedraw;
    this.needsRedraw = false;
    return needsRedraw;
  }

  _removeTransition(attributeName) {
    this.transitions[attributeName].cancel();
    delete this.transitions[attributeName];
  }

  _updateAttribute(attributeName, attribute, settings) {
    const transition = this.transitions[attributeName];
    let isNew = !transition || transition.type !== settings.type;

    if (isNew) {
      if (!this.isSupported) {
        _utils_log__WEBPACK_IMPORTED_MODULE_4__["default"].warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
        return;
      }

      if (transition) {
        this._removeTransition(attributeName);
      }

      const TransitionType = TRANSITION_TYPES[settings.type];

      if (TransitionType) {
        this.transitions[attributeName] = new TransitionType({
          attribute,
          timeline: this.timeline,
          gl: this.gl
        });
      } else {
        _utils_log__WEBPACK_IMPORTED_MODULE_4__["default"].error("unsupported transition type '".concat(settings.type, "'"))();
        isNew = false;
      }
    }

    if (isNew || attribute.needsRedraw()) {
      this.needsRedraw = true;
      this.transitions[attributeName].start(settings, this.numInstances);
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cycleBuffers": () => (/* binding */ cycleBuffers),
/* harmony export */   "getAttributeBufferLength": () => (/* binding */ getAttributeBufferLength),
/* harmony export */   "getAttributeTypeFromSize": () => (/* binding */ getAttributeTypeFromSize),
/* harmony export */   "getSourceBufferAttribute": () => (/* binding */ getSourceBufferAttribute),
/* harmony export */   "normalizeTransitionSettings": () => (/* binding */ normalizeTransitionSettings),
/* harmony export */   "padBuffer": () => (/* binding */ padBuffer)
/* harmony export */ });
/* harmony import */ var _utils_array_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/array-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/array-utils.js");

const DEFAULT_TRANSITION_SETTINGS = {
  interpolation: {
    duration: 0,
    easing: t => t
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function normalizeTransitionSettings(userSettings, layerSettings) {
  if (!userSettings) {
    return null;
  }

  if (Number.isFinite(userSettings)) {
    userSettings = {
      type: 'interpolation',
      duration: userSettings
    };
  }

  const type = userSettings.type || 'interpolation';
  return { ...DEFAULT_TRANSITION_SETTINGS[type],
    ...layerSettings,
    ...userSettings,
    type
  };
}
function getSourceBufferAttribute(gl, attribute) {
  const buffer = attribute.getBuffer();

  if (buffer) {
    return [buffer, {
      divisor: 0,
      size: attribute.size,
      normalized: attribute.settings.normalized
    }];
  }

  return attribute.value;
}
function getAttributeTypeFromSize(size) {
  switch (size) {
    case 1:
      return 'float';

    case 2:
      return 'vec2';

    case 3:
      return 'vec3';

    case 4:
      return 'vec4';

    default:
      throw new Error("No defined attribute type for size \"".concat(size, "\""));
  }
}
function cycleBuffers(buffers) {
  buffers.push(buffers.shift());
}
function getAttributeBufferLength(attribute, numInstances) {
  const {
    doublePrecision,
    settings,
    value,
    size
  } = attribute;
  const multiplier = doublePrecision && value instanceof Float64Array ? 2 : 1;
  return (settings.noAlloc ? value.length : numInstances * size) * multiplier;
}
function padBuffer({
  buffer,
  numInstances,
  attribute,
  fromLength,
  fromStartIndices,
  getData = x => x
}) {
  const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
  const size = attribute.size * precisionMultiplier;
  const byteOffset = attribute.byteOffset;
  const toStartIndices = attribute.startIndices;
  const hasStartIndices = fromStartIndices && toStartIndices;
  const toLength = getAttributeBufferLength(attribute, numInstances);
  const isConstant = attribute.isConstant;

  if (!hasStartIndices && fromLength >= toLength) {
    return;
  }

  const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
    srcByteOffset: byteOffset
  });

  if (attribute.settings.normalized && !isConstant) {
    const getter = getData;

    getData = (value, chunk) => attribute.normalizeConstant(getter(value, chunk));
  }

  const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size), chunk);
  const source = buffer.getData({
    length: fromLength
  });
  const data = new Float32Array(toLength);
  (0,_utils_array_utils__WEBPACK_IMPORTED_MODULE_0__.padArray)({
    source,
    target: data,
    sourceStartIndices: fromStartIndices,
    targetStartIndices: toStartIndices,
    size,
    getData: getMissingData
  });

  if (buffer.byteLength < data.byteLength + byteOffset) {
    buffer.reallocate(data.byteLength + byteOffset);
  }

  buffer.subData({
    data,
    offset: byteOffset
  });
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Attribute)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _data_column__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./data-column */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _utils_iterable_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/iterable-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js");
/* harmony import */ var _utils_flatten__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/flatten */ "./node_modules/@deck.gl/core/dist/esm/utils/flatten.js");
/* harmony import */ var _utils_range__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/range */ "./node_modules/@deck.gl/core/dist/esm/utils/range.js");
/* harmony import */ var _attribute_transition_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./attribute-transition-utils */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js");







class Attribute extends _data_column__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, opts) {
    super(gl, opts, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: true,
      needsRedraw: false,
      updateRanges: _utils_range__WEBPACK_IMPORTED_MODULE_2__.FULL
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "constant", false);

    this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : undefined);
    Object.seal(this.settings);
    Object.seal(this.state);

    this._validateAttributeUpdaters();
  }

  get startIndices() {
    return this.state.startIndices;
  }

  set startIndices(layout) {
    this.state.startIndices = layout;
  }

  needsUpdate() {
    return this.state.needsUpdate;
  }

  needsRedraw({
    clearChangedFlags = false
  } = {}) {
    const needsRedraw = this.state.needsRedraw;
    this.state.needsRedraw = needsRedraw && !clearChangedFlags;
    return needsRedraw;
  }

  getUpdateTriggers() {
    const {
      accessor
    } = this.settings;
    return [this.id].concat(typeof accessor !== 'function' && accessor || []);
  }

  supportsTransition() {
    return Boolean(this.settings.transition);
  }

  getTransitionSetting(opts) {
    if (!opts || !this.supportsTransition()) {
      return null;
    }

    const {
      accessor
    } = this.settings;
    const layerSettings = this.settings.transition;
    const userSettings = Array.isArray(accessor) ? opts[accessor.find(a => opts[a])] : opts[accessor];
    return (0,_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_3__.normalizeTransitionSettings)(userSettings, layerSettings);
  }

  setNeedsUpdate(reason = this.id, dataRange) {
    this.state.needsUpdate = this.state.needsUpdate || reason;
    this.setNeedsRedraw(reason);

    if (dataRange) {
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange;
      this.state.updateRanges = _utils_range__WEBPACK_IMPORTED_MODULE_2__.add(this.state.updateRanges, [startRow, endRow]);
    } else {
      this.state.updateRanges = _utils_range__WEBPACK_IMPORTED_MODULE_2__.FULL;
    }
  }

  clearNeedsUpdate() {
    this.state.needsUpdate = false;
    this.state.updateRanges = _utils_range__WEBPACK_IMPORTED_MODULE_2__.EMPTY;
  }

  setNeedsRedraw(reason = this.id) {
    this.state.needsRedraw = this.state.needsRedraw || reason;
  }

  allocate(numInstances) {
    const {
      state,
      settings
    } = this;

    if (settings.noAlloc) {
      return false;
    }

    if (settings.update) {
      super.allocate(numInstances, state.updateRanges !== _utils_range__WEBPACK_IMPORTED_MODULE_2__.FULL);
      return true;
    }

    return false;
  }

  updateBuffer({
    numInstances,
    data,
    props,
    context
  }) {
    if (!this.needsUpdate()) {
      return false;
    }

    const {
      state: {
        updateRanges
      },
      settings: {
        update,
        noAlloc
      }
    } = this;
    let updated = true;

    if (update) {
      for (const [startRow, endRow] of updateRanges) {
        update.call(context, this, {
          data,
          startRow,
          endRow,
          props,
          numInstances
        });
      }

      if (!this.value) {} else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
        this.setData({
          value: this.value,
          constant: this.constant
        });
        this.constant = false;
      } else {
        for (const [startRow, endRow] of updateRanges) {
          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
          const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
          super.updateSubBuffer({
            startOffset,
            endOffset
          });
        }
      }

      this._checkAttributeArray();
    } else {
      updated = false;
    }

    this.clearNeedsUpdate();
    this.setNeedsRedraw();
    return updated;
  }

  setConstantValue(value) {
    if (value === undefined || typeof value === 'function') {
      return false;
    }

    const hasChanged = this.setData({
      constant: true,
      value
    });

    if (hasChanged) {
      this.setNeedsRedraw();
    }

    this.clearNeedsUpdate();
    return true;
  }

  setExternalBuffer(buffer) {
    const {
      state
    } = this;

    if (!buffer) {
      state.lastExternalBuffer = null;
      return false;
    }

    this.clearNeedsUpdate();

    if (state.lastExternalBuffer === buffer) {
      return true;
    }

    state.lastExternalBuffer = buffer;
    this.setNeedsRedraw();
    this.setData(buffer);
    return true;
  }

  setBinaryValue(buffer, startIndices = null) {
    const {
      state,
      settings
    } = this;

    if (!buffer) {
      state.binaryValue = null;
      state.binaryAccessor = null;
      return false;
    }

    if (settings.noAlloc) {
      return false;
    }

    if (state.binaryValue === buffer) {
      this.clearNeedsUpdate();
      return true;
    }

    state.binaryValue = buffer;
    this.setNeedsRedraw();
    const needsUpdate = settings.transform || startIndices !== this.startIndices;

    if (needsUpdate) {
      if (ArrayBuffer.isView(buffer)) {
        buffer = {
          value: buffer
        };
      }

      const binaryValue = buffer;
      (0,_utils_assert__WEBPACK_IMPORTED_MODULE_4__["default"])(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
      const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
      state.binaryAccessor = (0,_utils_iterable_utils__WEBPACK_IMPORTED_MODULE_5__.getAccessorFromBuffer)(binaryValue.value, {
        size: binaryValue.size || this.size,
        stride: binaryValue.stride,
        offset: binaryValue.offset,
        startIndices: startIndices,
        nested: needsNormalize
      });
      return false;
    }

    this.clearNeedsUpdate();
    this.setData(buffer);
    return true;
  }

  getVertexOffset(row) {
    const {
      startIndices
    } = this;
    const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
    return vertexIndex * this.size;
  }

  getShaderAttributes() {
    const shaderAttributeDefs = this.settings.shaderAttributes || {
      [this.id]: null
    };
    const shaderAttributes = {};

    for (const shaderAttributeName in shaderAttributeDefs) {
      Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
    }

    return shaderAttributes;
  }

  _autoUpdater(attribute, {
    data,
    startRow,
    endRow,
    props,
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }

    const {
      settings,
      state,
      value,
      size,
      startIndices
    } = attribute;
    const {
      accessor,
      transform
    } = settings;
    const accessorFunc = state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_4__["default"])(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
    let i = attribute.getVertexOffset(startRow);
    const {
      iterable,
      objectInfo
    } = (0,_utils_iterable_utils__WEBPACK_IMPORTED_MODULE_5__.createIterable)(data, startRow, endRow);

    for (const object of iterable) {
      objectInfo.index++;
      let objectValue = accessorFunc(object, objectInfo);

      if (transform) {
        objectValue = transform.call(this, objectValue);
      }

      if (startIndices) {
        const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];

        if (objectValue && Array.isArray(objectValue[0])) {
          let startIndex = i;

          for (const item of objectValue) {
            attribute._normalizeValue(item, value, startIndex);

            startIndex += size;
          }
        } else if (objectValue && objectValue.length > size) {
          value.set(objectValue, i);
        } else {
          attribute._normalizeValue(objectValue, objectInfo.target, 0);

          (0,_utils_flatten__WEBPACK_IMPORTED_MODULE_6__.fillArray)({
            target: value,
            source: objectInfo.target,
            start: i,
            count: numVertices
          });
        }

        i += numVertices * size;
      } else {
        attribute._normalizeValue(objectValue, value, i);

        i += size;
      }
    }
  }

  _validateAttributeUpdaters() {
    const {
      settings
    } = this;
    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';

    if (!hasUpdater) {
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
    }
  }

  _checkAttributeArray() {
    const {
      value
    } = this;
    const limit = Math.min(4, this.size);

    if (value && value.length >= limit) {
      let valid = true;

      switch (limit) {
        case 4:
          valid = valid && Number.isFinite(value[3]);

        case 3:
          valid = valid && Number.isFinite(value[2]);

        case 2:
          valid = valid && Number.isFinite(value[1]);

        case 1:
          valid = valid && Number.isFinite(value[0]);
          break;

        default:
          valid = false;
      }

      if (!valid) {
        throw new Error("Illegal attribute generated for ".concat(this.id));
      }
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DataColumn)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/features/features.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _shader_attribute__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shader-attribute */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js");
/* harmony import */ var _gl_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gl-utils */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js");
/* harmony import */ var _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/typed-array-manager */ "./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");








function getStride(accessor) {
  return accessor.stride || accessor.size * accessor.bytesPerElement;
}

function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
  if (shaderAttributeOptions.offset) {
    _utils_log__WEBPACK_IMPORTED_MODULE_1__["default"].removed('shaderAttribute.offset', 'vertexOffset, elementOffset')();
  }

  const stride = getStride(baseAccessor);
  const vertexOffset = shaderAttributeOptions.vertexOffset !== undefined ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
  const elementOffset = shaderAttributeOptions.elementOffset || 0;
  const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
  return { ...shaderAttributeOptions,
    offset,
    stride
  };
}

function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
  const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
  return {
    high: resolvedOptions,
    low: { ...resolvedOptions,
      offset: resolvedOptions.offset + baseAccessor.size * 4
    }
  };
}

class DataColumn {
  constructor(gl, opts, state) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "size", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "settings", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "value", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "doublePrecision", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_buffer", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "state", void 0);

    this.gl = gl;
    this.id = opts.id || '';
    this.size = opts.size || 1;
    const logicalType = opts.logicalType || opts.type;
    const doublePrecision = logicalType === 5130;
    let {
      defaultValue
    } = opts;
    defaultValue = Number.isFinite(defaultValue) ? [defaultValue] : defaultValue || new Array(this.size).fill(0);
    let bufferType;

    if (doublePrecision) {
      bufferType = 5126;
    } else if (!logicalType && opts.isIndexed) {
      bufferType = gl && (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.hasFeature)(gl, _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__.FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
    } else {
      bufferType = logicalType || 5126;
    }

    let defaultType = (0,_gl_utils__WEBPACK_IMPORTED_MODULE_4__.glArrayFromType)(logicalType || bufferType || 5126);
    this.doublePrecision = doublePrecision;

    if (doublePrecision && opts.fp64 === false) {
      defaultType = Float32Array;
    }

    this.value = null;
    this.settings = { ...opts,
      defaultType,
      defaultValue: defaultValue,
      logicalType,
      type: bufferType,
      size: this.size,
      bytesPerElement: defaultType.BYTES_PER_ELEMENT
    };
    this.state = { ...state,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: false
    };
    this._buffer = null;
  }

  get isConstant() {
    return this.state.constant;
  }

  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed,
        type
      } = this.settings;
      this._buffer = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__["default"](this.gl, {
        id: this.id,
        target: isIndexed ? 34963 : 34962,
        accessor: {
          type
        }
      });
    }

    return this._buffer;
  }

  get byteOffset() {
    const accessor = this.getAccessor();

    if (accessor.vertexOffset) {
      return accessor.vertexOffset * getStride(accessor);
    }

    return 0;
  }

  get numInstances() {
    return this.state.numInstances;
  }

  set numInstances(n) {
    this.state.numInstances = n;
  }

  delete() {
    if (this._buffer) {
      this._buffer.delete();

      this._buffer = null;
    }

    _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_6__["default"].release(this.state.allocatedValue);
  }

  getShaderAttributes(id, options) {
    if (this.doublePrecision) {
      const shaderAttributes = {};
      const isBuffer64Bit = this.value instanceof Float64Array;
      const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options || {});
      shaderAttributes[id] = new _shader_attribute__WEBPACK_IMPORTED_MODULE_7__["default"](this, doubleShaderAttributeDefs.high);
      shaderAttributes["".concat(id, "64Low")] = isBuffer64Bit ? new _shader_attribute__WEBPACK_IMPORTED_MODULE_7__["default"](this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
      return shaderAttributes;
    }

    if (options) {
      const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options);
      return {
        [id]: new _shader_attribute__WEBPACK_IMPORTED_MODULE_7__["default"](this, shaderAttributeDef)
      };
    }

    return {
      [id]: this
    };
  }

  getBuffer() {
    if (this.state.constant) {
      return null;
    }

    return this.state.externalBuffer || this._buffer;
  }

  getValue() {
    if (this.state.constant) {
      return this.value;
    }

    return [this.getBuffer(), this.getAccessor()];
  }

  getAccessor() {
    return this.state.bufferAccessor;
  }

  getBounds() {
    if (this.state.bounds) {
      return this.state.bounds;
    }

    let result = null;

    if (this.state.constant && this.value) {
      const min = Array.from(this.value);
      result = [min, min];
    } else {
      const {
        value,
        numInstances,
        size
      } = this;
      const len = numInstances * size;

      if (value && len && value.length >= len) {
        const min = new Array(size).fill(Infinity);
        const max = new Array(size).fill(-Infinity);

        for (let i = 0; i < len;) {
          for (let j = 0; j < size; j++) {
            const v = value[i++];
            if (v < min[j]) min[j] = v;
            if (v > max[j]) max[j] = v;
          }
        }

        result = [min, max];
      }
    }

    this.state.bounds = result;
    return result;
  }

  setData(data) {
    const {
      state
    } = this;
    let opts;

    if (ArrayBuffer.isView(data)) {
      opts = {
        value: data
      };
    } else if (data instanceof _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__["default"]) {
      opts = {
        buffer: data
      };
    } else {
      opts = data;
    }

    const accessor = { ...this.settings,
      ...opts
    };
    state.bufferAccessor = accessor;
    state.bounds = null;

    if (opts.constant) {
      let value = opts.value;
      value = this._normalizeValue(value, [], 0);

      if (this.settings.normalized) {
        value = this.normalizeConstant(value);
      }

      const hasChanged = !state.constant || !this._areValuesEqual(value, this.value);

      if (!hasChanged) {
        return false;
      }

      state.externalBuffer = null;
      state.constant = true;
      this.value = value;
    } else if (opts.buffer) {
      const buffer = opts.buffer;
      state.externalBuffer = buffer;
      state.constant = false;
      this.value = opts.value || null;
      const isBuffer64Bit = opts.value instanceof Float64Array;
      accessor.type = opts.type || buffer.accessor.type;
      accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
      accessor.stride = getStride(accessor);
    } else if (opts.value) {
      this._checkExternalBuffer(opts);

      let value = opts.value;
      state.externalBuffer = null;
      state.constant = false;
      this.value = value;
      accessor.bytesPerElement = value.BYTES_PER_ELEMENT;
      accessor.stride = getStride(accessor);
      const {
        buffer,
        byteOffset
      } = this;

      if (this.doublePrecision && value instanceof Float64Array) {
        value = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_8__.toDoublePrecisionArray)(value, accessor);
      }

      const requiredBufferSize = value.byteLength + byteOffset + accessor.stride * 2;

      if (buffer.byteLength < requiredBufferSize) {
        buffer.reallocate(requiredBufferSize);
      }

      buffer.setAccessor(null);
      buffer.subData({
        data: value,
        offset: byteOffset
      });
      accessor.type = opts.type || buffer.accessor.type;
    }

    return true;
  }

  updateSubBuffer(opts = {}) {
    this.state.bounds = null;
    const value = this.value;
    const {
      startOffset = 0,
      endOffset
    } = opts;
    this.buffer.subData({
      data: this.doublePrecision && value instanceof Float64Array ? (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_8__.toDoublePrecisionArray)(value, {
        size: this.size,
        startIndex: startOffset,
        endIndex: endOffset
      }) : value.subarray(startOffset, endOffset),
      offset: startOffset * value.BYTES_PER_ELEMENT + this.byteOffset
    });
  }

  allocate(numInstances, copy = false) {
    const {
      state
    } = this;
    const oldValue = state.allocatedValue;
    const value = _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_6__["default"].allocate(oldValue, numInstances + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy
    });
    this.value = value;
    const {
      buffer,
      byteOffset
    } = this;

    if (buffer.byteLength < value.byteLength + byteOffset) {
      buffer.reallocate(value.byteLength + byteOffset);

      if (copy && oldValue) {
        buffer.subData({
          data: oldValue instanceof Float64Array ? (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_8__.toDoublePrecisionArray)(oldValue, this) : oldValue,
          offset: byteOffset
        });
      }
    }

    state.allocatedValue = value;
    state.constant = false;
    state.externalBuffer = null;
    state.bufferAccessor = this.settings;
    return true;
  }

  _checkExternalBuffer(opts) {
    const {
      value
    } = opts;

    if (!ArrayBuffer.isView(value)) {
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    }

    const ArrayType = this.settings.defaultType;
    let illegalArrayType = false;

    if (this.doublePrecision) {
      illegalArrayType = value.BYTES_PER_ELEMENT < 4;
    }

    if (illegalArrayType) {
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(value.constructor.name));
    }

    if (!(value instanceof ArrayType) && this.settings.normalized && !('normalized' in opts)) {
      _utils_log__WEBPACK_IMPORTED_MODULE_1__["default"].warn("Attribute ".concat(this.id, " is normalized"))();
    }
  }

  normalizeConstant(value) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(value).map(x => (x + 128) / 255 * 2 - 1);

      case 5122:
        return new Float32Array(value).map(x => (x + 32768) / 65535 * 2 - 1);

      case 5121:
        return new Float32Array(value).map(x => x / 255);

      case 5123:
        return new Float32Array(value).map(x => x / 65535);

      default:
        return value;
    }
  }

  _normalizeValue(value, out, start) {
    const {
      defaultValue,
      size
    } = this.settings;

    if (Number.isFinite(value)) {
      out[start] = value;
      return out;
    }

    if (!value) {
      let i = size;

      while (--i >= 0) {
        out[start + i] = defaultValue[i];
      }

      return out;
    }

    switch (size) {
      case 4:
        out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

      case 3:
        out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

      case 2:
        out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

      case 1:
        out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
        break;

      default:
        let i = size;

        while (--i >= 0) {
          out[start + i] = Number.isFinite(value[i]) ? value[i] : defaultValue[i];
        }

    }

    return out;
  }

  _areValuesEqual(value1, value2) {
    if (!value1 || !value2) {
      return false;
    }

    const {
      size
    } = this;

    for (let i = 0; i < size; i++) {
      if (value1[i] !== value2[i]) {
        return false;
      }
    }

    return true;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "glArrayFromType": () => (/* binding */ glArrayFromType)
/* harmony export */ });
function glArrayFromType(glType) {
  switch (glType) {
    case 5126:
      return Float32Array;

    case 5130:
      return Float64Array;

    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;

    case 5125:
      return Uint32Array;

    case 5121:
      return Uint8ClampedArray;

    case 5120:
      return Int8Array;

    case 5122:
      return Int16Array;

    case 5124:
      return Int32Array;

    default:
      throw new Error('Unknown GL type');
  }
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ShaderAttribute)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

class ShaderAttribute {
  constructor(dataColumn, opts) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "opts", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "source", void 0);

    this.opts = opts;
    this.source = dataColumn;
  }

  get value() {
    return this.source.value;
  }

  getValue() {
    const buffer = this.source.getBuffer();
    const accessor = this.getAccessor();

    if (buffer) {
      return [buffer, accessor];
    }

    const {
      value
    } = this.source;
    const {
      size
    } = accessor;
    let constantValue = value;

    if (value && value.length !== size) {
      constantValue = new Float32Array(size);
      const index = accessor.elementOffset || 0;

      for (let i = 0; i < size; ++i) {
        constantValue[i] = value[index + i];
      }
    }

    return constantValue;
  }

  getAccessor() {
    return { ...this.source.getAccessor(),
      ...this.opts
    };
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CompositeLayer)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer */ "./node_modules/@deck.gl/core/dist/esm/lib/layer.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../debug */ "./node_modules/@deck.gl/core/dist/esm/debug/index.js");
/* harmony import */ var _utils_flatten__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/flatten */ "./node_modules/@deck.gl/core/dist/esm/utils/flatten.js");
/* harmony import */ var _lifecycle_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lifecycle/constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");





const TRACE_RENDER_LAYERS = 'compositeLayer.renderLayers';
class CompositeLayer extends _layer__WEBPACK_IMPORTED_MODULE_1__["default"] {
  get isComposite() {
    return true;
  }

  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every(layer => layer.isLoaded);
  }

  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }

  initializeState(context) {}

  setState(updateObject) {
    super.setState(updateObject);
    this.setNeedsUpdate();
  }

  getPickingInfo({
    info
  }) {
    const {
      object
    } = info;
    const isDataWrapped = object && object.__source && object.__source.parent && object.__source.parent.id === this.id;

    if (!isDataWrapped) {
      return info;
    }

    info.object = object.__source.object;
    info.index = object.__source.index;
    return info;
  }

  filterSubLayer(context) {
    return true;
  }

  shouldRenderSubLayer(subLayerId, data) {
    return data && data.length;
  }

  getSubLayerClass(subLayerId, DefaultLayerClass) {
    const {
      _subLayerProps: overridingProps
    } = this.props;
    return overridingProps && overridingProps[subLayerId] && overridingProps[subLayerId].type || DefaultLayerClass;
  }

  getSubLayerRow(row, sourceObject, sourceObjectIndex) {
    row.__source = {
      parent: this,
      object: sourceObject,
      index: sourceObjectIndex
    };
    return row;
  }

  getSubLayerAccessor(accessor) {
    if (typeof accessor === 'function') {
      const objectInfo = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (x, i) => {
        if (x && x.__source) {
          objectInfo.index = x.__source.index;
          return accessor(x.__source.object, objectInfo);
        }

        return accessor(x, i);
      };
    }

    return accessor;
  }

  getSubLayerProps(sublayerProps = {}) {
    var _this$props$updateTri;

    const {
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation,
      _subLayerProps: overridingProps
    } = this.props;
    const newProps = {
      id: '',
      updateTriggers: {},
      opacity,
      pickable,
      visible,
      parameters,
      getPolygonOffset,
      highlightedObjectIndex,
      autoHighlight,
      highlightColor,
      coordinateSystem,
      coordinateOrigin,
      wrapLongitude,
      positionFormat,
      modelMatrix,
      extensions,
      fetch,
      operation
    };
    const overridingSublayerProps = overridingProps && sublayerProps.id && overridingProps[sublayerProps.id];
    const overridingSublayerTriggers = overridingSublayerProps && overridingSublayerProps.updateTriggers;
    const sublayerId = sublayerProps.id || 'sublayer';

    if (overridingSublayerProps) {
      const propTypes = this.props[_lifecycle_constants__WEBPACK_IMPORTED_MODULE_2__.PROP_TYPES_SYMBOL];
      const subLayerPropTypes = sublayerProps.type ? sublayerProps.type._propTypes : {};

      for (const key in overridingSublayerProps) {
        const propType = subLayerPropTypes[key] || propTypes[key];

        if (propType && propType.type === 'accessor') {
          overridingSublayerProps[key] = this.getSubLayerAccessor(overridingSublayerProps[key]);
        }
      }
    }

    Object.assign(newProps, sublayerProps, overridingSublayerProps);
    newProps.id = "".concat(this.props.id, "-").concat(sublayerId);
    newProps.updateTriggers = {
      all: (_this$props$updateTri = this.props.updateTriggers) === null || _this$props$updateTri === void 0 ? void 0 : _this$props$updateTri.all,
      ...sublayerProps.updateTriggers,
      ...overridingSublayerTriggers
    };

    for (const extension of extensions) {
      const passThroughProps = extension.getSubLayerProps.call(this, extension);

      if (passThroughProps) {
        Object.assign(newProps, passThroughProps, {
          updateTriggers: Object.assign(newProps.updateTriggers, passThroughProps.updateTriggers)
        });
      }
    }

    return newProps;
  }

  _updateAutoHighlight(info) {
    for (const layer of this.getSubLayers()) {
      layer.updateAutoHighlight(info);
    }
  }

  _getAttributeManager() {
    return null;
  }

  _postUpdate(updateParams, forceUpdate) {
    let subLayers = this.internalState.subLayers;
    const shouldUpdate = !subLayers || this.needsUpdate();

    if (shouldUpdate) {
      const subLayersList = this.renderLayers();
      subLayers = (0,_utils_flatten__WEBPACK_IMPORTED_MODULE_3__.flatten)(subLayersList, Boolean);
      this.internalState.subLayers = subLayers;
    }

    (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_RENDER_LAYERS, this, shouldUpdate, subLayers);

    for (const layer of subLayers) {
      layer.parent = this;
    }
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(CompositeLayer, "layerName", 'CompositeLayer');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js":
/*!**************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/constants.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "COORDINATE_SYSTEM": () => (/* binding */ COORDINATE_SYSTEM),
/* harmony export */   "EVENTS": () => (/* binding */ EVENTS),
/* harmony export */   "OPERATION": () => (/* binding */ OPERATION),
/* harmony export */   "PROJECTION_MODE": () => (/* binding */ PROJECTION_MODE),
/* harmony export */   "UNIT": () => (/* binding */ UNIT)
/* harmony export */ });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");

const COORDINATE_SYSTEM = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
Object.defineProperty(COORDINATE_SYSTEM, 'IDENTITY', {
  get: () => {
    _utils_log__WEBPACK_IMPORTED_MODULE_0__["default"].deprecated('COORDINATE_SYSTEM.IDENTITY', 'COORDINATE_SYSTEM.CARTESIAN')();
    return 0;
  }
});
const PROJECTION_MODE = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
};
const UNIT = {
  common: 0,
  meters: 1,
  pixels: 2
};
const EVENTS = {
  click: {
    handler: 'onClick'
  },
  panstart: {
    handler: 'onDragStart'
  },
  panmove: {
    handler: 'onDrag'
  },
  panend: {
    handler: 'onDragEnd'
  }
};
const OPERATION = {
  DRAW: 'draw',
  MASK: 'mask',
  TERRAIN: 'terrain'
};


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js":
/*!****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeckPicker)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js");
/* harmony import */ var _passes_pick_layers_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../passes/pick-layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js");
/* harmony import */ var _picking_query_object__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./picking/query-object */ "./node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js");
/* harmony import */ var _picking_pick_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./picking/pick-info */ "./node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js");





class DeckPicker {
  constructor(gl) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pickingFBO", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "depthFBO", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pickLayersPass", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "layerFilter", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "lastPickedInfo", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_pickable", true);

    this.gl = gl;
    this.pickLayersPass = new _passes_pick_layers_pass__WEBPACK_IMPORTED_MODULE_1__["default"](gl);
    this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }

  setProps(props) {
    if ('layerFilter' in props) {
      this.layerFilter = props.layerFilter;
    }

    if ('_pickable' in props) {
      this._pickable = props._pickable;
    }
  }

  finalize() {
    if (this.pickingFBO) {
      this.pickingFBO.delete();
    }

    if (this.depthFBO) {
      this.depthFBO.color.delete();
      this.depthFBO.delete();
    }
  }

  pickObject(opts) {
    return this._pickClosestObject(opts);
  }

  pickObjects(opts) {
    return this._pickVisibleObjects(opts);
  }

  getLastPickedObject({
    x,
    y,
    layers,
    viewports
  }, lastPickedInfo = this.lastPickedInfo.info) {
    const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
    const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
    const layer = lastPickedLayerId ? layers.find(l => l.id === lastPickedLayerId) : null;
    const viewport = lastPickedViewportId && viewports.find(v => v.id === lastPickedViewportId) || viewports[0];
    const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
    const info = {
      x,
      y,
      viewport,
      coordinate,
      layer
    };
    return { ...lastPickedInfo,
      ...info
    };
  }

  _resizeBuffer() {
    var _this$pickingFBO, _this$depthFBO;

    const {
      gl
    } = this;

    if (!this.pickingFBO) {
      this.pickingFBO = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"](gl);

      if (_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"].isSupported(gl, {
        colorBufferFloat: true
      })) {
        const depthFBO = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"](gl);
        depthFBO.attach({
          [36064]: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, {
            format: (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.isWebGL2)(gl) ? 34836 : 6408,
            type: 5126
          })
        });
        this.depthFBO = depthFBO;
      }
    }

    (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
    (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
      width: gl.canvas.width,
      height: gl.canvas.height
    });
  }

  _getPickable(layers) {
    if (this._pickable === false) {
      return null;
    }

    const pickableLayers = layers.filter(layer => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
    return pickableLayers.length ? pickableLayers : null;
  }

  _pickClosestObject({
    layers,
    views,
    viewports,
    x,
    y,
    radius = 0,
    depth = 1,
    mode = 'query',
    unproject3D,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);

    const pixelRatio = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.cssToDeviceRatio)(this.gl);

    if (!pickableLayers) {
      return {
        result: [],
        emptyInfo: (0,_picking_pick_info__WEBPACK_IMPORTED_MODULE_5__.getEmptyPickingInfo)({
          viewports,
          x,
          y,
          pixelRatio
        })
      };
    }

    this._resizeBuffer();

    const devicePixelRange = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.cssToDevicePixels)(this.gl, [x, y], true);
    const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
    const deviceRadius = Math.round(radius * pixelRatio);
    const {
      width,
      height
    } = this.pickingFBO;

    const deviceRect = this._getPickingRect({
      deviceX: devicePixel[0],
      deviceY: devicePixel[1],
      deviceRadius,
      deviceWidth: width,
      deviceHeight: height
    });

    const cullRect = {
      x: x - radius,
      y: y - radius,
      width: radius * 2 + 1,
      height: radius * 2 + 1
    };
    let infos;
    const result = [];
    const affectedLayers = new Set();

    for (let i = 0; i < depth; i++) {
      let pickInfo;

      if (deviceRect) {
        const pickedResult = this._drawAndSample({
          layers: pickableLayers,
          views,
          viewports,
          onViewportActive,
          deviceRect,
          cullRect,
          effects,
          pass: "picking:".concat(mode)
        });

        pickInfo = (0,_picking_query_object__WEBPACK_IMPORTED_MODULE_6__.getClosestObject)({ ...pickedResult,
          deviceX: devicePixel[0],
          deviceY: devicePixel[1],
          deviceRadius,
          deviceRect
        });
      } else {
        pickInfo = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      }

      let z;

      if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
        const {
          pickedColors: pickedColors2
        } = this._drawAndSample({
          layers: [pickInfo.pickedLayer],
          views,
          viewports,
          onViewportActive,
          deviceRect: {
            x: pickInfo.pickedX,
            y: pickInfo.pickedY,
            width: 1,
            height: 1
          },
          cullRect,
          effects,
          pass: "picking:".concat(mode, ":z")
        }, true);

        if (pickedColors2[3]) {
          z = pickedColors2[0];
        }
      }

      if (pickInfo.pickedLayer && i + 1 < depth) {
        affectedLayers.add(pickInfo.pickedLayer);
        pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
      }

      infos = (0,_picking_pick_info__WEBPACK_IMPORTED_MODULE_5__.processPickInfo)({
        pickInfo,
        lastPickedInfo: this.lastPickedInfo,
        mode,
        layers: pickableLayers,
        viewports,
        x,
        y,
        z,
        pixelRatio
      });

      for (const info of infos.values()) {
        if (info.layer) {
          result.push(info);
        }
      }

      if (!pickInfo.pickedColor) {
        break;
      }
    }

    for (const layer of affectedLayers) {
      layer.restorePickingColors();
    }

    return {
      result,
      emptyInfo: infos.get(null)
    };
  }

  _pickVisibleObjects({
    layers,
    views,
    viewports,
    x,
    y,
    width = 1,
    height = 1,
    mode = 'query',
    maxObjects = null,
    onViewportActive,
    effects
  }) {
    const pickableLayers = this._getPickable(layers);

    if (!pickableLayers) {
      return [];
    }

    this._resizeBuffer();

    const pixelRatio = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.cssToDeviceRatio)(this.gl);
    const leftTop = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.cssToDevicePixels)(this.gl, [x, y], true);
    const deviceLeft = leftTop.x;
    const deviceTop = leftTop.y + leftTop.height;
    const rightBottom = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.cssToDevicePixels)(this.gl, [x + width, y + height], true);
    const deviceRight = rightBottom.x + rightBottom.width;
    const deviceBottom = rightBottom.y;
    const deviceRect = {
      x: deviceLeft,
      y: deviceBottom,
      width: deviceRight - deviceLeft,
      height: deviceTop - deviceBottom
    };

    const pickedResult = this._drawAndSample({
      layers: pickableLayers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect: {
        x,
        y,
        width,
        height
      },
      effects,
      pass: "picking:".concat(mode)
    });

    const pickInfos = (0,_picking_query_object__WEBPACK_IMPORTED_MODULE_6__.getUniqueObjects)(pickedResult);
    const uniqueInfos = new Map();
    const isMaxObjects = Number.isFinite(maxObjects);

    for (let i = 0; i < pickInfos.length; i++) {
      if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
        break;
      }

      const pickInfo = pickInfos[i];
      let info = {
        color: pickInfo.pickedColor,
        layer: null,
        index: pickInfo.pickedObjectIndex,
        picked: true,
        x,
        y,
        pixelRatio
      };
      info = (0,_picking_pick_info__WEBPACK_IMPORTED_MODULE_5__.getLayerPickingInfo)({
        layer: pickInfo.pickedLayer,
        info,
        mode
      });

      if (!uniqueInfos.has(info.object)) {
        uniqueInfos.set(info.object, info);
      }
    }

    return Array.from(uniqueInfos.values());
  }

  _drawAndSample({
    layers,
    views,
    viewports,
    onViewportActive,
    deviceRect,
    cullRect,
    effects,
    pass
  }, pickZ = false) {
    const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
    const opts = {
      layers,
      layerFilter: this.layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect,
      cullRect,
      effects,
      pass,
      pickZ,
      preRenderStats: {}
    };

    for (const effect of effects) {
      if (effect.useInPicking) {
        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
      }
    }

    const {
      decodePickingColor
    } = this.pickLayersPass.render(opts);
    const {
      x,
      y,
      width,
      height
    } = deviceRect;
    const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width * height * 4);
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_7__.readPixelsToArray)(pickingFBO, {
      sourceX: x,
      sourceY: y,
      sourceWidth: width,
      sourceHeight: height,
      target: pickedColors
    });
    return {
      pickedColors,
      decodePickingColor
    };
  }

  _getPickingRect({
    deviceX,
    deviceY,
    deviceRadius,
    deviceWidth,
    deviceHeight
  }) {
    const x = Math.max(0, deviceX - deviceRadius);
    const y = Math.max(0, deviceY - deviceRadius);
    const width = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
    const height = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;

    if (width <= 0 || height <= 0) {
      return null;
    }

    return {
      x,
      y,
      width,
      height
    };
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js":
/*!******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DeckRenderer)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../debug */ "./node_modules/@deck.gl/core/dist/esm/debug/index.js");
/* harmony import */ var _passes_draw_layers_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../passes/draw-layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js");
/* harmony import */ var _passes_pick_layers_pass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../passes/pick-layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");





const TRACE_RENDER_LAYERS = 'deckRenderer.renderLayers';
class DeckRenderer {
  constructor(gl) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "layerFilter", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "drawPickingColors", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "drawLayersPass", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pickLayersPass", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "renderCount", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsRedraw", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "renderBuffers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "lastPostProcessEffect", void 0);

    this.gl = gl;
    this.layerFilter = null;
    this.drawPickingColors = false;
    this.drawLayersPass = new _passes_draw_layers_pass__WEBPACK_IMPORTED_MODULE_1__["default"](gl);
    this.pickLayersPass = new _passes_pick_layers_pass__WEBPACK_IMPORTED_MODULE_2__["default"](gl);
    this.renderCount = 0;
    this._needsRedraw = 'Initial render';
    this.renderBuffers = [];
    this.lastPostProcessEffect = null;
  }

  setProps(props) {
    if (this.layerFilter !== props.layerFilter) {
      this.layerFilter = props.layerFilter;
      this._needsRedraw = 'layerFilter changed';
    }

    if (this.drawPickingColors !== props.drawPickingColors) {
      this.drawPickingColors = props.drawPickingColors;
      this._needsRedraw = 'drawPickingColors changed';
    }
  }

  renderLayers(opts) {
    const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
    const renderOpts = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...opts,
      target: opts.target || _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"].getDefaultFramebuffer(this.gl)
    };

    if (renderOpts.effects) {
      this._preRender(renderOpts.effects, renderOpts);
    }

    const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
    const renderStats = layerPass.render({ ...renderOpts,
      target: outputBuffer
    });

    if (renderOpts.effects) {
      this._postRender(renderOpts.effects, renderOpts);
    }

    this.renderCount++;
    (0,_debug__WEBPACK_IMPORTED_MODULE_4__["default"])(TRACE_RENDER_LAYERS, this, renderStats, opts);
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    return redraw;
  }

  finalize() {
    const {
      renderBuffers
    } = this;

    for (const buffer of renderBuffers) {
      buffer.delete();
    }

    renderBuffers.length = 0;
  }

  _preRender(effects, opts) {
    this.lastPostProcessEffect = null;
    opts.preRenderStats = opts.preRenderStats || {};

    for (const effect of effects) {
      opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);

      if (effect.postRender) {
        this.lastPostProcessEffect = effect.id;
      }
    }

    if (this.lastPostProcessEffect) {
      this._resizeRenderBuffers();
    }
  }

  _resizeRenderBuffers() {
    const {
      renderBuffers
    } = this;

    if (renderBuffers.length === 0) {
      renderBuffers.push(new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl), new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl));
    }

    for (const buffer of renderBuffers) {
      buffer.resize();
    }
  }

  _postRender(effects, opts) {
    const {
      renderBuffers
    } = this;
    const params = { ...opts,
      inputBuffer: renderBuffers[0],
      swapBuffer: renderBuffers[1],
      target: null
    };

    for (const effect of effects) {
      if (effect.postRender) {
        if (effect.id === this.lastPostProcessEffect) {
          params.target = opts.target;
          effect.postRender(this.gl, params);
          break;
        }

        const buffer = effect.postRender(this.gl, params);
        params.inputBuffer = buffer;
        params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
      }
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/deck.js":
/*!*********************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/deck.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Deck)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _layer_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./layer-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js");
/* harmony import */ var _view_manager__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./view-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/view-manager.js");
/* harmony import */ var _views_map_view__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../views/map-view */ "./node_modules/@deck.gl/core/dist/esm/views/map-view.js");
/* harmony import */ var _effect_manager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./effect-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js");
/* harmony import */ var _deck_renderer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./deck-renderer */ "./node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js");
/* harmony import */ var _deck_picker__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./deck-picker */ "./node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js");
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./tooltip */ "./node_modules/@deck.gl/core/dist/esm/lib/tooltip.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");
/* harmony import */ var _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/typed-array-manager */ "./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js");
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./init */ "./node_modules/@deck.gl/core/dist/esm/lib/init.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @probe.gl/env */ "./node_modules/@probe.gl/env/dist/esm/lib/get-browser.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/animation/timeline.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/init.js");
/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/stats */ "./node_modules/@probe.gl/stats/dist/esm/index.js");
/* harmony import */ var mjolnir_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mjolnir.js */ "./node_modules/mjolnir.js/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");



















function noop() {}

const getCursor = ({
  isDragging
}) => isDragging ? 'grabbing' : 'grab';

const defaultProps = {
  id: '',
  width: '100%',
  height: '100%',
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: true,
  touchAction: 'none',
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: false,
  _pickable: true,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: noop,
  onResize: noop,
  onViewStateChange: noop,
  onInteractionStateChange: noop,
  onBeforeRender: noop,
  onAfterRender: noop,
  onLoad: noop,
  onError: error => _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].error(error.message)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor,
  getTooltip: null,
  debug: false,
  drawPickingColors: false
};
class Deck {
  constructor(props) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "width", 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "height", 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "userData", {});

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "canvas", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewManager", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "layerManager", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "effectManager", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "deckRenderer", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "deckPicker", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "eventManager", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "tooltip", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "metrics", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "animationLoop", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "stats", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewState", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "cursorState", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsRedraw", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_pickRequest", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_lastPointerDownInfo", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_metricsCounter", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_onPointerMove", event => {
      const {
        _pickRequest
      } = this;

      if (event.type === 'pointerleave') {
        _pickRequest.x = -1;
        _pickRequest.y = -1;
        _pickRequest.radius = 0;
      } else if (event.leftButton || event.rightButton) {
        return;
      } else {
        const pos = event.offsetCenter;

        if (!pos) {
          return;
        }

        _pickRequest.x = pos.x;
        _pickRequest.y = pos.y;
        _pickRequest.radius = this.props.pickingRadius;
      }

      if (this.layerManager) {
        this.layerManager.context.mousePosition = {
          x: _pickRequest.x,
          y: _pickRequest.y
        };
      }

      _pickRequest.event = event;
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_onEvent", event => {
      const eventOptions = _constants__WEBPACK_IMPORTED_MODULE_4__.EVENTS[event.type];
      const pos = event.offsetCenter;

      if (!eventOptions || !pos || !this.layerManager) {
        return;
      }

      const layers = this.layerManager.getLayers();
      const info = this.deckPicker.getLastPickedObject({
        x: pos.x,
        y: pos.y,
        layers,
        viewports: this.getViewports(pos)
      }, this._lastPointerDownInfo);
      const {
        layer
      } = info;
      const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
      const rootHandler = this.props[eventOptions.handler];
      let handled = false;

      if (layerHandler) {
        handled = layerHandler.call(layer, info, event);
      }

      if (!handled && rootHandler) {
        rootHandler(info, event);
      }
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_onPointerDown", event => {
      const pos = event.offsetCenter;

      const pickedInfo = this._pick('pickObject', 'pickObject Time', {
        x: pos.x,
        y: pos.y,
        radius: this.props.pickingRadius
      });

      this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
    });

    this.props = { ...defaultProps,
      ...props
    };
    props = this.props;
    this._needsRedraw = 'Initial render';
    this._pickRequest = {
      mode: 'hover',
      x: -1,
      y: -1,
      radius: 0,
      event: null
    };
    this.cursorState = {
      isHovering: false,
      isDragging: false
    };

    if (props.viewState && props.initialViewState) {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].warn('View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.')();
    }

    if ((0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_5__["default"])() === 'IE') {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].warn('IE 11 is not supported')();
    }

    this.viewState = props.initialViewState;

    if (!props.gl) {
      if (typeof document !== 'undefined') {
        this.canvas = this._createCanvas(props);
      }
    }

    this.animationLoop = this._createAnimationLoop(props);
    this.stats = new _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__.Stats({
      id: 'deck.gl'
    });
    this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    };
    this._metricsCounter = 0;
    this.setProps(props);

    if (props._typedArrayManagerProps) {
      _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_6__["default"].setOptions(props._typedArrayManagerProps);
    }

    this.animationLoop.start();
  }

  finalize() {
    var _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;

    this.animationLoop.stop();
    this.animationLoop = null;
    this._lastPointerDownInfo = null;
    (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
    this.layerManager = null;
    (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
    this.viewManager = null;
    (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
    this.effectManager = null;
    (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
    this.deckRenderer = null;
    (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
    this.deckPicker = null;
    (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
    this.eventManager = null;
    (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
    this.tooltip = null;

    if (!this.props.canvas && !this.props.gl && this.canvas) {
      var _this$canvas$parentEl;

      (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
      this.canvas = null;
    }
  }

  setProps(props) {
    this.stats.get('setProps Time').timeStart();

    if ('onLayerHover' in props) {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].removed('onLayerHover', 'onHover')();
    }

    if ('onLayerClick' in props) {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].removed('onLayerClick', 'onClick')();
    }

    if (props.initialViewState && !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_7__.deepEqual)(this.props.initialViewState, props.initialViewState, 3)) {
      this.viewState = props.initialViewState;
    }

    Object.assign(this.props, props);

    this._setCanvasSize(this.props);

    const resolvedProps = Object.create(this.props);
    Object.assign(resolvedProps, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    });
    this.animationLoop.setProps(resolvedProps);

    if (this.layerManager) {
      this.viewManager.setProps(resolvedProps);
      this.layerManager.activateViewport(this.getViewports()[0]);
      this.layerManager.setProps(resolvedProps);
      this.effectManager.setProps(resolvedProps);
      this.deckRenderer.setProps(resolvedProps);
      this.deckPicker.setProps(resolvedProps);
    }

    this.stats.get('setProps Time').timeEnd();
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    if (!this.layerManager) {
      return false;
    }

    if (this.props._animate) {
      return 'Deck._animate';
    }

    let redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
    const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
    const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
    const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
    redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
    return redraw;
  }

  redraw(reason) {
    if (!this.layerManager) {
      return;
    }

    let redrawReason = this.needsRedraw({
      clearRedrawFlags: true
    });
    redrawReason = reason || redrawReason;

    if (!redrawReason) {
      return;
    }

    this.stats.get('Redraw Count').incrementCount();

    if (this.props._customRender) {
      this.props._customRender(redrawReason);
    } else {
      this._drawLayers(redrawReason);
    }
  }

  get isInitialized() {
    return this.viewManager !== null;
  }

  getViews() {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_8__["default"])(this.viewManager);
    return this.viewManager.views;
  }

  getViewports(rect) {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_8__["default"])(this.viewManager);
    return this.viewManager.getViewports(rect);
  }

  pickObject(opts) {
    const infos = this._pick('pickObject', 'pickObject Time', opts).result;

    return infos.length ? infos[0] : null;
  }

  pickMultipleObjects(opts) {
    opts.depth = opts.depth || 10;
    return this._pick('pickObject', 'pickMultipleObjects Time', opts).result;
  }

  pickObjects(opts) {
    return this._pick('pickObjects', 'pickObjects Time', opts);
  }

  _addResources(resources, forceUpdate = false) {
    for (const id in resources) {
      this.layerManager.resourceManager.add({
        resourceId: id,
        data: resources[id],
        forceUpdate
      });
    }
  }

  _removeResources(resourceIds) {
    for (const id of resourceIds) {
      this.layerManager.resourceManager.remove(id);
    }
  }

  _addDefaultEffect(effect) {
    this.effectManager.addDefaultEffect(effect);
  }

  _pick(method, statKey, opts) {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_8__["default"])(this.deckPicker);
    const {
      stats
    } = this;
    stats.get('Pick Count').incrementCount();
    stats.get(statKey).timeStart();
    const infos = this.deckPicker[method]({
      layers: this.layerManager.getLayers(opts),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(opts),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...opts
    });
    stats.get(statKey).timeEnd();
    return infos;
  }

  _createCanvas(props) {
    let canvas = props.canvas;

    if (typeof canvas === 'string') {
      canvas = document.getElementById(canvas);
      (0,_utils_assert__WEBPACK_IMPORTED_MODULE_8__["default"])(canvas);
    }

    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.id = props.id || 'deckgl-overlay';
      const parent = props.parent || document.body;
      parent.appendChild(canvas);
    }

    Object.assign(canvas.style, props.style);
    return canvas;
  }

  _setCanvasSize(props) {
    if (!this.canvas) {
      return;
    }

    const {
      width,
      height
    } = props;

    if (width || width === 0) {
      const cssWidth = Number.isFinite(width) ? "".concat(width, "px") : width;
      this.canvas.style.width = cssWidth;
    }

    if (height || height === 0) {
      var _props$style;

      const cssHeight = Number.isFinite(height) ? "".concat(height, "px") : height;
      this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || 'absolute';
      this.canvas.style.height = cssHeight;
    }
  }

  _updateCanvasSize() {
    var _canvas$clientWidth, _canvas$clientHeight;

    const {
      canvas
    } = this;

    if (!canvas) {
      return;
    }

    const newWidth = (_canvas$clientWidth = canvas.clientWidth) !== null && _canvas$clientWidth !== void 0 ? _canvas$clientWidth : canvas.width;
    const newHeight = (_canvas$clientHeight = canvas.clientHeight) !== null && _canvas$clientHeight !== void 0 ? _canvas$clientHeight : canvas.height;

    if (newWidth !== this.width || newHeight !== this.height) {
      var _this$viewManager2;

      this.width = newWidth;
      this.height = newHeight;
      (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
        width: newWidth,
        height: newHeight
      });
      this.props.onResize({
        width: newWidth,
        height: newHeight
      });
    }
  }

  _createAnimationLoop(props) {
    const {
      width,
      height,
      gl,
      glOptions,
      debug,
      onError,
      onBeforeRender,
      onAfterRender,
      useDevicePixels
    } = props;
    return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_9__["default"]({
      width,
      height,
      useDevicePixels,
      autoResizeDrawingBuffer: !gl,
      autoResizeViewport: false,
      gl,
      onCreateContext: opts => (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_10__.createGLContext)({ ...glOptions,
        ...opts,
        canvas: this.canvas,
        debug,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: context => this._setGLContext(context.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender,
      onAfterRender,
      onError
    });
  }

  _getViewState() {
    return this.props.viewState || this.viewState;
  }

  _getViews() {
    let views = this.props.views || [new _views_map_view__WEBPACK_IMPORTED_MODULE_11__["default"]({
      id: 'default-view'
    })];
    views = Array.isArray(views) ? views : [views];

    if (views.length && this.props.controller) {
      views[0].props.controller = this.props.controller;
    }

    return views;
  }

  _onContextLost() {
    const {
      onError
    } = this.props;

    if (this.animationLoop && onError) {
      onError(new Error('WebGL context is lost'));
    }
  }

  _pickAndCallback() {
    const {
      _pickRequest
    } = this;

    if (_pickRequest.event) {
      const {
        result,
        emptyInfo
      } = this._pick('pickObject', 'pickObject Time', _pickRequest);

      this.cursorState.isHovering = result.length > 0;
      let pickedInfo = emptyInfo;
      let handled = false;

      for (const info of result) {
        var _info$layer;

        pickedInfo = info;
        handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
      }

      if (!handled && this.props.onHover) {
        this.props.onHover(pickedInfo, _pickRequest.event);
      }

      if (this.props.getTooltip && this.tooltip) {
        const displayInfo = this.props.getTooltip(pickedInfo);
        this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
      }

      _pickRequest.event = null;
    }
  }

  _updateCursor() {
    const container = this.props.parent || this.canvas;

    if (container) {
      container.style.cursor = this.props.getCursor(this.cursorState);
    }
  }

  _setGLContext(gl) {
    if (this.layerManager) {
      return;
    }

    if (!this.canvas) {
      this.canvas = gl.canvas;
      (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_10__.instrumentGLContext)(gl, {
        enable: true,
        copyState: true
      });
    }

    this.tooltip = new _tooltip__WEBPACK_IMPORTED_MODULE_12__["default"](this.canvas);
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_10__.setParameters)(gl, {
      blend: true,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: true,
      depthTest: true,
      depthFunc: 515
    });
    this.props.onWebGLInitialized(gl);
    const timeline = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_13__.Timeline();
    timeline.play();
    this.animationLoop.attachTimeline(timeline);
    this.eventManager = new mjolnir_js__WEBPACK_IMPORTED_MODULE_2__.EventManager(this.props.parent || gl.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });

    for (const eventType in _constants__WEBPACK_IMPORTED_MODULE_4__.EVENTS) {
      this.eventManager.on(eventType, this._onEvent);
    }

    this.viewManager = new _view_manager__WEBPACK_IMPORTED_MODULE_14__["default"]({
      timeline,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const viewport = this.viewManager.getViewports()[0];
    this.layerManager = new _layer_manager__WEBPACK_IMPORTED_MODULE_15__["default"](gl, {
      deck: this,
      stats: this.stats,
      viewport,
      timeline
    });
    this.effectManager = new _effect_manager__WEBPACK_IMPORTED_MODULE_16__["default"]();
    this.deckRenderer = new _deck_renderer__WEBPACK_IMPORTED_MODULE_17__["default"](gl);
    this.deckPicker = new _deck_picker__WEBPACK_IMPORTED_MODULE_18__["default"](gl);
    this.setProps(this.props);

    this._updateCanvasSize();

    this.props.onLoad();
  }

  _drawLayers(redrawReason, renderOptions) {
    const {
      gl
    } = this.layerManager.context;
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_10__.setParameters)(gl, this.props.parameters);
    this.props.onBeforeRender({
      gl
    });
    this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: 'screen',
      effects: this.effectManager.getEffects(),
      ...renderOptions
    });
    this.props.onAfterRender({
      gl
    });
  }

  _onRenderFrame(animationProps) {
    this._getFrameStats();

    if (this._metricsCounter++ % 60 === 0) {
      this._getMetrics();

      this.stats.reset();
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].table(4, this.metrics)();

      if (this.props._onMetrics) {
        this.props._onMetrics(this.metrics);
      }
    }

    this._updateCanvasSize();

    this._updateCursor();

    if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
      this.tooltip.setTooltip(null);
    }

    this.layerManager.updateLayers();

    this._pickAndCallback();

    this.redraw();

    if (this.viewManager) {
      this.viewManager.updateViewStates();
    }
  }

  _onViewStateChange(params) {
    const viewState = this.props.onViewStateChange(params) || params.viewState;

    if (this.viewState) {
      this.viewState = { ...this.viewState,
        [params.viewId]: viewState
      };

      if (!this.props.viewState) {
        if (this.viewManager) {
          this.viewManager.setProps({
            viewState: this.viewState
          });
        }
      }
    }
  }

  _onInteractionStateChange(interactionState) {
    this.cursorState.isDragging = interactionState.isDragging || false;
    this.props.onInteractionStateChange(interactionState);
  }

  _getFrameStats() {
    const {
      stats
    } = this;
    stats.get('frameRate').timeEnd();
    stats.get('frameRate').timeStart();
    const animationLoopStats = this.animationLoop.stats;
    stats.get('GPU Time').addTime(animationLoopStats.get('GPU Time').lastTiming);
    stats.get('CPU Time').addTime(animationLoopStats.get('CPU Time').lastTiming);
  }

  _getMetrics() {
    const {
      metrics,
      stats
    } = this;
    metrics.fps = stats.get('frameRate').getHz();
    metrics.setPropsTime = stats.get('setProps Time').time;
    metrics.updateAttributesTime = stats.get('Update Attributes').time;
    metrics.framesRedrawn = stats.get('Redraw Count').count;
    metrics.pickTime = stats.get('pickObject Time').time + stats.get('pickMultipleObjects Time').time + stats.get('pickObjects Time').time;
    metrics.pickCount = stats.get('Pick Count').count;
    metrics.gpuTime = stats.get('GPU Time').time;
    metrics.cpuTime = stats.get('CPU Time').time;
    metrics.gpuTimePerFrame = stats.get('GPU Time').getAverageTime();
    metrics.cpuTimePerFrame = stats.get('CPU Time').getAverageTime();
    const memoryStats = _luma_gl_core__WEBPACK_IMPORTED_MODULE_19__.lumaStats.get('Memory Usage');
    metrics.bufferMemory = memoryStats.get('Buffer Memory').count;
    metrics.textureMemory = memoryStats.get('Texture Memory').count;
    metrics.renderbufferMemory = memoryStats.get('Renderbuffer Memory').count;
    metrics.gpuMemory = memoryStats.get('GPU Memory').count;
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Deck, "defaultProps", defaultProps);

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Deck, "VERSION", _init__WEBPACK_IMPORTED_MODULE_20__.VERSION);


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EffectManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");
/* harmony import */ var _effects_lighting_lighting_effect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../effects/lighting/lighting-effect */ "./node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js");



const DEFAULT_LIGHTING_EFFECT = new _effects_lighting_lighting_effect__WEBPACK_IMPORTED_MODULE_1__["default"]();

function compareEffects(e1, e2) {
  var _e1$order, _e2$order;

  const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
  const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
  return o1 - o2;
}

class EffectManager {
  constructor() {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "effects", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_resolvedEffects", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_defaultEffects", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsRedraw", void 0);

    this.effects = [];
    this._needsRedraw = 'Initial render';

    this._setEffects([]);
  }

  addDefaultEffect(effect) {
    const defaultEffects = this._defaultEffects;

    if (!defaultEffects.find(e => e.id === effect.id)) {
      const index = defaultEffects.findIndex(e => compareEffects(e, effect) > 0);

      if (index < 0) {
        defaultEffects.push(effect);
      } else {
        defaultEffects.splice(index, 0, effect);
      }

      this._setEffects(this.effects);
    }
  }

  setProps(props) {
    if ('effects' in props) {
      if (!(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(props.effects, this.effects, 1)) {
        this._setEffects(props.effects);
      }
    }
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    return redraw;
  }

  getEffects() {
    return this._resolvedEffects;
  }

  _setEffects(effects) {
    const oldEffectsMap = {};

    for (const effect of this.effects) {
      oldEffectsMap[effect.id] = effect;
    }

    const nextEffects = [];

    for (const effect of effects) {
      const oldEffect = oldEffectsMap[effect.id];

      if (oldEffect && oldEffect !== effect) {
        if (oldEffect.setProps) {
          oldEffect.setProps(effect.props);
          nextEffects.push(oldEffect);
        } else {
          oldEffect.cleanup();
          nextEffects.push(effect);
        }
      } else {
        nextEffects.push(effect);
      }

      delete oldEffectsMap[effect.id];
    }

    for (const removedEffectId in oldEffectsMap) {
      oldEffectsMap[removedEffectId].cleanup();
    }

    this.effects = nextEffects;
    this._resolvedEffects = nextEffects.concat(this._defaultEffects);

    if (!effects.some(effect => effect instanceof _effects_lighting_lighting_effect__WEBPACK_IMPORTED_MODULE_1__["default"])) {
      this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
    }

    this._needsRedraw = 'effects changed';
  }

  finalize() {
    for (const effect of this._resolvedEffects) {
      effect.cleanup();
    }

    this.effects.length = 0;
    this._resolvedEffects.length = 0;
    this._defaultEffects.length = 0;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/init.js":
/*!*********************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/init.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VERSION": () => (/* binding */ VERSION)
/* harmony export */ });
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/core */ "./node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js");
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @loaders.gl/images */ "./node_modules/@loaders.gl/images/dist/esm/image-loader.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../debug */ "./node_modules/@deck.gl/core/dist/esm/debug/index.js");
/* harmony import */ var _utils_json_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/json-loader */ "./node_modules/@deck.gl/core/dist/esm/utils/json-loader.js");






function checkVersion() {
  const version =  true ? "8.9.15" : 0;
  const existingVersion = globalThis.deck && globalThis.deck.VERSION;

  if (existingVersion && existingVersion !== version) {
    throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
  }

  if (!existingVersion) {
    _utils_log__WEBPACK_IMPORTED_MODULE_0__["default"].log(1, "deck.gl ".concat(version))();
    globalThis.deck = { ...globalThis.deck,
      VERSION: version,
      version,
      log: _utils_log__WEBPACK_IMPORTED_MODULE_0__["default"],
      _registerLoggers: _debug__WEBPACK_IMPORTED_MODULE_1__.register
    };
    (0,_loaders_gl_core__WEBPACK_IMPORTED_MODULE_2__.registerLoaders)([_utils_json_loader__WEBPACK_IMPORTED_MODULE_3__["default"], [_loaders_gl_images__WEBPACK_IMPORTED_MODULE_4__.ImageLoader, {
      imagebitmap: {
        premultiplyAlpha: 'none'
      }
    }]]);
  }

  return version;
}

const VERSION = checkVersion();


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js":
/*!********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/layer-extension.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LayerExtension)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");


class LayerExtension {
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, 'extensionName') ? this.extensionName : '';
  }

  constructor(opts) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "opts", void 0);

    if (opts) {
      this.opts = opts;
    }
  }

  equals(extension) {
    if (this === extension) {
      return true;
    }

    return this.constructor === extension.constructor && (0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_1__.deepEqual)(this.opts, extension.opts, 1);
  }

  getShaders(extension) {
    return null;
  }

  getSubLayerProps(extension) {
    const {
      defaultProps
    } = extension.constructor;
    const newProps = {
      updateTriggers: {}
    };

    for (const key in defaultProps) {
      if (key in this.props) {
        const propDef = defaultProps[key];
        const propValue = this.props[key];
        newProps[key] = propValue;

        if (propDef && propDef.type === 'accessor') {
          newProps.updateTriggers[key] = this.props.updateTriggers[key];

          if (typeof propValue === 'function') {
            newProps[key] = this.getSubLayerAccessor(propValue);
          }
        }
      }
    }

    return newProps;
  }

  initializeState(context, extension) {}

  updateState(params, extension) {}

  onNeedsRedraw(extension) {}

  getNeedsPickingBuffer(extension) {
    return false;
  }

  draw(params, extension) {}

  finalizeState(context, extension) {}

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(LayerExtension, "defaultProps", {});

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(LayerExtension, "extensionName", 'LayerExtension');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js":
/*!******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LayerManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/animation/timeline.js");
/* harmony import */ var _lifecycle_constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lifecycle/constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../debug */ "./node_modules/@deck.gl/core/dist/esm/debug/index.js");
/* harmony import */ var _utils_flatten__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/flatten */ "./node_modules/@deck.gl/core/dist/esm/utils/flatten.js");
/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/stats */ "./node_modules/@probe.gl/stats/dist/esm/index.js");
/* harmony import */ var _resource_resource_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./resource/resource-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js");
/* harmony import */ var _viewports_viewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../viewports/viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _shaderlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaderlib */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/index.js");










const TRACE_SET_LAYERS = 'layerManager.setLayers';
const TRACE_ACTIVATE_VIEWPORT = 'layerManager.activateViewport';
class LayerManager {
  constructor(gl, {
    deck,
    stats,
    viewport: _viewport,
    timeline
  } = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "layers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "context", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "resourceManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_lastRenderedLayers", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsRedraw", false);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsUpdate", false);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_nextLayers", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_debug", false);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "activateViewport", viewport => {
      (0,_debug__WEBPACK_IMPORTED_MODULE_2__["default"])(TRACE_ACTIVATE_VIEWPORT, this, viewport);

      if (viewport) {
        this.context.viewport = viewport;
      }
    });

    this.layers = [];
    this.resourceManager = new _resource_resource_manager__WEBPACK_IMPORTED_MODULE_3__["default"]({
      gl,
      protocol: 'deck://'
    });
    this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl,
      deck,
      programManager: gl && (0,_shaderlib__WEBPACK_IMPORTED_MODULE_4__.createProgramManager)(gl),
      stats: stats || new _probe_gl_stats__WEBPACK_IMPORTED_MODULE_1__.Stats({
        id: 'deck.gl'
      }),
      viewport: _viewport || new _viewports_viewport__WEBPACK_IMPORTED_MODULE_5__["default"]({
        id: 'DEFAULT-INITIAL-VIEWPORT'
      }),
      timeline: timeline || new _luma_gl_core__WEBPACK_IMPORTED_MODULE_6__.Timeline(),
      resourceManager: this.resourceManager,
      onError: undefined
    };
    Object.seal(this);
  }

  finalize() {
    this.resourceManager.finalize();

    for (const layer of this.layers) {
      this._finalizeLayer(layer);
    }
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    let redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    for (const layer of this.layers) {
      const layerNeedsRedraw = layer.getNeedsRedraw(opts);
      redraw = redraw || layerNeedsRedraw;
    }

    return redraw;
  }

  needsUpdate() {
    if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
      return 'layers changed';
    }

    return this._needsUpdate;
  }

  setNeedsRedraw(reason) {
    this._needsRedraw = this._needsRedraw || reason;
  }

  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
  }

  getLayers({
    layerIds
  } = {}) {
    return layerIds ? this.layers.filter(layer => layerIds.find(layerId => layer.id.indexOf(layerId) === 0)) : this.layers;
  }

  setProps(props) {
    if ('debug' in props) {
      this._debug = props.debug;
    }

    if ('userData' in props) {
      this.context.userData = props.userData;
    }

    if ('layers' in props) {
      this._nextLayers = props.layers;
    }

    if ('onError' in props) {
      this.context.onError = props.onError;
    }
  }

  setLayers(newLayers, reason) {
    (0,_debug__WEBPACK_IMPORTED_MODULE_2__["default"])(TRACE_SET_LAYERS, this, reason, newLayers);
    this._lastRenderedLayers = newLayers;
    const flatLayers = (0,_utils_flatten__WEBPACK_IMPORTED_MODULE_7__.flatten)(newLayers, Boolean);

    for (const layer of flatLayers) {
      layer.context = this.context;
    }

    this._updateLayers(this.layers, flatLayers);
  }

  updateLayers() {
    const reason = this.needsUpdate();

    if (reason) {
      this.setNeedsRedraw("updating layers: ".concat(reason));
      this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
    }

    this._nextLayers = null;
  }

  _handleError(stage, error, layer) {
    layer.raiseError(error, "".concat(stage, " of ").concat(layer));
  }

  _updateLayers(oldLayers, newLayers) {
    const oldLayerMap = {};

    for (const oldLayer of oldLayers) {
      if (oldLayerMap[oldLayer.id]) {
        _utils_log__WEBPACK_IMPORTED_MODULE_8__["default"].warn("Multiple old layers with same id ".concat(oldLayer.id))();
      } else {
        oldLayerMap[oldLayer.id] = oldLayer;
      }
    }

    const generatedLayers = [];

    this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);

    this._finalizeOldLayers(oldLayerMap);

    let needsUpdate = false;

    for (const layer of generatedLayers) {
      if (layer.hasUniformTransition()) {
        needsUpdate = "Uniform transition in ".concat(layer);
        break;
      }
    }

    this._needsUpdate = needsUpdate;
    this.layers = generatedLayers;
  }

  _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
    for (const newLayer of newLayers) {
      newLayer.context = this.context;
      const oldLayer = oldLayerMap[newLayer.id];

      if (oldLayer === null) {
        _utils_log__WEBPACK_IMPORTED_MODULE_8__["default"].warn("Multiple new layers with same id ".concat(newLayer.id))();
      }

      oldLayerMap[newLayer.id] = null;
      let sublayers = null;

      try {
        if (this._debug && oldLayer !== newLayer) {
          newLayer.validateProps();
        }

        if (!oldLayer) {
          this._initializeLayer(newLayer);
        } else {
          this._transferLayerState(oldLayer, newLayer);

          this._updateLayer(newLayer);
        }

        generatedLayers.push(newLayer);
        sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
      } catch (err) {
        this._handleError('matching', err, newLayer);
      }

      if (sublayers) {
        this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
      }
    }
  }

  _finalizeOldLayers(oldLayerMap) {
    for (const layerId in oldLayerMap) {
      const layer = oldLayerMap[layerId];

      if (layer) {
        this._finalizeLayer(layer);
      }
    }
  }

  _initializeLayer(layer) {
    try {
      layer._initialize();

      layer.lifecycle = _lifecycle_constants__WEBPACK_IMPORTED_MODULE_9__.LIFECYCLE.INITIALIZED;
    } catch (err) {
      this._handleError('initialization', err, layer);
    }
  }

  _transferLayerState(oldLayer, newLayer) {
    newLayer._transferState(oldLayer);

    newLayer.lifecycle = _lifecycle_constants__WEBPACK_IMPORTED_MODULE_9__.LIFECYCLE.MATCHED;

    if (newLayer !== oldLayer) {
      oldLayer.lifecycle = _lifecycle_constants__WEBPACK_IMPORTED_MODULE_9__.LIFECYCLE.AWAITING_GC;
    }
  }

  _updateLayer(layer) {
    try {
      layer._update();
    } catch (err) {
      this._handleError('update', err, layer);
    }
  }

  _finalizeLayer(layer) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
    layer.lifecycle = _lifecycle_constants__WEBPACK_IMPORTED_MODULE_9__.LIFECYCLE.AWAITING_FINALIZATION;

    try {
      layer._finalize();

      layer.lifecycle = _lifecycle_constants__WEBPACK_IMPORTED_MODULE_9__.LIFECYCLE.FINALIZED;
    } catch (err) {
      this._handleError('finalization', err, layer);
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/layer-state.js":
/*!****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/layer-state.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LayerState)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _lifecycle_component_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lifecycle/component-state */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js");


class LayerState extends _lifecycle_component_state__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor({
    attributeManager,
    layer
  }) {
    super(layer);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attributeManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "needsRedraw", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "needsUpdate", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "subLayers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "usesPickingColorCache", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "hasPickingBuffer", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "changeFlags", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewport", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "uniformTransitions", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "propsInTransition", void 0);

    this.attributeManager = attributeManager;
    this.needsRedraw = true;
    this.needsUpdate = true;
    this.subLayers = null;
    this.usesPickingColorCache = false;
  }

  get layer() {
    return this.component;
  }

  _fetch(propName, url) {
    const layer = this.layer;
    const fetch = layer === null || layer === void 0 ? void 0 : layer.props.fetch;

    if (fetch) {
      return fetch(url, {
        propName,
        layer
      });
    }

    return super._fetch(propName, url);
  }

  _onResolve(propName, value) {
    const layer = this.layer;

    if (layer) {
      const onDataLoad = layer.props.onDataLoad;

      if (propName === 'data' && onDataLoad) {
        onDataLoad(value, {
          propName,
          layer
        });
      }
    }
  }

  _onError(propName, error) {
    const layer = this.layer;

    if (layer) {
      layer.raiseError(error, "loading ".concat(propName, " of ").concat(this.layer));
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/layer.js":
/*!**********************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/layer.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Layer)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");
/* harmony import */ var _attribute_attribute_manager__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./attribute/attribute-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js");
/* harmony import */ var _uniform_transition_manager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./uniform-transition-manager */ "./node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js");
/* harmony import */ var _lifecycle_props__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../lifecycle/props */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/props.js");
/* harmony import */ var _lifecycle_constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lifecycle/constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");
/* harmony import */ var _utils_count__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/count */ "./node_modules/@deck.gl/core/dist/esm/utils/count.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _debug__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../debug */ "./node_modules/@deck.gl/core/dist/esm/debug/index.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _utils_memoize__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/memoize */ "./node_modules/@deck.gl/core/dist/esm/utils/memoize.js");
/* harmony import */ var _utils_shader__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/shader */ "./node_modules/@deck.gl/core/dist/esm/utils/shader.js");
/* harmony import */ var _shaderlib_project_project_functions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../shaderlib/project/project-functions */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js");
/* harmony import */ var _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/typed-array-manager */ "./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js");
/* harmony import */ var _lifecycle_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lifecycle/component */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/component.js");
/* harmony import */ var _layer_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./layer-state */ "./node_modules/@deck.gl/core/dist/esm/lib/layer-state.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/core */ "./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js");



















const TRACE_CHANGE_FLAG = 'layer.changeFlag';
const TRACE_INITIALIZE = 'layer.initialize';
const TRACE_UPDATE = 'layer.update';
const TRACE_FINALIZE = 'layer.finalize';
const TRACE_MATCHED = 'layer.matched';
const MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
const EMPTY_ARRAY = Object.freeze([]);
const areViewportsEqual = (0,_utils_memoize__WEBPACK_IMPORTED_MODULE_2__["default"])(({
  oldViewport,
  viewport
}) => {
  return oldViewport.equals(viewport);
});
let pickingColorCache = new Uint8ClampedArray(0);
const defaultProps = {
  data: {
    type: 'data',
    value: EMPTY_ARRAY,
    async: true
  },
  dataComparator: {
    type: 'function',
    value: null,
    optional: true
  },
  _dataDiff: {
    type: 'function',
    value: data => data && data.__diff,
    optional: true
  },
  dataTransform: {
    type: 'function',
    value: null,
    optional: true
  },
  onDataLoad: {
    type: 'function',
    value: null,
    optional: true
  },
  onError: {
    type: 'function',
    value: null,
    optional: true
  },
  fetch: {
    type: 'function',
    value: (url, {
      propName,
      layer,
      loaders,
      loadOptions,
      signal
    }) => {
      const {
        resourceManager
      } = layer.context;
      loadOptions = loadOptions || layer.getLoadOptions();
      loaders = loaders || layer.props.loaders;

      if (signal) {
        var _loadOptions;

        loadOptions = { ...loadOptions,
          fetch: { ...((_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch),
            signal
          }
        };
      }

      let inResourceManager = resourceManager.contains(url);

      if (!inResourceManager && !loadOptions) {
        resourceManager.add({
          resourceId: url,
          data: (0,_loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__.load)(url, loaders),
          persistent: false
        });
        inResourceManager = true;
      }

      if (inResourceManager) {
        return resourceManager.subscribe({
          resourceId: url,
          onChange: data => {
            var _layer$internalState;

            return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
          },
          consumerId: layer.id,
          requestId: propName
        });
      }

      return (0,_loaders_gl_core__WEBPACK_IMPORTED_MODULE_3__.load)(url, loaders, loadOptions);
    }
  },
  updateTriggers: {},
  visible: true,
  pickable: false,
  opacity: {
    type: 'number',
    min: 0,
    max: 1,
    value: 1
  },
  operation: 'draw',
  onHover: {
    type: 'function',
    value: null,
    optional: true
  },
  onClick: {
    type: 'function',
    value: null,
    optional: true
  },
  onDragStart: {
    type: 'function',
    value: null,
    optional: true
  },
  onDrag: {
    type: 'function',
    value: null,
    optional: true
  },
  onDragEnd: {
    type: 'function',
    value: null,
    optional: true
  },
  coordinateSystem: _constants__WEBPACK_IMPORTED_MODULE_4__.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin: {
    type: 'array',
    value: [0, 0, 0],
    compare: true
  },
  modelMatrix: {
    type: 'array',
    value: null,
    compare: true,
    optional: true
  },
  wrapLongitude: false,
  positionFormat: 'XYZ',
  colorFormat: 'RGBA',
  parameters: {
    type: 'object',
    value: {},
    optional: true,
    compare: 2
  },
  loadOptions: {
    type: 'object',
    value: null,
    optional: true,
    ignore: true
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: 'array',
    value: [],
    optional: true,
    ignore: true
  },
  getPolygonOffset: {
    type: 'function',
    value: ({
      layerIndex
    }) => [0, -layerIndex * 100]
  },
  highlightedObjectIndex: null,
  autoHighlight: false,
  highlightColor: {
    type: 'accessor',
    value: [0, 0, 128, 128]
  }
};
class Layer extends _lifecycle_component__WEBPACK_IMPORTED_MODULE_5__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "internalState", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "lifecycle", _lifecycle_constants__WEBPACK_IMPORTED_MODULE_6__.LIFECYCLE.NO_STATE);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "context", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "state", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "parent", null);
  }

  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, 'layerName') ? this.layerName : '';
  }

  get root() {
    let layer = this;

    while (layer.parent) {
      layer = layer.parent;
    }

    return layer;
  }

  toString() {
    const className = this.constructor.layerName || this.constructor.name;
    return "".concat(className, "({id: '").concat(this.props.id, "'})");
  }

  project(xyz) {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    const worldPosition = (0,_shaderlib_project_project_functions__WEBPACK_IMPORTED_MODULE_8__.getWorldPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    });
    const [x, y, z] = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.worldToPixels)(worldPosition, viewport.pixelProjectionMatrix);
    return xyz.length === 2 ? [x, y] : [x, y, z];
  }

  unproject(xy) {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return viewport.unproject(xy);
  }

  projectPosition(xyz, params) {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(this.internalState);
    const viewport = this.internalState.viewport || this.context.viewport;
    return (0,_shaderlib_project_project_functions__WEBPACK_IMPORTED_MODULE_8__.projectPosition)(xyz, {
      viewport,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...params
    });
  }

  get isComposite() {
    return false;
  }

  setState(partialState) {
    this.setChangeFlags({
      stateChanged: true
    });
    Object.assign(this.state, partialState);
    this.setNeedsRedraw();
  }

  setNeedsRedraw() {
    if (this.internalState) {
      this.internalState.needsRedraw = true;
    }
  }

  setNeedsUpdate() {
    if (this.internalState) {
      this.context.layerManager.setNeedsUpdate(String(this));
      this.internalState.needsUpdate = true;
    }
  }

  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
  }

  get wrapLongitude() {
    return this.props.wrapLongitude;
  }

  isPickable() {
    return this.props.pickable && this.props.visible;
  }

  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }

  setModuleParameters(moduleParameters) {
    for (const model of this.getModels()) {
      model.updateModuleSettings(moduleParameters);
    }
  }

  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }

  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }

  getLoadOptions() {
    return this.props.loadOptions;
  }

  use64bitPositions() {
    const {
      coordinateSystem
    } = this.props;
    return coordinateSystem === _constants__WEBPACK_IMPORTED_MODULE_4__.COORDINATE_SYSTEM.DEFAULT || coordinateSystem === _constants__WEBPACK_IMPORTED_MODULE_4__.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _constants__WEBPACK_IMPORTED_MODULE_4__.COORDINATE_SYSTEM.CARTESIAN;
  }

  onHover(info, pickingEvent) {
    if (this.props.onHover) {
      return this.props.onHover(info, pickingEvent) || false;
    }

    return false;
  }

  onClick(info, pickingEvent) {
    if (this.props.onClick) {
      return this.props.onClick(info, pickingEvent) || false;
    }

    return false;
  }

  nullPickingColor() {
    return [0, 0, 0];
  }

  encodePickingColor(i, target = []) {
    target[0] = i + 1 & 255;
    target[1] = i + 1 >> 8 & 255;
    target[2] = i + 1 >> 8 >> 8 & 255;
    return target;
  }

  decodePickingColor(color) {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(color instanceof Uint8Array);
    const [i1, i2, i3] = color;
    const index = i1 + i2 * 256 + i3 * 65536 - 1;
    return index;
  }

  getNumInstances() {
    if (Number.isFinite(this.props.numInstances)) {
      return this.props.numInstances;
    }

    if (this.state && this.state.numInstances !== undefined) {
      return this.state.numInstances;
    }

    return (0,_utils_count__WEBPACK_IMPORTED_MODULE_9__.count)(this.props.data);
  }

  getStartIndices() {
    if (this.props.startIndices) {
      return this.props.startIndices;
    }

    if (this.state && this.state.startIndices) {
      return this.state.startIndices;
    }

    return null;
  }

  getBounds() {
    var _this$getAttributeMan;

    return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(['positions', 'instancePositions']);
  }

  getShaders(shaders) {
    for (const extension of this.props.extensions) {
      shaders = (0,_utils_shader__WEBPACK_IMPORTED_MODULE_10__.mergeShaders)(shaders, extension.getShaders.call(this, extension));
    }

    return shaders;
  }

  shouldUpdateState(params) {
    return params.changeFlags.propsOrDataChanged;
  }

  updateState(params) {
    const attributeManager = this.getAttributeManager();
    const {
      dataChanged
    } = params.changeFlags;

    if (dataChanged && attributeManager) {
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          attributeManager.invalidateAll(dataRange);
        }
      } else {
        attributeManager.invalidateAll();
      }
    }

    if (attributeManager) {
      const {
        props
      } = params;
      const hasPickingBuffer = this.internalState.hasPickingBuffer;
      const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some(extension => extension.getNeedsPickingBuffer.call(this, extension));

      if (hasPickingBuffer !== needsPickingBuffer) {
        this.internalState.hasPickingBuffer = needsPickingBuffer;
        const {
          pickingColors,
          instancePickingColors
        } = attributeManager.attributes;
        const pickingColorsAttribute = pickingColors || instancePickingColors;

        if (pickingColorsAttribute) {
          if (needsPickingBuffer && pickingColorsAttribute.constant) {
            pickingColorsAttribute.constant = false;
            attributeManager.invalidate(pickingColorsAttribute.id);
          }

          if (!pickingColorsAttribute.value && !needsPickingBuffer) {
            pickingColorsAttribute.constant = true;
            pickingColorsAttribute.value = [0, 0, 0];
          }
        }
      }
    }
  }

  finalizeState(context) {
    for (const model of this.getModels()) {
      model.delete();
    }

    const attributeManager = this.getAttributeManager();

    if (attributeManager) {
      attributeManager.finalize();
    }

    if (this.context) {
      this.context.resourceManager.unsubscribe({
        consumerId: this.id
      });
    }

    if (this.internalState) {
      this.internalState.uniformTransitions.clear();
      this.internalState.finalize();
    }
  }

  draw(opts) {
    for (const model of this.getModels()) {
      model.draw(opts);
    }
  }

  getPickingInfo({
    info,
    mode,
    sourceLayer
  }) {
    const {
      index
    } = info;

    if (index >= 0) {
      if (Array.isArray(this.props.data)) {
        info.object = this.props.data[index];
      }
    }

    return info;
  }

  raiseError(error, message) {
    var _this$props$onError, _this$props;

    if (message) {
      error.message = "".concat(message, ": ").concat(error.message);
    }

    if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error))) {
      var _this$context, _this$context$onError;

      (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error, this);
    }
  }

  getNeedsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    return this._getNeedsRedraw(opts);
  }

  needsUpdate() {
    if (!this.internalState) {
      return false;
    }

    return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
  }

  hasUniformTransition() {
    var _this$internalState;

    return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
  }

  activateViewport(viewport) {
    if (!this.internalState) {
      return;
    }

    const oldViewport = this.internalState.viewport;
    this.internalState.viewport = viewport;

    if (!oldViewport || !areViewportsEqual({
      oldViewport,
      viewport
    })) {
      this.setChangeFlags({
        viewportChanged: true
      });

      if (this.isComposite) {
        if (this.needsUpdate()) {
          this.setNeedsUpdate();
        }
      } else {
        this._update();
      }
    }
  }

  invalidateAttribute(name = 'all') {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager) {
      return;
    }

    if (name === 'all') {
      attributeManager.invalidateAll();
    } else {
      attributeManager.invalidate(name);
    }
  }

  updateAttributes(changedAttributes) {
    for (const model of this.getModels()) {
      this._setModelAttributes(model, changedAttributes);
    }
  }

  _updateAttributes() {
    const attributeManager = this.getAttributeManager();

    if (!attributeManager) {
      return;
    }

    const props = this.props;
    const numInstances = this.getNumInstances();
    const startIndices = this.getStartIndices();
    attributeManager.update({
      data: props.data,
      numInstances,
      startIndices,
      props,
      transitions: props.transitions,
      buffers: props.data.attributes,
      context: this
    });
    const changedAttributes = attributeManager.getChangedAttributes({
      clearChangedFlags: true
    });
    this.updateAttributes(changedAttributes);
  }

  _updateAttributeTransition() {
    const attributeManager = this.getAttributeManager();

    if (attributeManager) {
      attributeManager.updateTransition();
    }
  }

  _updateUniformTransition() {
    const {
      uniformTransitions
    } = this.internalState;

    if (uniformTransitions.active) {
      const propsInTransition = uniformTransitions.update();
      const props = Object.create(this.props);

      for (const key in propsInTransition) {
        Object.defineProperty(props, key, {
          value: propsInTransition[key]
        });
      }

      return props;
    }

    return this.props;
  }

  calculateInstancePickingColors(attribute, {
    numInstances
  }) {
    if (attribute.constant) {
      return;
    }

    const cacheSize = Math.floor(pickingColorCache.length / 3);
    this.internalState.usesPickingColorCache = true;

    if (cacheSize < numInstances) {
      if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
        _utils_log__WEBPACK_IMPORTED_MODULE_11__["default"].warn('Layer has too many data objects. Picking might not be able to distinguish all objects.')();
      }

      pickingColorCache = _utils_typed_array_manager__WEBPACK_IMPORTED_MODULE_12__["default"].allocate(pickingColorCache, numInstances, {
        size: 3,
        copy: true,
        maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
      });
      const newCacheSize = Math.floor(pickingColorCache.length / 3);
      const pickingColor = [];

      for (let i = cacheSize; i < newCacheSize; i++) {
        this.encodePickingColor(i, pickingColor);
        pickingColorCache[i * 3 + 0] = pickingColor[0];
        pickingColorCache[i * 3 + 1] = pickingColor[1];
        pickingColorCache[i * 3 + 2] = pickingColor[2];
      }
    }

    attribute.value = pickingColorCache.subarray(0, numInstances * 3);
  }

  _setModelAttributes(model, changedAttributes) {
    const attributeManager = this.getAttributeManager();
    const excludeAttributes = model.userData.excludeAttributes || {};
    const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
    model.setAttributes(shaderAttributes);
  }

  disablePickingIndex(objectIndex) {
    const data = this.props.data;

    if (!('attributes' in data)) {
      this._disablePickingIndex(objectIndex);

      return;
    }

    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;
    const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];

    if (externalColorAttribute && externalColorAttribute.value) {
      const values = externalColorAttribute.value;
      const objectColor = this.encodePickingColor(objectIndex);

      for (let index = 0; index < data.length; index++) {
        const i = colors.getVertexOffset(index);

        if (values[i] === objectColor[0] && values[i + 1] === objectColor[1] && values[i + 2] === objectColor[2]) {
          this._disablePickingIndex(index);
        }
      }
    } else {
      this._disablePickingIndex(objectIndex);
    }
  }

  _disablePickingIndex(objectIndex) {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;

    if (!colors) {
      return;
    }

    const start = colors.getVertexOffset(objectIndex);
    const end = colors.getVertexOffset(objectIndex + 1);
    colors.buffer.subData({
      data: new Uint8Array(end - start),
      offset: start
    });
  }

  restorePickingColors() {
    const {
      pickingColors,
      instancePickingColors
    } = this.getAttributeManager().attributes;
    const colors = pickingColors || instancePickingColors;

    if (!colors) {
      return;
    }

    if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
      colors.value = pickingColorCache.subarray(0, colors.value.length);
    }

    colors.updateSubBuffer({
      startOffset: 0
    });
  }

  _initialize() {
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(!this.internalState);
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(Number.isFinite(this.props.coordinateSystem));
    (0,_debug__WEBPACK_IMPORTED_MODULE_13__["default"])(TRACE_INITIALIZE, this);

    const attributeManager = this._getAttributeManager();

    if (attributeManager) {
      attributeManager.addInstanced({
        instancePickingColors: {
          type: 5121,
          size: 3,
          noAlloc: true,
          update: this.calculateInstancePickingColors
        }
      });
    }

    this.internalState = new _layer_state__WEBPACK_IMPORTED_MODULE_14__["default"]({
      attributeManager,
      layer: this
    });

    this._clearChangeFlags();

    this.state = {};
    Object.defineProperty(this.state, 'attributeManager', {
      get: () => {
        _utils_log__WEBPACK_IMPORTED_MODULE_11__["default"].deprecated('layer.state.attributeManager', 'layer.getAttributeManager()')();
        return attributeManager;
      }
    });
    this.internalState.uniformTransitions = new _uniform_transition_manager__WEBPACK_IMPORTED_MODULE_15__["default"](this.context.timeline);
    this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
    this.internalState.setAsyncProps(this.props);
    this.initializeState(this.context);

    for (const extension of this.props.extensions) {
      extension.initializeState.call(this, this.context, extension);
    }

    this.setChangeFlags({
      dataChanged: 'init',
      propsChanged: 'init',
      viewportChanged: true,
      extensionsChanged: true
    });

    this._update();
  }

  _transferState(oldLayer) {
    (0,_debug__WEBPACK_IMPORTED_MODULE_13__["default"])(TRACE_MATCHED, this, this === oldLayer);
    const {
      state,
      internalState
    } = oldLayer;

    if (this === oldLayer) {
      return;
    }

    this.internalState = internalState;
    this.state = state;
    this.internalState.setAsyncProps(this.props);

    this._diffProps(this.props, this.internalState.getOldProps());
  }

  _update() {
    const stateNeedsUpdate = this.needsUpdate();
    (0,_debug__WEBPACK_IMPORTED_MODULE_13__["default"])(TRACE_UPDATE, this, stateNeedsUpdate);

    if (!stateNeedsUpdate) {
      return;
    }

    const currentProps = this.props;
    const context = this.context;
    const internalState = this.internalState;
    const currentViewport = context.viewport;

    const propsInTransition = this._updateUniformTransition();

    internalState.propsInTransition = propsInTransition;
    context.viewport = internalState.viewport || currentViewport;
    this.props = propsInTransition;

    try {
      const updateParams = this._getUpdateParams();

      const oldModels = this.getModels();

      if (context.gl) {
        this.updateState(updateParams);
      } else {
        try {
          this.updateState(updateParams);
        } catch (error) {}
      }

      for (const extension of this.props.extensions) {
        extension.updateState.call(this, updateParams, extension);
      }

      const modelChanged = this.getModels()[0] !== oldModels[0];

      this._postUpdate(updateParams, modelChanged);
    } finally {
      context.viewport = currentViewport;
      this.props = currentProps;

      this._clearChangeFlags();

      internalState.needsUpdate = false;
      internalState.resetOldProps();
    }
  }

  _finalize() {
    (0,_debug__WEBPACK_IMPORTED_MODULE_13__["default"])(TRACE_FINALIZE, this);
    this.finalizeState(this.context);

    for (const extension of this.props.extensions) {
      extension.finalizeState.call(this, this.context, extension);
    }
  }

  _drawLayer({
    moduleParameters = null,
    uniforms = {},
    parameters = {}
  }) {
    this._updateAttributeTransition();

    const currentProps = this.props;
    const context = this.context;
    this.props = this.internalState.propsInTransition || currentProps;
    const opacity = this.props.opacity;
    uniforms.opacity = Math.pow(opacity, 1 / 2.2);

    try {
      if (moduleParameters) {
        this.setModuleParameters(moduleParameters);
      }

      const {
        getPolygonOffset
      } = this.props;
      const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
      (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_16__.setParameters)(context.gl, {
        polygonOffset: offsets
      });
      (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_16__.withParameters)(context.gl, parameters, () => {
        const opts = {
          moduleParameters,
          uniforms,
          parameters,
          context
        };

        for (const extension of this.props.extensions) {
          extension.draw.call(this, opts, extension);
        }

        this.draw(opts);
      });
    } finally {
      this.props = currentProps;
    }
  }

  getChangeFlags() {
    var _this$internalState2;

    return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
  }

  setChangeFlags(flags) {
    if (!this.internalState) {
      return;
    }

    const {
      changeFlags
    } = this.internalState;

    for (const key in flags) {
      if (flags[key]) {
        let flagChanged = false;

        switch (key) {
          case 'dataChanged':
            const dataChangedReason = flags[key];
            const prevDataChangedReason = changeFlags[key];

            if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
              changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
              flagChanged = true;
            }

          default:
            if (!changeFlags[key]) {
              changeFlags[key] = flags[key];
              flagChanged = true;
            }

        }

        if (flagChanged) {
          (0,_debug__WEBPACK_IMPORTED_MODULE_13__["default"])(TRACE_CHANGE_FLAG, this, key, flags);
        }
      }
    }

    const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
    changeFlags.propsOrDataChanged = propsOrDataChanged;
    changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
  }

  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: false,
      propsChanged: false,
      updateTriggersChanged: false,
      viewportChanged: false,
      stateChanged: false,
      extensionsChanged: false,
      propsOrDataChanged: false,
      somethingChanged: false
    };
  }

  _diffProps(newProps, oldProps) {
    const changeFlags = (0,_lifecycle_props__WEBPACK_IMPORTED_MODULE_17__.diffProps)(newProps, oldProps);

    if (changeFlags.updateTriggersChanged) {
      for (const key in changeFlags.updateTriggersChanged) {
        if (changeFlags.updateTriggersChanged[key]) {
          this.invalidateAttribute(key);
        }
      }
    }

    if (changeFlags.transitionsChanged) {
      for (const key in changeFlags.transitionsChanged) {
        var _newProps$transitions;

        this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
      }
    }

    return this.setChangeFlags(changeFlags);
  }

  validateProps() {
    (0,_lifecycle_props__WEBPACK_IMPORTED_MODULE_17__.validateProps)(this.props);
  }

  updateAutoHighlight(info) {
    if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
      this._updateAutoHighlight(info);
    }
  }

  _updateAutoHighlight(info) {
    const pickingModuleParameters = {
      pickingSelectedColor: info.picked ? info.color : null
    };
    const {
      highlightColor
    } = this.props;

    if (info.picked && typeof highlightColor === 'function') {
      pickingModuleParameters.pickingHighlightColor = highlightColor(info);
    }

    this.setModuleParameters(pickingModuleParameters);
    this.setNeedsRedraw();
  }

  _getAttributeManager() {
    const context = this.context;
    return new _attribute_attribute_manager__WEBPACK_IMPORTED_MODULE_18__["default"](context.gl, {
      id: this.props.id,
      stats: context.stats,
      timeline: context.timeline
    });
  }

  _postUpdate(updateParams, forceUpdate) {
    const {
      props,
      oldProps
    } = updateParams;
    this.setNeedsRedraw();

    this._updateAttributes();

    const {
      model
    } = this.state;
    model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight,
      highlightedObjectIndex,
      highlightColor
    } = props;

    if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
      const parameters = {};

      if (!autoHighlight) {
        parameters.pickingSelectedColor = null;
      }

      if (Array.isArray(highlightColor)) {
        parameters.pickingHighlightColor = highlightColor;
      }

      if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
        parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
      }

      this.setModuleParameters(parameters);
    }
  }

  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }

  _getNeedsRedraw(opts) {
    if (!this.internalState) {
      return false;
    }

    let redraw = false;
    redraw = redraw || this.internalState.needsRedraw && this.id;
    const attributeManager = this.getAttributeManager();
    const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
    redraw = redraw || attributeManagerNeedsRedraw;

    if (redraw) {
      for (const extension of this.props.extensions) {
        extension.onNeedsRedraw.call(this, extension);
      }
    }

    this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
    return redraw;
  }

  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps());

    this.setNeedsUpdate();
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Layer, "defaultProps", defaultProps);

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Layer, "layerName", 'Layer');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getEmptyPickingInfo": () => (/* binding */ getEmptyPickingInfo),
/* harmony export */   "getLayerPickingInfo": () => (/* binding */ getLayerPickingInfo),
/* harmony export */   "processPickInfo": () => (/* binding */ processPickInfo)
/* harmony export */ });
function getEmptyPickingInfo({
  pickInfo,
  viewports,
  pixelRatio,
  x,
  y,
  z
}) {
  let pickedViewport = viewports[0];

  if (viewports.length > 1) {
    pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
      x,
      y
    });
  }

  let coordinate;

  if (pickedViewport) {
    const point = [x - pickedViewport.x, y - pickedViewport.y];

    if (z !== undefined) {
      point[2] = z;
    }

    coordinate = pickedViewport.unproject(point);
  }

  return {
    color: null,
    layer: null,
    viewport: pickedViewport,
    index: -1,
    picked: false,
    x,
    y,
    pixel: [x, y],
    coordinate,
    devicePixel: pickInfo && 'pickedX' in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : undefined,
    pixelRatio
  };
}
function processPickInfo(opts) {
  const {
    pickInfo,
    lastPickedInfo,
    mode,
    layers
  } = opts;
  const {
    pickedColor,
    pickedLayer,
    pickedObjectIndex
  } = pickInfo;
  const affectedLayers = pickedLayer ? [pickedLayer] : [];

  if (mode === 'hover') {
    const lastPickedPixelIndex = lastPickedInfo.index;
    const lastPickedLayerId = lastPickedInfo.layerId;
    const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;

    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
      if (pickedLayerId !== lastPickedLayerId) {
        const lastPickedLayer = layers.find(layer => layer.props.id === lastPickedLayerId);

        if (lastPickedLayer) {
          affectedLayers.unshift(lastPickedLayer);
        }
      }

      lastPickedInfo.layerId = pickedLayerId;
      lastPickedInfo.index = pickedObjectIndex;
      lastPickedInfo.info = null;
    }
  }

  const baseInfo = getEmptyPickingInfo(opts);
  const infos = new Map();
  infos.set(null, baseInfo);
  affectedLayers.forEach(layer => {
    let info = { ...baseInfo
    };

    if (layer === pickedLayer) {
      info.color = pickedColor;
      info.index = pickedObjectIndex;
      info.picked = true;
    }

    info = getLayerPickingInfo({
      layer,
      info,
      mode
    });
    const rootLayer = info.layer;

    if (layer === pickedLayer && mode === 'hover') {
      lastPickedInfo.info = info;
    }

    infos.set(rootLayer.id, info);

    if (mode === 'hover') {
      rootLayer.updateAutoHighlight(info);
    }
  });
  return infos;
}
function getLayerPickingInfo({
  layer,
  info,
  mode
}) {
  while (layer && info) {
    const sourceLayer = info.layer || null;
    info.sourceLayer = sourceLayer;
    info.layer = layer;
    info = layer.getPickingInfo({
      info,
      mode,
      sourceLayer
    });
    layer = layer.parent;
  }

  return info;
}

function getViewportFromCoordinates(viewports, pixel) {
  for (let i = viewports.length - 1; i >= 0; i--) {
    const viewport = viewports[i];

    if (viewport.containsPixel(pixel)) {
      return viewport;
    }
  }

  return viewports[0];
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getClosestObject": () => (/* binding */ getClosestObject),
/* harmony export */   "getUniqueObjects": () => (/* binding */ getUniqueObjects)
/* harmony export */ });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");

const NO_PICKED_OBJECT = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function getClosestObject({
  pickedColors,
  decodePickingColor,
  deviceX,
  deviceY,
  deviceRadius,
  deviceRect
}) {
  const {
    x,
    y,
    width,
    height
  } = deviceRect;
  let minSquareDistanceToCenter = deviceRadius * deviceRadius;
  let closestPixelIndex = -1;
  let i = 0;

  for (let row = 0; row < height; row++) {
    const dy = row + y - deviceY;
    const dy2 = dy * dy;

    if (dy2 > minSquareDistanceToCenter) {
      i += 4 * width;
    } else {
      for (let col = 0; col < width; col++) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;

        if (pickedLayerIndex >= 0) {
          const dx = col + x - deviceX;
          const d2 = dx * dx + dy2;

          if (d2 <= minSquareDistanceToCenter) {
            minSquareDistanceToCenter = d2;
            closestPixelIndex = i;
          }
        }

        i += 4;
      }
    }
  }

  if (closestPixelIndex >= 0) {
    const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
    const pickedObject = decodePickingColor(pickedColor);

    if (pickedObject) {
      const dy = Math.floor(closestPixelIndex / 4 / width);
      const dx = closestPixelIndex / 4 - dy * width;
      return { ...pickedObject,
        pickedColor,
        pickedX: x + dx,
        pickedY: y + dy
      };
    }

    _utils_log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Picked non-existent layer. Is picking buffer corrupt?')();
  }

  return NO_PICKED_OBJECT;
}
function getUniqueObjects({
  pickedColors,
  decodePickingColor
}) {
  const uniqueColors = new Map();

  if (pickedColors) {
    for (let i = 0; i < pickedColors.length; i += 4) {
      const pickedLayerIndex = pickedColors[i + 3] - 1;

      if (pickedLayerIndex >= 0) {
        const pickedColor = pickedColors.slice(i, i + 4);
        const colorKey = pickedColor.join(',');

        if (!uniqueColors.has(colorKey)) {
          const pickedObject = decodePickingColor(pickedColor);

          if (pickedObject) {
            uniqueColors.set(colorKey, { ...pickedObject,
              color: pickedColor
            });
          } else {
            _utils_log__WEBPACK_IMPORTED_MODULE_0__["default"].error('Picked non-existent layer. Is picking buffer corrupt?')();
          }
        }
      }
    }
  }

  return Array.from(uniqueColors.values());
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ResourceManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "./node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js");


class ResourceManager {
  constructor({
    gl,
    protocol
  }) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "protocol", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_context", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_resources", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_consumers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_pruneRequest", void 0);

    this.protocol = protocol || 'resource://';
    this._context = {
      gl,
      resourceManager: this
    };
    this._resources = {};
    this._consumers = {};
    this._pruneRequest = null;
  }

  contains(resourceId) {
    if (resourceId.startsWith(this.protocol)) {
      return true;
    }

    return resourceId in this._resources;
  }

  add({
    resourceId,
    data,
    forceUpdate = false,
    persistent = true
  }) {
    let res = this._resources[resourceId];

    if (res) {
      res.setData(data, forceUpdate);
    } else {
      res = new _resource__WEBPACK_IMPORTED_MODULE_1__["default"](resourceId, data, this._context);
      this._resources[resourceId] = res;
    }

    res.persistent = persistent;
  }

  remove(resourceId) {
    const res = this._resources[resourceId];

    if (res) {
      res.delete();
      delete this._resources[resourceId];
    }
  }

  unsubscribe({
    consumerId
  }) {
    const consumer = this._consumers[consumerId];

    if (consumer) {
      for (const requestId in consumer) {
        const request = consumer[requestId];
        const resource = this._resources[request.resourceId];

        if (resource) {
          resource.unsubscribe(request);
        }
      }

      delete this._consumers[consumerId];
      this.prune();
    }
  }

  subscribe({
    resourceId,
    onChange,
    consumerId,
    requestId = 'default'
  }) {
    const {
      _resources: resources,
      protocol
    } = this;

    if (resourceId.startsWith(protocol)) {
      resourceId = resourceId.replace(protocol, '');

      if (!resources[resourceId]) {
        this.add({
          resourceId,
          data: null,
          persistent: false
        });
      }
    }

    const res = resources[resourceId];

    this._track(consumerId, requestId, res, onChange);

    if (res) {
      return res.getData();
    }

    return undefined;
  }

  prune() {
    if (!this._pruneRequest) {
      this._pruneRequest = setTimeout(() => this._prune(), 0);
    }
  }

  finalize() {
    for (const key in this._resources) {
      this._resources[key].delete();
    }
  }

  _track(consumerId, requestId, resource, onChange) {
    const consumers = this._consumers;
    const consumer = consumers[consumerId] = consumers[consumerId] || {};
    const request = consumer[requestId] || {};
    const oldResource = request.resourceId && this._resources[request.resourceId];

    if (oldResource) {
      oldResource.unsubscribe(request);
      this.prune();
    }

    if (resource) {
      consumer[requestId] = request;
      request.onChange = onChange;
      request.resourceId = resource.id;
      resource.subscribe(request);
    }
  }

  _prune() {
    this._pruneRequest = null;

    for (const key of Object.keys(this._resources)) {
      const res = this._resources[key];

      if (!res.persistent && !res.inUse()) {
        res.delete();
        delete this._resources[key];
      }
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Resource)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/core */ "./node_modules/@loaders.gl/core/dist/esm/lib/api/load.js");


class Resource {
  constructor(id, data, context) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "context", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isLoaded", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "persistent", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_loadCount", 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_subscribers", new Set());

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_data", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_loader", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_error", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_content", void 0);

    this.id = id;
    this.context = context;
    this.setData(data);
  }

  subscribe(consumer) {
    this._subscribers.add(consumer);
  }

  unsubscribe(consumer) {
    this._subscribers.delete(consumer);
  }

  inUse() {
    return this._subscribers.size > 0;
  }

  delete() {}

  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }

  setData(data, forceUpdate) {
    if (data === this._data && !forceUpdate) {
      return;
    }

    this._data = data;
    const loadCount = ++this._loadCount;
    let loader = data;

    if (typeof data === 'string') {
      loader = (0,_loaders_gl_core__WEBPACK_IMPORTED_MODULE_1__.load)(data);
    }

    if (loader instanceof Promise) {
      this.isLoaded = false;
      this._loader = loader.then(result => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = undefined;
          this._content = result;
        }
      }).catch(error => {
        if (this._loadCount === loadCount) {
          this.isLoaded = true;
          this._error = error || true;
        }
      });
    } else {
      this.isLoaded = true;
      this._error = undefined;
      this._content = data;
    }

    for (const subscriber of this._subscribers) {
      subscriber.onChange(this.getData());
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/tooltip.js":
/*!************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/tooltip.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

const defaultStyle = {
  zIndex: '1',
  position: 'absolute',
  pointerEvents: 'none',
  color: '#a0a7b4',
  backgroundColor: '#29323c',
  padding: '10px',
  top: '0',
  left: '0',
  display: 'none'
};
class Tooltip {
  constructor(canvas) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "el", null);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isVisible", false);

    const canvasParent = canvas.parentElement;

    if (canvasParent) {
      this.el = document.createElement('div');
      this.el.className = 'deck-tooltip';
      Object.assign(this.el.style, defaultStyle);
      canvasParent.appendChild(this.el);
    }
  }

  setTooltip(displayInfo, x, y) {
    const el = this.el;

    if (!el) {
      return;
    }

    if (typeof displayInfo === 'string') {
      el.innerText = displayInfo;
    } else if (!displayInfo) {
      this.isVisible = false;
      el.style.display = 'none';
      return;
    } else {
      if (displayInfo.text) {
        el.innerText = displayInfo.text;
      }

      if (displayInfo.html) {
        el.innerHTML = displayInfo.html;
      }

      if (displayInfo.className) {
        el.className = displayInfo.className;
      }

      Object.assign(el.style, displayInfo.style);
    }

    this.isVisible = true;
    el.style.display = 'block';
    el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
  }

  remove() {
    if (this.el) {
      this.el.remove();
      this.el = null;
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UniformTransitionManager)
/* harmony export */ });
/* harmony import */ var _attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./attribute/attribute-transition-utils */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js");
/* harmony import */ var _transitions_cpu_interpolation_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transitions/cpu-interpolation-transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js");
/* harmony import */ var _transitions_cpu_spring_transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transitions/cpu-spring-transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");




const TRANSITION_TYPES = {
  interpolation: _transitions_cpu_interpolation_transition__WEBPACK_IMPORTED_MODULE_0__["default"],
  spring: _transitions_cpu_spring_transition__WEBPACK_IMPORTED_MODULE_1__["default"]
};
class UniformTransitionManager {
  constructor(timeline) {
    this.transitions = new Map();
    this.timeline = timeline;
  }

  get active() {
    return this.transitions.size > 0;
  }

  add(key, fromValue, toValue, settings) {
    const {
      transitions
    } = this;

    if (transitions.has(key)) {
      const transition = transitions.get(key);
      const {
        value = transition.settings.fromValue
      } = transition;
      fromValue = value;
      this.remove(key);
    }

    settings = (0,_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeTransitionSettings)(settings);

    if (!settings) {
      return;
    }

    const TransitionType = TRANSITION_TYPES[settings.type];

    if (!TransitionType) {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].error("unsupported transition type '".concat(settings.type, "'"))();
      return;
    }

    const transition = new TransitionType(this.timeline);
    transition.start({ ...settings,
      fromValue,
      toValue
    });
    transitions.set(key, transition);
  }

  remove(key) {
    const {
      transitions
    } = this;

    if (transitions.has(key)) {
      transitions.get(key).cancel();
      transitions.delete(key);
    }
  }

  update() {
    const propsInTransition = {};

    for (const [key, transition] of this.transitions) {
      transition.update();
      propsInTransition[key] = transition.value;

      if (!transition.inProgress) {
        this.remove(key);
      }
    }

    return propsInTransition;
  }

  clear() {
    for (const key of this.transitions.keys()) {
      this.remove(key);
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lib/view-manager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lib/view-manager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ViewManager)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _utils_flatten__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/flatten */ "./node_modules/@deck.gl/core/dist/esm/utils/flatten.js");




class ViewManager {
  constructor(props) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "width", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "height", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "views", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewState", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "controllers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "timeline", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_viewports", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_viewportMap", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_isUpdating", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsRedraw", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_needsUpdate", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_eventManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_eventCallbacks", void 0);

    this.views = [];
    this.width = 100;
    this.height = 100;
    this.viewState = {};
    this.controllers = {};
    this.timeline = props.timeline;
    this._viewports = [];
    this._viewportMap = {};
    this._isUpdating = false;
    this._needsRedraw = 'First render';
    this._needsUpdate = 'Initialize';
    this._eventManager = props.eventManager;
    this._eventCallbacks = {
      onViewStateChange: props.onViewStateChange,
      onInteractionStateChange: props.onInteractionStateChange
    };
    Object.seal(this);
    this.setProps(props);
  }

  finalize() {
    for (const key in this.controllers) {
      const controller = this.controllers[key];

      if (controller) {
        controller.finalize();
      }
    }

    this.controllers = {};
  }

  needsRedraw(opts = {
    clearRedrawFlags: false
  }) {
    const redraw = this._needsRedraw;

    if (opts.clearRedrawFlags) {
      this._needsRedraw = false;
    }

    return redraw;
  }

  setNeedsUpdate(reason) {
    this._needsUpdate = this._needsUpdate || reason;
    this._needsRedraw = this._needsRedraw || reason;
  }

  updateViewStates() {
    for (const viewId in this.controllers) {
      const controller = this.controllers[viewId];

      if (controller) {
        controller.updateTransition();
      }
    }
  }

  getViewports(rect) {
    if (rect) {
      return this._viewports.filter(viewport => viewport.containsPixel(rect));
    }

    return this._viewports;
  }

  getViews() {
    const viewMap = {};
    this.views.forEach(view => {
      viewMap[view.id] = view;
    });
    return viewMap;
  }

  getView(viewId) {
    return this.views.find(view => view.id === viewId);
  }

  getViewState(viewOrViewId) {
    const view = typeof viewOrViewId === 'string' ? this.getView(viewOrViewId) : viewOrViewId;
    const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
    return view ? view.filterViewState(viewState) : viewState;
  }

  getViewport(viewId) {
    return this._viewportMap[viewId];
  }

  unproject(xyz, opts) {
    const viewports = this.getViewports();
    const pixel = {
      x: xyz[0],
      y: xyz[1]
    };

    for (let i = viewports.length - 1; i >= 0; --i) {
      const viewport = viewports[i];

      if (viewport.containsPixel(pixel)) {
        const p = xyz.slice();
        p[0] -= viewport.x;
        p[1] -= viewport.y;
        return viewport.unproject(p, opts);
      }
    }

    return null;
  }

  setProps(props) {
    if (props.views) {
      this._setViews(props.views);
    }

    if (props.viewState) {
      this._setViewState(props.viewState);
    }

    if ('width' in props || 'height' in props) {
      this._setSize(props.width, props.height);
    }

    if (!this._isUpdating) {
      this._update();
    }
  }

  _update() {
    this._isUpdating = true;

    if (this._needsUpdate) {
      this._needsUpdate = false;

      this._rebuildViewports();
    }

    if (this._needsUpdate) {
      this._needsUpdate = false;

      this._rebuildViewports();
    }

    this._isUpdating = false;
  }

  _setSize(width, height) {
    if (width !== this.width || height !== this.height) {
      this.width = width;
      this.height = height;
      this.setNeedsUpdate('Size changed');
    }
  }

  _setViews(views) {
    views = (0,_utils_flatten__WEBPACK_IMPORTED_MODULE_1__.flatten)(views, Boolean);

    const viewsChanged = this._diffViews(views, this.views);

    if (viewsChanged) {
      this.setNeedsUpdate('views changed');
    }

    this.views = views;
  }

  _setViewState(viewState) {
    if (viewState) {
      const viewStateChanged = !(0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(viewState, this.viewState, 3);

      if (viewStateChanged) {
        this.setNeedsUpdate('viewState changed');
      }

      this.viewState = viewState;
    } else {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].warn('missing `viewState` or `initialViewState`')();
    }
  }

  _onViewStateChange(viewId, event) {
    if (this._eventCallbacks.onViewStateChange) {
      this._eventCallbacks.onViewStateChange({ ...event,
        viewId
      });
    }
  }

  _createController(view, props) {
    const Controller = props.type;
    const controller = new Controller({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, props.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: viewState => {
        var _this$getView;

        return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
      }
    });
    return controller;
  }

  _updateController(view, viewState, viewport, controller) {
    const controllerProps = view.controller;

    if (controllerProps && viewport) {
      const resolvedProps = { ...viewState,
        ...controllerProps,
        id: view.id,
        x: viewport.x,
        y: viewport.y,
        width: viewport.width,
        height: viewport.height
      };

      if (!controller) {
        controller = this._createController(view, resolvedProps);
      }

      if (controller) {
        controller.setProps(resolvedProps);
      }

      return controller;
    }

    return null;
  }

  _rebuildViewports() {
    const {
      views
    } = this;
    const oldControllers = this.controllers;
    this._viewports = [];
    this.controllers = {};
    let invalidateControllers = false;

    for (let i = views.length; i--;) {
      const view = views[i];
      const viewState = this.getViewState(view);
      const viewport = view.makeViewport({
        viewState,
        width: this.width,
        height: this.height
      });
      let oldController = oldControllers[view.id];
      const hasController = Boolean(view.controller);

      if (hasController && !oldController) {
        invalidateControllers = true;
      }

      if ((invalidateControllers || !hasController) && oldController) {
        oldController.finalize();
        oldController = null;
      }

      this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);

      if (viewport) {
        this._viewports.unshift(viewport);
      }
    }

    for (const id in oldControllers) {
      const oldController = oldControllers[id];

      if (oldController && !this.controllers[id]) {
        oldController.finalize();
      }
    }

    this._buildViewportMap();
  }

  _buildViewportMap() {
    this._viewportMap = {};

    this._viewports.forEach(viewport => {
      if (viewport.id) {
        this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
      }
    });
  }

  _diffViews(newViews, oldViews) {
    if (newViews.length !== oldViews.length) {
      return true;
    }

    return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ComponentState)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_iterable_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/iterable-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");



const EMPTY_PROPS = Object.freeze({});
class ComponentState {
  constructor(component) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "component", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "onAsyncPropUpdated", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "asyncProps", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "oldProps", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "oldAsyncProps", void 0);

    this.component = component;
    this.asyncProps = {};

    this.onAsyncPropUpdated = () => {};

    this.oldProps = null;
    this.oldAsyncProps = null;
  }

  finalize() {
    for (const propName in this.asyncProps) {
      const asyncProp = this.asyncProps[propName];

      if (asyncProp && asyncProp.type && asyncProp.type.release) {
        asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
      }
    }

    this.asyncProps = {};
    this.component = null;
    this.resetOldProps();
  }

  getOldProps() {
    return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
  }

  resetOldProps() {
    this.oldAsyncProps = null;
    this.oldProps = this.component ? this.component.props : null;
  }

  hasAsyncProp(propName) {
    return propName in this.asyncProps;
  }

  getAsyncProp(propName) {
    const asyncProp = this.asyncProps[propName];
    return asyncProp && asyncProp.resolvedValue;
  }

  isAsyncPropLoading(propName) {
    if (propName) {
      const asyncProp = this.asyncProps[propName];
      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
    }

    for (const key in this.asyncProps) {
      if (this.isAsyncPropLoading(key)) {
        return true;
      }
    }

    return false;
  }

  reloadAsyncProp(propName, value) {
    this._watchPromise(propName, Promise.resolve(value));
  }

  setAsyncProps(props) {
    this.component = props[_constants__WEBPACK_IMPORTED_MODULE_1__.COMPONENT_SYMBOL] || this.component;
    const resolvedValues = props[_constants__WEBPACK_IMPORTED_MODULE_1__.ASYNC_RESOLVED_SYMBOL] || {};
    const originalValues = props[_constants__WEBPACK_IMPORTED_MODULE_1__.ASYNC_ORIGINAL_SYMBOL] || props;
    const defaultValues = props[_constants__WEBPACK_IMPORTED_MODULE_1__.ASYNC_DEFAULTS_SYMBOL] || {};

    for (const propName in resolvedValues) {
      const value = resolvedValues[propName];

      this._createAsyncPropData(propName, defaultValues[propName]);

      this._updateAsyncProp(propName, value);

      resolvedValues[propName] = this.getAsyncProp(propName);
    }

    for (const propName in originalValues) {
      const value = originalValues[propName];

      this._createAsyncPropData(propName, defaultValues[propName]);

      this._updateAsyncProp(propName, value);
    }
  }

  _fetch(propName, url) {
    return null;
  }

  _onResolve(propName, value) {}

  _onError(propName, error) {}

  _updateAsyncProp(propName, value) {
    if (!this._didAsyncInputValueChange(propName, value)) {
      return;
    }

    if (typeof value === 'string') {
      value = this._fetch(propName, value);
    }

    if (value instanceof Promise) {
      this._watchPromise(propName, value);

      return;
    }

    if ((0,_utils_iterable_utils__WEBPACK_IMPORTED_MODULE_2__.isAsyncIterable)(value)) {
      this._resolveAsyncIterable(propName, value);

      return;
    }

    this._setPropValue(propName, value);
  }

  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);

      for (const propName in this.asyncProps) {
        Object.defineProperty(this.oldAsyncProps, propName, {
          enumerable: true,
          value: this.oldProps[propName]
        });
      }
    }
  }

  _didAsyncInputValueChange(propName, value) {
    const asyncProp = this.asyncProps[propName];

    if (value === asyncProp.resolvedValue || value === asyncProp.lastValue) {
      return false;
    }

    asyncProp.lastValue = value;
    return true;
  }

  _setPropValue(propName, value) {
    this._freezeAsyncOldProps();

    const asyncProp = this.asyncProps[propName];

    if (asyncProp) {
      value = this._postProcessValue(asyncProp, value);
      asyncProp.resolvedValue = value;
      asyncProp.pendingLoadCount++;
      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
    }
  }

  _setAsyncPropValue(propName, value, loadCount) {
    const asyncProp = this.asyncProps[propName];

    if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value !== undefined) {
      this._freezeAsyncOldProps();

      asyncProp.resolvedValue = value;
      asyncProp.resolvedLoadCount = loadCount;
      this.onAsyncPropUpdated(propName, value);
    }
  }

  _watchPromise(propName, promise) {
    const asyncProp = this.asyncProps[propName];

    if (asyncProp) {
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      promise.then(data => {
        if (!this.component) {
          return;
        }

        data = this._postProcessValue(asyncProp, data);

        this._setAsyncPropValue(propName, data, loadCount);

        this._onResolve(propName, data);
      }).catch(error => {
        this._onError(propName, error);
      });
    }
  }

  async _resolveAsyncIterable(propName, iterable) {
    if (propName !== 'data') {
      this._setPropValue(propName, iterable);

      return;
    }

    const asyncProp = this.asyncProps[propName];

    if (!asyncProp) {
      return;
    }

    asyncProp.pendingLoadCount++;
    const loadCount = asyncProp.pendingLoadCount;
    let data = [];
    let count = 0;

    for await (const chunk of iterable) {
      if (!this.component) {
        return;
      }

      const {
        dataTransform
      } = this.component.props;

      if (dataTransform) {
        data = dataTransform(chunk, data);
      } else {
        data = data.concat(chunk);
      }

      Object.defineProperty(data, '__diff', {
        enumerable: false,
        value: [{
          startRow: count,
          endRow: data.length
        }]
      });
      count = data.length;

      this._setAsyncPropValue(propName, data, loadCount);
    }

    this._onResolve(propName, data);
  }

  _postProcessValue(asyncProp, value) {
    const propType = asyncProp.type;

    if (propType && this.component) {
      if (propType.release) {
        propType.release(asyncProp.resolvedValue, propType, this.component);
      }

      if (propType.transform) {
        return propType.transform(value, propType, this.component);
      }
    }

    return value;
  }

  _createAsyncPropData(propName, defaultValue) {
    const asyncProp = this.asyncProps[propName];

    if (!asyncProp) {
      const propTypes = this.component && this.component.props[_constants__WEBPACK_IMPORTED_MODULE_1__.PROP_TYPES_SYMBOL];
      this.asyncProps[propName] = {
        type: propTypes && propTypes[propName],
        lastValue: null,
        resolvedValue: defaultValue,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lifecycle/component.js":
/*!********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lifecycle/component.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Component)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");
/* harmony import */ var _create_props__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-props */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js");



let counter = 0;
class Component {
  constructor(...propObjects) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "count", void 0);

    this.props = (0,_create_props__WEBPACK_IMPORTED_MODULE_1__.createProps)(this, propObjects);
    this.id = this.props.id;
    this.count = counter++;
  }

  clone(newProps) {
    const {
      props
    } = this;
    const asyncProps = {};

    for (const key in props[_constants__WEBPACK_IMPORTED_MODULE_2__.ASYNC_DEFAULTS_SYMBOL]) {
      if (key in props[_constants__WEBPACK_IMPORTED_MODULE_2__.ASYNC_RESOLVED_SYMBOL]) {
        asyncProps[key] = props[_constants__WEBPACK_IMPORTED_MODULE_2__.ASYNC_RESOLVED_SYMBOL][key];
      } else if (key in props[_constants__WEBPACK_IMPORTED_MODULE_2__.ASYNC_ORIGINAL_SYMBOL]) {
        asyncProps[key] = props[_constants__WEBPACK_IMPORTED_MODULE_2__.ASYNC_ORIGINAL_SYMBOL][key];
      }
    }

    return new this.constructor({ ...props,
      ...asyncProps,
      ...newProps
    });
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Component, "componentName", 'Component');

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Component, "defaultProps", {});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ASYNC_DEFAULTS_SYMBOL": () => (/* binding */ ASYNC_DEFAULTS_SYMBOL),
/* harmony export */   "ASYNC_ORIGINAL_SYMBOL": () => (/* binding */ ASYNC_ORIGINAL_SYMBOL),
/* harmony export */   "ASYNC_RESOLVED_SYMBOL": () => (/* binding */ ASYNC_RESOLVED_SYMBOL),
/* harmony export */   "COMPONENT_SYMBOL": () => (/* binding */ COMPONENT_SYMBOL),
/* harmony export */   "DEPRECATED_PROPS_SYMBOL": () => (/* binding */ DEPRECATED_PROPS_SYMBOL),
/* harmony export */   "LIFECYCLE": () => (/* binding */ LIFECYCLE),
/* harmony export */   "PROP_TYPES_SYMBOL": () => (/* binding */ PROP_TYPES_SYMBOL)
/* harmony export */ });
const LIFECYCLE = {
  NO_STATE: 'Awaiting state',
  MATCHED: 'Matched. State transferred from previous layer',
  INITIALIZED: 'Initialized',
  AWAITING_GC: 'Discarded. Awaiting garbage collection',
  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
  FINALIZED: 'Finalized! Awaiting garbage collection'
};
const COMPONENT_SYMBOL = Symbol.for('component');
const PROP_TYPES_SYMBOL = Symbol.for('propTypes');
const DEPRECATED_PROPS_SYMBOL = Symbol.for('deprecatedProps');
const ASYNC_DEFAULTS_SYMBOL = Symbol.for('asyncPropDefaults');
const ASYNC_ORIGINAL_SYMBOL = Symbol.for('asyncPropOriginal');
const ASYNC_RESOLVED_SYMBOL = Symbol.for('asyncPropResolved');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProps": () => (/* binding */ createProps)
/* harmony export */ });
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _utils_iterable_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterable-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js");
/* harmony import */ var _prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./prop-types */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");




function createProps(component, propObjects) {
  let extensions;

  for (let i = propObjects.length - 1; i >= 0; i--) {
    const props = propObjects[i];

    if ('extensions' in props) {
      extensions = props.extensions;
    }
  }

  const propsPrototype = getPropsPrototype(component.constructor, extensions);
  const propsInstance = Object.create(propsPrototype);
  propsInstance[_constants__WEBPACK_IMPORTED_MODULE_0__.COMPONENT_SYMBOL] = component;
  propsInstance[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_ORIGINAL_SYMBOL] = {};
  propsInstance[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_RESOLVED_SYMBOL] = {};

  for (let i = 0; i < propObjects.length; ++i) {
    const props = propObjects[i];

    for (const key in props) {
      propsInstance[key] = props[key];
    }
  }

  Object.freeze(propsInstance);
  return propsInstance;
}
const MergedDefaultPropsCacheKey = '_mergedDefaultProps';

function getPropsPrototype(componentClass, extensions) {
  let cacheKey = MergedDefaultPropsCacheKey;

  if (extensions) {
    for (const extension of extensions) {
      const ExtensionClass = extension.constructor;

      if (ExtensionClass) {
        cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
      }
    }
  }

  const defaultProps = getOwnProperty(componentClass, cacheKey);

  if (!defaultProps) {
    return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
  }

  return defaultProps;
}

function createPropsPrototypeAndTypes(componentClass, extensions) {
  const parent = componentClass.prototype;

  if (!parent) {
    return null;
  }

  const parentClass = Object.getPrototypeOf(componentClass);
  const parentDefaultProps = getPropsPrototype(parentClass);
  const componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
  const componentPropDefs = (0,_prop_types__WEBPACK_IMPORTED_MODULE_1__.parsePropTypes)(componentDefaultProps);
  const defaultProps = Object.assign(Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
  const propTypes = Object.assign(Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
  const deprecatedProps = Object.assign(Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);

  for (const extension of extensions) {
    const extensionDefaultProps = getPropsPrototype(extension.constructor);

    if (extensionDefaultProps) {
      Object.assign(defaultProps, extensionDefaultProps);
      Object.assign(propTypes, extensionDefaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.PROP_TYPES_SYMBOL]);
      Object.assign(deprecatedProps, extensionDefaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_PROPS_SYMBOL]);
    }
  }

  createPropsPrototype(defaultProps, componentClass);
  addAsyncPropsToPropPrototype(defaultProps, propTypes);
  addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps);
  defaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.PROP_TYPES_SYMBOL] = propTypes;
  defaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.DEPRECATED_PROPS_SYMBOL] = deprecatedProps;

  if (extensions.length === 0 && !hasOwnProperty(componentClass, '_propTypes')) {
    componentClass._propTypes = propTypes;
  }

  return defaultProps;
}

function createPropsPrototype(defaultProps, componentClass) {
  const id = getComponentName(componentClass);
  Object.defineProperties(defaultProps, {
    id: {
      writable: true,
      value: id
    }
  });
}

function addDeprecatedPropsToPropPrototype(defaultProps, deprecatedProps) {
  for (const propName in deprecatedProps) {
    Object.defineProperty(defaultProps, propName, {
      enumerable: false,

      set(newValue) {
        const nameStr = "".concat(this.id, ": ").concat(propName);

        for (const newPropName of deprecatedProps[propName]) {
          if (!hasOwnProperty(this, newPropName)) {
            this[newPropName] = newValue;
          }
        }

        _utils_log__WEBPACK_IMPORTED_MODULE_2__["default"].deprecated(nameStr, deprecatedProps[propName].join('/'))();
      }

    });
  }
}

function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
  const defaultValues = {};
  const descriptors = {};

  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      name,
      value
    } = propType;

    if (propType.async) {
      defaultValues[name] = value;
      descriptors[name] = getDescriptorForAsyncProp(name);
    }
  }

  defaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_DEFAULTS_SYMBOL] = defaultValues;
  defaultProps[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_ORIGINAL_SYMBOL] = {};
  Object.defineProperties(defaultProps, descriptors);
}

function getDescriptorForAsyncProp(name) {
  return {
    enumerable: true,

    set(newValue) {
      if (typeof newValue === 'string' || newValue instanceof Promise || (0,_utils_iterable_utils__WEBPACK_IMPORTED_MODULE_3__.isAsyncIterable)(newValue)) {
        this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_ORIGINAL_SYMBOL][name] = newValue;
      } else {
        this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_RESOLVED_SYMBOL][name] = newValue;
      }
    },

    get() {
      if (this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_RESOLVED_SYMBOL]) {
        if (name in this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_RESOLVED_SYMBOL]) {
          const value = this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_RESOLVED_SYMBOL][name];
          return value || this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_DEFAULTS_SYMBOL][name];
        }

        if (name in this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_ORIGINAL_SYMBOL]) {
          const state = this[_constants__WEBPACK_IMPORTED_MODULE_0__.COMPONENT_SYMBOL] && this[_constants__WEBPACK_IMPORTED_MODULE_0__.COMPONENT_SYMBOL].internalState;

          if (state && state.hasAsyncProp(name)) {
            return state.getAsyncProp(name) || this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_DEFAULTS_SYMBOL][name];
          }
        }
      }

      return this[_constants__WEBPACK_IMPORTED_MODULE_0__.ASYNC_DEFAULTS_SYMBOL][name];
    }

  };
}

function hasOwnProperty(object, prop) {
  return Object.prototype.hasOwnProperty.call(object, prop);
}

function getOwnProperty(object, prop) {
  return hasOwnProperty(object, prop) && object[prop];
}

function getComponentName(componentClass) {
  const componentName = componentClass.componentName;

  if (!componentName) {
    _utils_log__WEBPACK_IMPORTED_MODULE_2__["default"].warn("".concat(componentClass.name, ".componentName not specified"))();
  }

  return componentName || componentClass.name;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "parsePropTypes": () => (/* binding */ parsePropTypes)
/* harmony export */ });
/* harmony import */ var _utils_texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/texture */ "./node_modules/@deck.gl/core/dist/esm/utils/texture.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");


const TYPE_DEFINITIONS = {
  boolean: {
    validate(value, propType) {
      return true;
    },

    equal(value1, value2, propType) {
      return Boolean(value1) === Boolean(value2);
    }

  },
  number: {
    validate(value, propType) {
      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
    }

  },
  color: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value) && (value.length === 3 || value.length === 4);
    },

    equal(value1, value2, propType) {
      return (0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(value1, value2, 1);
    }

  },
  accessor: {
    validate(value, propType) {
      const valueType = getTypeOf(value);
      return valueType === 'function' || valueType === getTypeOf(propType.value);
    },

    equal(value1, value2, propType) {
      if (typeof value2 === 'function') {
        return true;
      }

      return (0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(value1, value2, 1);
    }

  },
  array: {
    validate(value, propType) {
      return propType.optional && !value || isArray(value);
    },

    equal(value1, value2, propType) {
      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? (0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(value1, value2, depth) : value1 === value2;
    }

  },
  object: {
    equal(value1, value2, propType) {
      if (propType.ignore) {
        return true;
      }

      const {
        compare
      } = propType;
      const depth = Number.isInteger(compare) ? compare : compare ? 1 : 0;
      return compare ? (0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_0__.deepEqual)(value1, value2, depth) : value1 === value2;
    }

  },
  function: {
    validate(value, propType) {
      return propType.optional && !value || typeof value === 'function';
    },

    equal(value1, value2, propType) {
      const shouldIgnore = !propType.compare && propType.ignore !== false;
      return shouldIgnore || value1 === value2;
    }

  },
  data: {
    transform: (value, propType, component) => {
      const {
        dataTransform
      } = component.props;
      return dataTransform && value ? dataTransform(value) : value;
    }
  },
  image: {
    transform: (value, propType, component) => {
      const context = component.context;

      if (!context || !context.gl) {
        return null;
      }

      return (0,_utils_texture__WEBPACK_IMPORTED_MODULE_1__.createTexture)(component.id, context.gl, value, { ...propType.parameters,
        ...component.props.textureParameters
      });
    },
    release: (value, propType, component) => {
      (0,_utils_texture__WEBPACK_IMPORTED_MODULE_1__.destroyTexture)(component.id, value);
    }
  }
};
function parsePropTypes(propDefs) {
  const propTypes = {};
  const defaultProps = {};
  const deprecatedProps = {};

  for (const [propName, propDef] of Object.entries(propDefs)) {
    const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;

    if (deprecated) {
      deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
    } else {
      const propType = parsePropType(propName, propDef);
      propTypes[propName] = propType;
      defaultProps[propName] = propType.value;
    }
  }

  return {
    propTypes,
    defaultProps,
    deprecatedProps
  };
}

function parsePropType(name, propDef) {
  switch (getTypeOf(propDef)) {
    case 'object':
      return normalizePropDefinition(name, propDef);

    case 'array':
      return normalizePropDefinition(name, {
        type: 'array',
        value: propDef,
        compare: false
      });

    case 'boolean':
      return normalizePropDefinition(name, {
        type: 'boolean',
        value: propDef
      });

    case 'number':
      return normalizePropDefinition(name, {
        type: 'number',
        value: propDef
      });

    case 'function':
      return normalizePropDefinition(name, {
        type: 'function',
        value: propDef,
        compare: true
      });

    default:
      return {
        name,
        type: 'unknown',
        value: propDef
      };
  }
}

function normalizePropDefinition(name, propDef) {
  if (!('type' in propDef)) {
    if (!('value' in propDef)) {
      return {
        name,
        type: 'object',
        value: propDef
      };
    }

    return {
      name,
      type: getTypeOf(propDef.value),
      ...propDef
    };
  }

  return {
    name,
    ...TYPE_DEFINITIONS[propDef.type],
    ...propDef
  };
}

function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}

function getTypeOf(value) {
  if (isArray(value)) {
    return 'array';
  }

  if (value === null) {
    return 'null';
  }

  return typeof value;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/lifecycle/props.js":
/*!****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/lifecycle/props.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compareProps": () => (/* binding */ compareProps),
/* harmony export */   "diffProps": () => (/* binding */ diffProps),
/* harmony export */   "validateProps": () => (/* binding */ validateProps)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js");

function validateProps(props) {
  const propTypes = props[_constants__WEBPACK_IMPORTED_MODULE_0__.PROP_TYPES_SYMBOL];

  for (const propName in propTypes) {
    const propType = propTypes[propName];
    const {
      validate
    } = propType;

    if (validate && !validate(props[propName], propType)) {
      throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
    }
  }
}
function diffProps(props, oldProps) {
  const propsChangedReason = compareProps({
    newProps: props,
    oldProps,
    propTypes: props[_constants__WEBPACK_IMPORTED_MODULE_0__.PROP_TYPES_SYMBOL],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  });
  const dataChangedReason = diffDataProps(props, oldProps);
  let updateTriggersChangedReason = false;

  if (!dataChangedReason) {
    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
  }

  return {
    dataChanged: dataChangedReason,
    propsChanged: propsChangedReason,
    updateTriggersChanged: updateTriggersChangedReason,
    extensionsChanged: diffExtensions(props, oldProps),
    transitionsChanged: diffTransitions(props, oldProps)
  };
}

function diffTransitions(props, oldProps) {
  if (!props.transitions) {
    return false;
  }

  const result = {};
  const propTypes = props[_constants__WEBPACK_IMPORTED_MODULE_0__.PROP_TYPES_SYMBOL];
  let changed = false;

  for (const key in props.transitions) {
    const propType = propTypes[key];
    const type = propType && propType.type;
    const isTransitionable = type === 'number' || type === 'color' || type === 'array';

    if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
      result[key] = true;
      changed = true;
    }
  }

  return changed ? result : false;
}

function compareProps({
  newProps,
  oldProps,
  ignoreProps = {},
  propTypes = {},
  triggerName = 'props'
}) {
  if (oldProps === newProps) {
    return false;
  }

  if (typeof newProps !== 'object' || newProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  if (typeof oldProps !== 'object' || oldProps === null) {
    return "".concat(triggerName, " changed shallowly");
  }

  for (const key of Object.keys(newProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in oldProps)) {
        return "".concat(triggerName, ".").concat(key, " added");
      }

      const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);

      if (changed) {
        return "".concat(triggerName, ".").concat(key, " ").concat(changed);
      }
    }
  }

  for (const key of Object.keys(oldProps)) {
    if (!(key in ignoreProps)) {
      if (!(key in newProps)) {
        return "".concat(triggerName, ".").concat(key, " dropped");
      }

      if (!Object.hasOwnProperty.call(newProps, key)) {
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes[key]);

        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
  }

  return false;
}

function comparePropValues(newProp, oldProp, propType) {
  let equal = propType && propType.equal;

  if (equal && !equal(newProp, oldProp, propType)) {
    return 'changed deeply';
  }

  if (!equal) {
    equal = newProp && oldProp && newProp.equals;

    if (equal && !equal.call(newProp, oldProp)) {
      return 'changed deeply';
    }
  }

  if (!equal && oldProp !== newProp) {
    return 'changed shallowly';
  }

  return null;
}

function diffDataProps(props, oldProps) {
  if (oldProps === null) {
    return 'oldProps is null, initial diff';
  }

  let dataChanged = false;
  const {
    dataComparator,
    _dataDiff
  } = props;

  if (dataComparator) {
    if (!dataComparator(props.data, oldProps.data)) {
      dataChanged = 'Data comparator detected a change';
    }
  } else if (props.data !== oldProps.data) {
    dataChanged = 'A new data container was supplied';
  }

  if (dataChanged && _dataDiff) {
    dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
  }

  return dataChanged;
}

function diffUpdateTriggers(props, oldProps) {
  if (oldProps === null) {
    return {
      all: true
    };
  }

  if ('all' in props.updateTriggers) {
    const diffReason = diffUpdateTrigger(props, oldProps, 'all');

    if (diffReason) {
      return {
        all: true
      };
    }
  }

  const reason = {};
  let changed = false;

  for (const triggerName in props.updateTriggers) {
    if (triggerName !== 'all') {
      const diffReason = diffUpdateTrigger(props, oldProps, triggerName);

      if (diffReason) {
        reason[triggerName] = true;
        changed = true;
      }
    }
  }

  return changed ? reason : false;
}

function diffExtensions(props, oldProps) {
  if (oldProps === null) {
    return true;
  }

  const oldExtensions = oldProps.extensions;
  const {
    extensions
  } = props;

  if (extensions === oldExtensions) {
    return false;
  }

  if (!oldExtensions || !extensions) {
    return true;
  }

  if (extensions.length !== oldExtensions.length) {
    return true;
  }

  for (let i = 0; i < extensions.length; i++) {
    if (!extensions[i].equals(oldExtensions[i])) {
      return true;
    }
  }

  return false;
}

function diffUpdateTrigger(props, oldProps, triggerName) {
  let newTriggers = props.updateTriggers[triggerName];
  newTriggers = newTriggers === undefined || newTriggers === null ? {} : newTriggers;
  let oldTriggers = oldProps.updateTriggers[triggerName];
  oldTriggers = oldTriggers === undefined || oldTriggers === null ? {} : oldTriggers;
  const diffReason = compareProps({
    oldProps: oldTriggers,
    newProps: newTriggers,
    triggerName
  });
  return diffReason;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DrawLayersPass)
/* harmony export */ });
/* harmony import */ var _layers_pass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js");

class DrawLayersPass extends _layers_pass__WEBPACK_IMPORTED_MODULE_0__["default"] {
  shouldDrawLayer(layer) {
    const {
      operation
    } = layer.props;
    return operation.includes('draw') || operation.includes('terrain');
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LayersPass),
/* harmony export */   "layerIndexResolver": () => (/* binding */ layerIndexResolver)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pass */ "./node_modules/@deck.gl/core/dist/esm/passes/pass.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/clear.js");



class LayersPass extends _pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_lastRenderIndex", -1);
  }

  render(options) {
    const gl = this.gl;
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.setParameters)(gl, {
      framebuffer: options.target
    });
    return this._drawLayers(options);
  }

  _drawLayers(options) {
    const {
      target,
      moduleParameters,
      viewports,
      views,
      onViewportActive,
      clearStack = true,
      clearCanvas = true
    } = options;
    options.pass = options.pass || 'unknown';
    const gl = this.gl;

    if (clearCanvas) {
      clearGLCanvas(gl, target);
    }

    if (clearStack) {
      this._lastRenderIndex = -1;
    }

    const renderStats = [];

    for (const viewport of viewports) {
      const view = views && views[viewport.id];
      onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);

      const drawLayerParams = this._getDrawLayerParams(viewport, options);

      const subViewports = viewport.subViewports || [viewport];

      for (const subViewport of subViewports) {
        const stats = this._drawLayersInViewport(gl, {
          target,
          moduleParameters,
          viewport: subViewport,
          view,
          pass: options.pass,
          layers: options.layers
        }, drawLayerParams);

        renderStats.push(stats);
      }
    }

    return renderStats;
  }

  _getDrawLayerParams(viewport, {
    layers,
    pass,
    isPicking = false,
    layerFilter,
    cullRect,
    effects,
    moduleParameters
  }, evaluateShouldDrawOnly = false) {
    const drawLayerParams = [];
    const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
    const drawContext = {
      layer: layers[0],
      viewport,
      isPicking,
      renderPass: pass,
      cullRect
    };
    const layerFilterCache = {};

    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];

      const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);

      const layerParam = {
        shouldDrawLayer
      };

      if (shouldDrawLayer && !evaluateShouldDrawOnly) {
        layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
        layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass, moduleParameters);
        layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
      }

      drawLayerParams[layerIndex] = layerParam;
    }

    return drawLayerParams;
  }

  _drawLayersInViewport(gl, {
    layers,
    moduleParameters: globalModuleParameters,
    pass,
    target,
    viewport,
    view
  }, drawLayerParams) {
    const glViewport = getGLViewport(gl, {
      moduleParameters: globalModuleParameters,
      target,
      viewport
    });

    if (view && view.props.clear) {
      const clearOpts = view.props.clear === true ? {
        color: true,
        depth: true
      } : view.props.clear;
      (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.withParameters)(gl, {
        scissorTest: true,
        scissor: glViewport
      }, () => (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_3__.clear)(gl, clearOpts));
    }

    const renderStatus = {
      totalCount: layers.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.setParameters)(gl, {
      viewport: glViewport
    });

    for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
      const layer = layers[layerIndex];
      const {
        shouldDrawLayer,
        layerRenderIndex,
        moduleParameters,
        layerParameters
      } = drawLayerParams[layerIndex];

      if (shouldDrawLayer && layer.props.pickable) {
        renderStatus.pickableCount++;
      }

      if (layer.isComposite) {
        renderStatus.compositeCount++;
      } else if (shouldDrawLayer) {
        renderStatus.visibleCount++;
        this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
        moduleParameters.viewport = viewport;

        try {
          layer._drawLayer({
            moduleParameters,
            uniforms: {
              layerIndex: layerRenderIndex
            },
            parameters: layerParameters
          });
        } catch (err) {
          layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass));
        }
      }
    }

    return renderStatus;
  }

  shouldDrawLayer(layer) {
    return true;
  }

  getModuleParameters(layer, effects) {
    return null;
  }

  getLayerParameters(layer, layerIndex, viewport) {
    return layer.props.parameters;
  }

  _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
    const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);

    if (!shouldDrawLayer) {
      return false;
    }

    drawContext.layer = layer;
    let parent = layer.parent;

    while (parent) {
      if (!parent.props.visible || !parent.filterSubLayer(drawContext)) {
        return false;
      }

      drawContext.layer = parent;
      parent = parent.parent;
    }

    if (layerFilter) {
      const rootLayerId = drawContext.layer.id;

      if (!(rootLayerId in layerFilterCache)) {
        layerFilterCache[rootLayerId] = layerFilter(drawContext);
      }

      if (!layerFilterCache[rootLayerId]) {
        return false;
      }
    }

    layer.activateViewport(drawContext.viewport);
    return true;
  }

  _getModuleParameters(layer, effects, pass, overrides) {
    var _layer$internalState;

    const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
      autoWrapLongitude: layer.wrapLongitude,
      viewport: layer.context.viewport,
      mousePosition: layer.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.cssToDeviceRatio)(this.gl)
    });

    if (effects) {
      for (const effect of effects) {
        var _effect$getModulePara;

        Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
      }
    }

    return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
  }

}
function layerIndexResolver(startIndex = 0, layerIndices = {}) {
  const resolvers = {};

  const resolveLayerIndex = (layer, isDrawn) => {
    const indexOverride = layer.props._offset;
    const layerId = layer.id;
    const parentId = layer.parent && layer.parent.id;
    let index;

    if (parentId && !(parentId in layerIndices)) {
      resolveLayerIndex(layer.parent, false);
    }

    if (parentId in resolvers) {
      const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
      index = resolver(layer, isDrawn);
      resolvers[layerId] = resolver;
    } else if (Number.isFinite(indexOverride)) {
      index = indexOverride + (layerIndices[parentId] || 0);
      resolvers[layerId] = null;
    } else {
      index = startIndex;
    }

    if (isDrawn && index >= startIndex) {
      startIndex = index + 1;
    }

    layerIndices[layerId] = index;
    return index;
  };

  return resolveLayerIndex;
}

function getGLViewport(gl, {
  moduleParameters,
  target,
  viewport
}) {
  const useTarget = target && target.id !== 'default-framebuffer';
  const pixelRatio = moduleParameters && moduleParameters.devicePixelRatio || (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.cssToDeviceRatio)(gl);
  const height = useTarget ? target.height : gl.drawingBufferHeight;
  const dimensions = viewport;
  return [dimensions.x * pixelRatio, height - (dimensions.y + dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
}

function clearGLCanvas(gl, targetFramebuffer) {
  const width = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
  const height = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
  (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.setParameters)(gl, {
    viewport: [0, 0, width, height]
  });
  gl.clear(16384 | 256);
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/passes/pass.js":
/*!************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/passes/pass.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Pass)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

class Pass {
  constructor(gl, props = {
    id: 'pass'
  }) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    const {
      id
    } = props;
    this.id = id;
    this.gl = gl;
    this.props = { ...props
    };
  }

  setProps(props) {
    Object.assign(this.props, props);
  }

  render(params) {}

  cleanup() {}

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PickLayersPass)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _layers_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");




const PICKING_PARAMETERS = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
class PickLayersPass extends _layers_pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(...args) {
    super(...args);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pickZ", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_colorEncoderState", null);
  }

  render(props) {
    if ('pickingFBO' in props) {
      return this._drawPickingBuffer(props);
    }

    return super.render(props);
  }

  _drawPickingBuffer({
    layers,
    layerFilter,
    views,
    viewports,
    onViewportActive,
    pickingFBO,
    deviceRect: {
      x,
      y,
      width,
      height
    },
    cullRect,
    effects,
    pass = 'picking',
    pickZ,
    moduleParameters
  }) {
    const gl = this.gl;
    this.pickZ = pickZ;

    const colorEncoderState = this._resetColorEncoder(pickZ);

    const renderStatus = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__.withParameters)(gl, {
      scissorTest: true,
      scissor: [x, y, width, height],
      clearColor: [0, 0, 0, 0],
      depthMask: true,
      depthTest: true,
      depthRange: [0, 1],
      colorMask: [true, true, true, true],
      ...PICKING_PARAMETERS,
      blend: !pickZ
    }, () => super.render({
      target: pickingFBO,
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      cullRect,
      effects: effects === null || effects === void 0 ? void 0 : effects.filter(e => e.useInPicking),
      pass,
      isPicking: true,
      moduleParameters
    }));
    this._colorEncoderState = null;
    const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
    return {
      decodePickingColor,
      stats: renderStatus
    };
  }

  shouldDrawLayer(layer) {
    const {
      pickable,
      operation
    } = layer.props;
    return pickable && operation.includes('draw') || operation.includes('terrain');
  }

  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }

  getLayerParameters(layer, layerIndex, viewport) {
    const pickParameters = { ...layer.props.parameters
    };
    const {
      pickable,
      operation
    } = layer.props;

    if (!this._colorEncoderState) {
      pickParameters.blend = false;
    } else if (pickable && operation.includes('draw')) {
      Object.assign(pickParameters, PICKING_PARAMETERS);
      pickParameters.blend = true;
      pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
    }

    if (operation.includes('terrain')) {
      pickParameters.blend = false;
    }

    return pickParameters;
  }

  _resetColorEncoder(pickZ) {
    this._colorEncoderState = pickZ ? null : {
      byLayer: new Map(),
      byAlpha: []
    };
    return this._colorEncoderState;
  }

}

function encodeColor(encoded, layer, viewport) {
  const {
    byLayer,
    byAlpha
  } = encoded;
  let a;
  let entry = byLayer.get(layer);

  if (entry) {
    entry.viewports.push(viewport);
    a = entry.a;
  } else {
    a = byLayer.size + 1;

    if (a <= 255) {
      entry = {
        a,
        layer,
        viewports: [viewport]
      };
      byLayer.set(layer, entry);
      byAlpha[a] = entry;
    } else {
      _utils_log__WEBPACK_IMPORTED_MODULE_3__["default"].warn('Too many pickable layers, only picking the first 255')();
      a = 0;
    }
  }

  return [0, 0, 0, a / 255];
}

function decodeColor(encoded, pickedColor) {
  const entry = encoded.byAlpha[pickedColor[3]];
  return entry && {
    pickedLayer: entry.layer,
    pickedViewports: entry.viewports,
    pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
  };
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/passes/screen-pass.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ScreenPass)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/clear.js");
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pass */ "./node_modules/@deck.gl/core/dist/esm/passes/pass.js");



class ScreenPass extends _pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props) {
    super(gl, props);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "model", void 0);

    const {
      module,
      fs,
      id
    } = props;
    this.model = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"](gl, {
      id,
      fs,
      modules: [module]
    });
  }

  render(params) {
    const gl = this.gl;
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_3__.setParameters)(gl, {
      viewport: [0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight]
    });
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_3__.withParameters)(gl, {
      framebuffer: params.outputBuffer,
      clearColor: [0, 0, 0, 0]
    }, () => this._renderPass(gl, params));
  }

  delete() {
    this.model.delete();
    this.model = null;
  }

  _renderPass(gl, options) {
    const {
      inputBuffer
    } = options;
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.clear)(gl, {
      color: true
    });
    this.model.draw({
      moduleSettings: options.moduleSettings,
      uniforms: {
        texture: inputBuffer,
        texSize: [inputBuffer.width, inputBuffer.height]
      },
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ShadowPass)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _layers_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layers-pass */ "./node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");



class ShadowPass extends _layers_pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props) {
    super(gl, props);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "shadowMap", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "depthBuffer", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "fbo", void 0);

    this.shadowMap = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"](gl, {
      width: 1,
      height: 1,
      parameters: {
        [10241]: 9729,
        [10240]: 9729,
        [10242]: 33071,
        [10243]: 33071
      }
    });
    this.depthBuffer = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, {
      format: 33189,
      width: 1,
      height: 1
    });
    this.fbo = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__["default"](gl, {
      id: 'shadowmap',
      width: 1,
      height: 1,
      attachments: {
        [36064]: this.shadowMap,
        [36096]: this.depthBuffer
      }
    });
  }

  render(params) {
    const target = this.fbo;
    (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_5__.withParameters)(this.gl, {
      depthRange: [0, 1],
      depthTest: true,
      blend: false,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const viewport = params.viewports[0];
      const pixelRatio = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_5__.cssToDeviceRatio)(this.gl);
      const width = viewport.width * pixelRatio;
      const height = viewport.height * pixelRatio;

      if (width !== target.width || height !== target.height) {
        target.resize({
          width,
          height
        });
      }

      super.render({ ...params,
        target,
        pass: 'shadow'
      });
    });
  }

  shouldDrawLayer(layer) {
    return layer.props.shadowEnabled !== false;
  }

  getModuleParameters() {
    return {
      drawToShadowMap: true
    };
  }

  delete() {
    if (this.fbo) {
      this.fbo.delete();
      this.fbo = null;
    }

    if (this.shadowMap) {
      this.shadowMap.delete();
      this.shadowMap = null;
    }

    if (this.depthBuffer) {
      this.depthBuffer.delete();
      this.depthBuffer = null;
    }
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProgramManager": () => (/* binding */ createProgramManager),
/* harmony export */   "gouraudLighting": () => (/* reexport safe */ _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.gouraudLighting),
/* harmony export */   "phongLighting": () => (/* reexport safe */ _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__.phongLighting),
/* harmony export */   "picking": () => (/* reexport safe */ _picking_picking__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "project": () => (/* reexport safe */ _project_project__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "project32": () => (/* reexport safe */ _project32_project32__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "shadow": () => (/* reexport safe */ _shadow_shadow__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js");
/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./project/project */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js");
/* harmony import */ var _project32_project32__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./project32/project32 */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js");
/* harmony import */ var _shadow_shadow__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shadow/shadow */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js");
/* harmony import */ var _picking_picking__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./picking/picking */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js");






const DEFAULT_MODULES = [_project_project__WEBPACK_IMPORTED_MODULE_0__["default"]];
const SHADER_HOOKS = ['vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)', 'vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)', 'vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)', 'fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)'];
function createProgramManager(gl) {
  const programManager = _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["default"].getDefaultProgramManager(gl);

  for (const shaderModule of DEFAULT_MODULES) {
    programManager.addDefaultModule(shaderModule);
  }

  for (const shaderHook of SHADER_HOOKS) {
    programManager.addShaderHook(shaderHook);
  }

  return programManager;
}



/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const defines = '#define SMOOTH_EDGE_RADIUS 0.5';
const vs = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
const fs = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'geometry',
  vs,
  fs
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
    'vs:DECKGL_FILTER_COLOR': "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
    'fs:#decl': "\nuniform bool picking_uAttribute;\n  ",
    'fs:DECKGL_FILTER_COLOR': {
      order: 99,
      injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
    }
  },
  ..._luma_gl_core__WEBPACK_IMPORTED_MODULE_0__.picking
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getWorldPosition": () => (/* binding */ getWorldPosition),
/* harmony export */   "projectPosition": () => (/* binding */ projectPosition)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");
/* harmony import */ var _viewport_uniforms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./viewport-uniforms */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js");
/* harmony import */ var _viewports_web_mercator_viewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../viewports/web-mercator-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/vec4 */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");






const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];

function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
  const p = viewport.projectPosition(lngLatZ);

  if (offsetMode && viewport instanceof _viewports_web_mercator_viewport__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    const [longitude, latitude, z = 0] = lngLatZ;
    const distanceScales = viewport.getDistanceScales([longitude, latitude]);
    p[2] = z * distanceScales.unitsPerMeter[2];
  }

  return p;
}

function normalizeParameters(opts) {
  const {
    viewport,
    modelMatrix,
    coordinateOrigin
  } = opts;
  let {
    coordinateSystem,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = opts;

  if (coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.LNGLAT : _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.CARTESIAN;
  }

  if (fromCoordinateSystem === undefined) {
    fromCoordinateSystem = coordinateSystem;
  }

  if (fromCoordinateOrigin === undefined) {
    fromCoordinateOrigin = coordinateOrigin;
  }

  return {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  };
}

function getWorldPosition(position, {
  viewport,
  modelMatrix,
  coordinateSystem,
  coordinateOrigin,
  offsetMode
}) {
  let [x, y, z = 0] = position;

  if (modelMatrix) {
    [x, y, z] = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_3__.transformMat4([], [x, y, z, 1.0], modelMatrix);
  }

  switch (coordinateSystem) {
    case _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.LNGLAT:
      return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);

    case _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
      return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);

    case _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.METER_OFFSETS:
      return lngLatZToWorldPosition((0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__.addMetersToLngLat)(coordinateOrigin, [x, y, z]), viewport, offsetMode);

    case _lib_constants__WEBPACK_IMPORTED_MODULE_2__.COORDINATE_SYSTEM.CARTESIAN:
    default:
      return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
  }
}
function projectPosition(position, params) {
  const {
    viewport,
    coordinateSystem,
    coordinateOrigin,
    modelMatrix,
    fromCoordinateSystem,
    fromCoordinateOrigin
  } = normalizeParameters(params);
  const {
    autoOffset = true
  } = params;
  const {
    geospatialOrigin = DEFAULT_COORDINATE_ORIGIN,
    shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    offsetMode = false
  } = autoOffset ? (0,_viewport_uniforms__WEBPACK_IMPORTED_MODULE_4__.getOffsetOrigin)(viewport, coordinateSystem, coordinateOrigin) : {};
  const worldPosition = getWorldPosition(position, {
    viewport,
    modelMatrix,
    coordinateSystem: fromCoordinateSystem,
    coordinateOrigin: fromCoordinateOrigin,
    offsetMode
  });

  if (offsetMode) {
    const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__.sub(worldPosition, worldPosition, positionCommonSpace);
  }

  return worldPosition;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");

const COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.COORDINATE_SYSTEM).map(key => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.COORDINATE_SYSTEM[key], ";")).join('');
const PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.PROJECTION_MODE).map(key => "const int PROJECTION_MODE_".concat(key, " = ").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.PROJECTION_MODE[key], ";")).join('');
const UNIT_GLSL_CONSTANTS = Object.keys(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.UNIT).map(key => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.UNIT[key], ";")).join('');
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n"));


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js");
/* harmony import */ var _misc_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../misc/geometry */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js");
/* harmony import */ var _project_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./project.glsl */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js");
/* harmony import */ var _viewport_uniforms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./viewport-uniforms */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js");




const INITIAL_MODULE_OPTIONS = {};

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if ('viewport' in opts) {
    return (0,_viewport_uniforms__WEBPACK_IMPORTED_MODULE_0__.getUniformsFromViewport)(opts);
  }

  return {};
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'project',
  dependencies: [_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__.fp32, _misc_geometry__WEBPACK_IMPORTED_MODULE_2__["default"]],
  vs: _project_glsl__WEBPACK_IMPORTED_MODULE_3__["default"],
  getUniforms
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOffsetOrigin": () => (/* binding */ getOffsetOrigin),
/* harmony export */   "getUniformsFromViewport": () => (/* binding */ getUniformsFromViewport)
/* harmony export */ });
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/mat4 */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix/vec4 */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");
/* harmony import */ var _utils_memoize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/memoize */ "./node_modules/@deck.gl/core/dist/esm/utils/memoize.js");




const ZERO_VECTOR = [0, 0, 0, 0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
const DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
const DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
const getMemoizedViewportUniforms = (0,_utils_memoize__WEBPACK_IMPORTED_MODULE_0__["default"])(calculateViewportUniforms);
function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
  if (coordinateOrigin.length < 3) {
    coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
  }

  let shaderCoordinateOrigin = coordinateOrigin;
  let geospatialOrigin;
  let offsetMode = true;

  if (coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.METER_OFFSETS) {
    geospatialOrigin = coordinateOrigin;
  } else {
    geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
  }

  switch (viewport.projectionMode) {
    case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.PROJECTION_MODE.WEB_MERCATOR:
      if (coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.LNGLAT || coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.CARTESIAN) {
        geospatialOrigin = [0, 0, 0];
        offsetMode = false;
      }

      break;

    case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
      if (coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.LNGLAT) {
        shaderCoordinateOrigin = geospatialOrigin;
      } else if (coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.CARTESIAN) {
        shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
        geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
        shaderCoordinateOrigin[0] -= coordinateOrigin[0];
        shaderCoordinateOrigin[1] -= coordinateOrigin[1];
        shaderCoordinateOrigin[2] -= coordinateOrigin[2];
      }

      break;

    case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.PROJECTION_MODE.IDENTITY:
      shaderCoordinateOrigin = viewport.position.map(Math.fround);
      shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
      break;

    case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.PROJECTION_MODE.GLOBE:
      offsetMode = false;
      geospatialOrigin = null;
      break;

    default:
      offsetMode = false;
  }

  return {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  };
}

function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
  const {
    viewMatrixUncentered,
    projectionMatrix
  } = viewport;
  let {
    viewMatrix,
    viewProjectionMatrix
  } = viewport;
  let projectionCenter = ZERO_VECTOR;
  let originCommon = ZERO_VECTOR;
  let cameraPosCommon = viewport.cameraPosition;
  const {
    geospatialOrigin,
    shaderCoordinateOrigin,
    offsetMode
  } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);

  if (offsetMode) {
    originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
    cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
    originCommon[3] = 1;
    projectionCenter = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__.transformMat4([], originCommon, viewProjectionMatrix);
    viewMatrix = viewMatrixUncentered || viewMatrix;
    viewProjectionMatrix = gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__.multiply([], projectionMatrix, viewMatrix);
    viewProjectionMatrix = gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_3__.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
  }

  return {
    viewMatrix,
    viewProjectionMatrix,
    projectionCenter,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  };
}

function getUniformsFromViewport({
  viewport,
  devicePixelRatio = 1,
  modelMatrix = null,
  coordinateSystem = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.DEFAULT,
  coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
  autoWrapLongitude = false
}) {
  if (coordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.DEFAULT) {
    coordinateSystem = viewport.isGeospatial ? _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.LNGLAT : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.CARTESIAN;
  }

  const uniforms = getMemoizedViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  });
  uniforms.project_uWrapLongitude = autoWrapLongitude;
  uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX;
  return uniforms;
}

function calculateViewportUniforms({
  viewport,
  devicePixelRatio,
  coordinateSystem,
  coordinateOrigin
}) {
  const {
    projectionCenter,
    viewProjectionMatrix,
    originCommon,
    cameraPosCommon,
    shaderCoordinateOrigin,
    geospatialOrigin
  } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
  const distanceScales = viewport.getDistanceScales();
  const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
  const focalDistance = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__.transformMat4([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
  const uniforms = {
    project_uCoordinateSystem: coordinateSystem,
    project_uProjectionMode: viewport.projectionMode,
    project_uCoordinateOrigin: shaderCoordinateOrigin,
    project_uCommonOrigin: originCommon.slice(0, 3),
    project_uCenter: projectionCenter,
    project_uPseudoMeters: Boolean(viewport._pseudoMeters),
    project_uViewportSize: viewportSize,
    project_uDevicePixelRatio: devicePixelRatio,
    project_uFocalDistance: focalDistance,
    project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
    project_uScale: viewport.scale,
    project_uWrapLongitude: false,
    project_uViewProjectionMatrix: viewProjectionMatrix,
    project_uModelMatrix: IDENTITY_MATRIX,
    project_uCameraPosition: cameraPosCommon
  };

  if (geospatialOrigin) {
    const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);

    switch (coordinateSystem) {
      case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.METER_OFFSETS:
        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
        break;

      case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.LNGLAT:
      case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        if (!viewport._pseudoMeters) {
          uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
        }

        uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
        uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
        break;

      case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.COORDINATE_SYSTEM.CARTESIAN:
        uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
        uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
        break;

      default:
        break;
    }
  }

  return uniforms;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../project/project */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js");

const vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'project32',
  dependencies: [_project_project__WEBPACK_IMPORTED_MODULE_0__["default"]],
  vs
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");
/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../project/project */ "./node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var _utils_memoize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/memoize */ "./node_modules/@deck.gl/core/dist/esm/utils/memoize.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");





const vs = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
const fs = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
const getMemoizedViewportCenterPosition = (0,_utils_memoize__WEBPACK_IMPORTED_MODULE_1__["default"])(getViewportCenterPosition);
const getMemoizedViewProjectionMatrices = (0,_utils_memoize__WEBPACK_IMPORTED_MODULE_1__["default"])(getViewProjectionMatrices);
const DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];
const VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];

function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
  const [x, y, z] = xyz;
  const coord = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__.pixelsToWorld)([x, y, z], pixelUnprojectionMatrix);

  if (Number.isFinite(z)) {
    return coord;
  }

  return [coord[0], coord[1], 0];
}

function getViewportCenterPosition({
  viewport,
  center
}) {
  return new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"](viewport.viewProjectionMatrix).invert().transform(center);
}

function getViewProjectionMatrices({
  viewport,
  shadowMatrices
}) {
  const projectionMatrices = [];
  const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
  const farZ = viewport.isGeospatial ? undefined : 1;
  const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map(pixel => screenToCommonSpace(pixel, pixelUnprojectionMatrix));

  for (const shadowMatrix of shadowMatrices) {
    const viewMatrix = shadowMatrix.clone().translate(new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](viewport.center).negate());
    const positions = corners.map(corner => viewMatrix.transform(corner));
    const projectionMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"]().ortho({
      left: Math.min(...positions.map(position => position[0])),
      right: Math.max(...positions.map(position => position[0])),
      bottom: Math.min(...positions.map(position => position[1])),
      top: Math.max(...positions.map(position => position[1])),
      near: Math.min(...positions.map(position => -position[2])),
      far: Math.max(...positions.map(position => -position[2]))
    });
    projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
  }

  return projectionMatrices;
}

function createShadowUniforms(opts, context) {
  const {
    shadowEnabled = true
  } = opts;

  if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
    return {
      shadow_uDrawShadowMap: false,
      shadow_uUseShadowMap: false
    };
  }

  const uniforms = {
    shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
    shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
    shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
    shadow_uLightId: opts.shadowLightId || 0,
    shadow_uLightCount: opts.shadowMatrices.length
  };
  const center = getMemoizedViewportCenterPosition({
    viewport: opts.viewport,
    center: context.project_uCenter
  });
  const projectCenters = [];
  const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
    shadowMatrices: opts.shadowMatrices,
    viewport: opts.viewport
  }).slice();

  for (let i = 0; i < opts.shadowMatrices.length; i++) {
    const viewProjectionMatrix = viewProjectionMatrices[i];
    const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](opts.viewport.center).negate());

    if (context.project_uCoordinateSystem === _lib_constants__WEBPACK_IMPORTED_MODULE_4__.COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === _lib_constants__WEBPACK_IMPORTED_MODULE_4__.PROJECTION_MODE.WEB_MERCATOR) {
      viewProjectionMatrices[i] = viewProjectionMatrixCentered;
      projectCenters[i] = center;
    } else {
      viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX);
      projectCenters[i] = viewProjectionMatrixCentered.transform(center);
    }
  }

  for (let i = 0; i < viewProjectionMatrices.length; i++) {
    uniforms["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
    uniforms["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];

    if (opts.shadowMaps && opts.shadowMaps.length > 0) {
      uniforms["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
    } else {
      uniforms["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
    }
  }

  return uniforms;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'shadow',
  dependencies: [_project_project__WEBPACK_IMPORTED_MODULE_5__["default"]],
  vs,
  fs,
  inject: {
    'vs:DECKGL_FILTER_GL_POSITION': "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
    'fs:DECKGL_FILTER_COLOR': "\n    color = shadow_filterShadowColor(color);\n    "
  },
  getUniforms: (opts = {}, context = {}) => {
    if ('viewport' in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
      return createShadowUniforms(opts, context);
    }

    return {};
  }
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CPUInterpolationTransition)
/* harmony export */ });
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition.js");


class CPUInterpolationTransition extends _transition__WEBPACK_IMPORTED_MODULE_0__["default"] {
  get value() {
    return this._value;
  }

  _onUpdate() {
    const {
      time,
      settings: {
        fromValue,
        toValue,
        duration,
        easing
      }
    } = this;
    const t = easing(time / duration);
    this._value = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.lerp)(fromValue, toValue, t);
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ CPUSpringTransition)
/* harmony export */ });
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition.js");

const EPSILON = 1e-5;

function updateSpringElement(prev, cur, dest, damping, stiffness) {
  const velocity = cur - prev;
  const delta = dest - cur;
  const spring = delta * stiffness;
  const damper = -velocity * damping;
  return spring + damper + velocity + cur;
}

function updateSpring(prev, cur, dest, damping, stiffness) {
  if (Array.isArray(dest)) {
    const next = [];

    for (let i = 0; i < dest.length; i++) {
      next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
    }

    return next;
  }

  return updateSpringElement(prev, cur, dest, damping, stiffness);
}

function distance(value1, value2) {
  if (Array.isArray(value1)) {
    let distanceSquare = 0;

    for (let i = 0; i < value1.length; i++) {
      const d = value1[i] - value2[i];
      distanceSquare += d * d;
    }

    return Math.sqrt(distanceSquare);
  }

  return Math.abs(value1 - value2);
}

class CPUSpringTransition extends _transition__WEBPACK_IMPORTED_MODULE_0__["default"] {
  get value() {
    return this._currValue;
  }

  _onUpdate() {
    const {
      fromValue,
      toValue,
      damping,
      stiffness
    } = this.settings;
    const {
      _prevValue = fromValue,
      _currValue = fromValue
    } = this;
    let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
    const delta = distance(nextValue, toValue);
    const velocity = distance(nextValue, _currValue);

    if (delta < EPSILON && velocity < EPSILON) {
      nextValue = toValue;
      this.end();
    }

    this._prevValue = _currValue;
    this._currValue = nextValue;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/fly-to-interpolator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FlyToInterpolator)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _transition_interpolator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transition-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");




const LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];
const DEFAULT_OPTS = {
  speed: 1.2,
  curve: 1.414
};
class FlyToInterpolator extends _transition_interpolator__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(opts = {}) {
    super({
      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "opts", void 0);

    this.opts = { ...DEFAULT_OPTS,
      ...opts
    };
  }

  interpolateProps(startProps, endProps, t) {
    const viewport = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.flyToViewport)(startProps, endProps, t, this.opts);

    for (const key of LINEARLY_INTERPOLATED_PROPS) {
      viewport[key] = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_3__.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }

    return viewport;
  }

  getDuration(startProps, endProps) {
    let {
      transitionDuration
    } = endProps;

    if (transitionDuration === 'auto') {
      transitionDuration = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getFlyToDuration)(startProps, endProps, this.opts);
    }

    return transitionDuration;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GPUInterpolationTransition)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/transform/transform.js");
/* harmony import */ var _lib_attribute_attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/attribute/attribute */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js");
/* harmony import */ var _lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/attribute/attribute-transition-utils */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition.js");





class GPUInterpolationTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", 'interpolation');

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attributeInTransition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "settings", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attribute", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentStartIndices", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentLength", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transform", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "buffers", void 0);

    this.gl = gl;
    this.transition = new _transition__WEBPACK_IMPORTED_MODULE_1__["default"](timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _lib_attribute_attribute__WEBPACK_IMPORTED_MODULE_2__["default"](gl, attribute.settings);
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.transform = getTransform(gl, attribute);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, bufferOpts), new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, bufferOpts)];
  }

  get inProgress() {
    return this.transition.inProgress;
  }

  start(transitionSettings, numInstances) {
    if (transitionSettings.duration <= 0) {
      this.transition.cancel();
      return;
    }

    this.settings = transitionSettings;
    const {
      gl,
      buffers,
      attribute
    } = this;
    (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.cycleBuffers)(buffers);
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };

    for (const buffer of buffers) {
      (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }

    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start(transitionSettings);
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aFrom: buffers[0],
        aTo: (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.getSourceBufferAttribute)(gl, attribute)
      },
      feedbackBuffers: {
        vCurrent: buffers[1]
      }
    });
  }

  update() {
    const updated = this.transition.update();

    if (updated) {
      const {
        duration,
        easing
      } = this.settings;
      const {
        time
      } = this.transition;
      let t = time / duration;

      if (easing) {
        t = easing(t);
      }

      this.transform.run({
        uniforms: {
          time: t
        }
      });
    }

    return updated;
  }

  cancel() {
    this.transition.cancel();
    this.transform.delete();

    for (const buffer of this.buffers) {
      buffer.delete();
    }

    this.buffers.length = 0;
  }

}
const vs = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";

function getTransform(gl, attribute) {
  const attributeType = (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.getAttributeTypeFromSize)(attribute.size);
  return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__["default"](gl, {
    vs,
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vCurrent']
  });
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GPUSpringTransition)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/engine/dist/esm/transform/transform.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/attribute/attribute-transition-utils */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js");
/* harmony import */ var _lib_attribute_attribute__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/attribute/attribute */ "./node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition.js");





class GPUSpringTransition {
  constructor({
    gl,
    attribute,
    timeline
  }) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "gl", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "type", 'spring');

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attributeInTransition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "settings", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attribute", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentStartIndices", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "currentLength", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "texture", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "framebuffer", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "transform", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "buffers", void 0);

    this.gl = gl;
    this.type = 'spring';
    this.transition = new _transition__WEBPACK_IMPORTED_MODULE_1__["default"](timeline);
    this.attribute = attribute;
    this.attributeInTransition = new _lib_attribute_attribute__WEBPACK_IMPORTED_MODULE_2__["default"](gl, { ...attribute.settings,
      normalized: false
    });
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = 0;
    this.texture = getTexture(gl);
    this.framebuffer = getFramebuffer(gl, this.texture);
    this.transform = getTransform(gl, attribute, this.framebuffer);
    const bufferOpts = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, bufferOpts), new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, bufferOpts), new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](gl, bufferOpts)];
  }

  get inProgress() {
    return this.transition.inProgress;
  }

  start(transitionSettings, numInstances) {
    const {
      gl,
      buffers,
      attribute
    } = this;
    const padBufferOpts = {
      numInstances,
      attribute,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: transitionSettings.enter
    };

    for (const buffer of buffers) {
      (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.padBuffer)({
        buffer,
        ...padBufferOpts
      });
    }

    this.settings = transitionSettings;
    this.currentStartIndices = attribute.startIndices;
    this.currentLength = (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.getAttributeBufferLength)(attribute, numInstances);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: attribute.value
    });
    this.transition.start({ ...transitionSettings,
      duration: Infinity
    });
    this.transform.update({
      elementCount: Math.floor(this.currentLength / attribute.size),
      sourceBuffers: {
        aTo: (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.getSourceBufferAttribute)(gl, attribute)
      }
    });
  }

  update() {
    const {
      buffers,
      transform,
      framebuffer,
      transition
    } = this;
    const updated = transition.update();

    if (!updated) {
      return false;
    }

    const settings = this.settings;
    transform.update({
      sourceBuffers: {
        aPrev: buffers[0],
        aCur: buffers[1]
      },
      feedbackBuffers: {
        vNext: buffers[2]
      }
    });
    transform.run({
      framebuffer,
      discard: false,
      clearRenderTarget: true,
      uniforms: {
        stiffness: settings.stiffness,
        damping: settings.damping
      },
      parameters: {
        depthTest: false,
        blend: true,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    });
    (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.cycleBuffers)(buffers);
    this.attributeInTransition.setData({
      buffer: buffers[1],
      value: this.attribute.value
    });
    const isTransitioning = (0,_luma_gl_core__WEBPACK_IMPORTED_MODULE_5__.readPixelsToArray)(framebuffer)[0] > 0;

    if (!isTransitioning) {
      transition.end();
    }

    return true;
  }

  cancel() {
    this.transition.cancel();
    this.transform.delete();

    for (const buffer of this.buffers) {
      buffer.delete();
    }

    this.buffers.length = 0;
    this.texture.delete();
    this.framebuffer.delete();
  }

}

function getTransform(gl, attribute, framebuffer) {
  const attributeType = (0,_lib_attribute_attribute_transition_utils__WEBPACK_IMPORTED_MODULE_4__.getAttributeTypeFromSize)(attribute.size);
  return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_6__["default"](gl, {
    framebuffer,
    vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
    fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
    defines: {
      ATTRIBUTE_TYPE: attributeType
    },
    varyings: ['vNext']
  });
}

function getTexture(gl) {
  return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__["default"](gl, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: false,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}

function getFramebuffer(gl, texture) {
  return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__["default"](gl, {
    id: 'spring-transition-is-transitioning-framebuffer',
    width: 1,
    height: 1,
    attachments: {
      [36064]: texture
    }
  });
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ LinearInterpolator)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _transition_interpolator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition-interpolator */ "./node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");



const DEFAULT_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
const DEFAULT_REQUIRED_PROPS = ['longitude', 'latitude', 'zoom'];
class LinearInterpolator extends _transition_interpolator__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(opts = {}) {
    const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
    const normalizedOpts = Array.isArray(opts) ? {} : opts;
    normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
      compare: transitionProps,
      required: transitionProps
    } : transitionProps || {
      compare: DEFAULT_PROPS,
      required: DEFAULT_REQUIRED_PROPS
    };
    super(normalizedOpts.transitionProps);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "opts", void 0);

    this.opts = normalizedOpts;
  }

  initializeProps(startProps, endProps) {
    const result = super.initializeProps(startProps, endProps);
    const {
      makeViewport,
      around
    } = this.opts;

    if (makeViewport && around) {
      const startViewport = makeViewport(startProps);
      const endViewport = makeViewport(endProps);
      const aroundPosition = startViewport.unproject(around);
      result.start.around = around;
      Object.assign(result.end, {
        around: endViewport.project(aroundPosition),
        aroundPosition,
        width: endProps.width,
        height: endProps.height
      });
    }

    return result;
  }

  interpolateProps(startProps, endProps, t) {
    const propsInTransition = {};

    for (const key of this._propsToExtract) {
      propsInTransition[key] = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.lerp)(startProps[key] || 0, endProps[key] || 0, t);
    }

    if (endProps.aroundPosition && this.opts.makeViewport) {
      const viewport = this.opts.makeViewport({ ...endProps,
        ...propsInTransition
      });
      Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.lerp)(startProps.around, endProps.around, t)));
    }

    return propsInTransition;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TransitionInterpolator)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");



class TransitionInterpolator {
  constructor(opts) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_propsToCompare", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_propsToExtract", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_requiredProps", void 0);

    const {
      compare,
      extract,
      required
    } = opts;
    this._propsToCompare = compare;
    this._propsToExtract = extract || compare;
    this._requiredProps = required;
  }

  arePropsEqual(currentProps, nextProps) {
    for (const key of this._propsToCompare) {
      if (!(key in currentProps) || !(key in nextProps) || !(0,_math_gl_core__WEBPACK_IMPORTED_MODULE_1__.equals)(currentProps[key], nextProps[key])) {
        return false;
      }
    }

    return true;
  }

  initializeProps(startProps, endProps) {
    const startViewStateProps = {};
    const endViewStateProps = {};

    for (const key of this._propsToExtract) {
      if (key in startProps || key in endProps) {
        startViewStateProps[key] = startProps[key];
        endViewStateProps[key] = endProps[key];
      }
    }

    this._checkRequiredProps(startViewStateProps);

    this._checkRequiredProps(endViewStateProps);

    return {
      start: startViewStateProps,
      end: endViewStateProps
    };
  }

  getDuration(startProps, endProps) {
    return endProps.transitionDuration;
  }

  _checkRequiredProps(props) {
    if (!this._requiredProps) {
      return;
    }

    this._requiredProps.forEach(propName => {
      const value = props[propName];
      (0,_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
    });
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/transitions/transition.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/transitions/transition.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transition)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

class Transition {
  constructor(timeline) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_inProgress", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_handle", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_timeline", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "time", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "settings", void 0);

    this._inProgress = false;
    this._handle = null;
    this._timeline = timeline;
    this.time = 0;
    this.settings = {
      duration: 0
    };
  }

  get inProgress() {
    return this._inProgress;
  }

  start(settings) {
    var _this$settings$onStar, _this$settings;

    this.cancel();
    this.settings = settings;
    this._inProgress = true;
    (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
  }

  end() {
    if (this._inProgress) {
      var _this$settings$onEnd, _this$settings2;

      this._timeline.removeChannel(this._handle);

      this._handle = null;
      this._inProgress = false;
      (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
    }
  }

  cancel() {
    if (this._inProgress) {
      var _this$settings$onInte, _this$settings3;

      (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);

      this._timeline.removeChannel(this._handle);

      this._handle = null;
      this._inProgress = false;
    }
  }

  update() {
    var _this$settings$onUpda, _this$settings4;

    if (!this._inProgress) {
      return false;
    }

    if (this._handle === null) {
      const {
        _timeline: timeline,
        settings
      } = this;
      this._handle = timeline.addChannel({
        delay: timeline.getTime(),
        duration: settings.duration
      });
    }

    this.time = this._timeline.getTime(this._handle);

    this._onUpdate();

    (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);

    if (this._timeline.isFinished(this._handle)) {
      this.end();
    }

    return true;
  }

  _onUpdate() {}

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/array-utils.js":
/*!******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/array-utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "padArray": () => (/* binding */ padArray)
/* harmony export */ });
function padArrayChunk(options) {
  const {
    source,
    target,
    start = 0,
    size,
    getData
  } = options;
  const end = options.end || target.length;
  const sourceLength = source.length;
  const targetLength = end - start;

  if (sourceLength > targetLength) {
    target.set(source.subarray(0, targetLength), start);
    return;
  }

  target.set(source, start);

  if (!getData) {
    return;
  }

  let i = sourceLength;

  while (i < targetLength) {
    const datum = getData(i, source);

    for (let j = 0; j < size; j++) {
      target[start + i] = datum[j] || 0;
      i++;
    }
  }
}

function padArray({
  source,
  target,
  size,
  getData,
  sourceStartIndices,
  targetStartIndices
}) {
  if (!Array.isArray(targetStartIndices)) {
    padArrayChunk({
      source,
      target,
      size,
      getData
    });
    return target;
  }

  let sourceIndex = 0;
  let targetIndex = 0;

  const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));

  const n = Math.min(sourceStartIndices.length, targetStartIndices.length);

  for (let i = 1; i < n; i++) {
    const nextSourceIndex = sourceStartIndices[i] * size;
    const nextTargetIndex = targetStartIndices[i] * size;
    padArrayChunk({
      source: source.subarray(sourceIndex, nextSourceIndex),
      target,
      start: targetIndex,
      end: nextTargetIndex,
      size,
      getData: getChunkData
    });
    sourceIndex = nextSourceIndex;
    targetIndex = nextTargetIndex;
  }

  if (targetIndex < target.length) {
    padArrayChunk({
      source: [],
      target,
      start: targetIndex,
      size,
      getData: getChunkData
    });
  }

  return target;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js":
/*!*************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/assert.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ assert)
/* harmony export */ });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'deck.gl: assertion failed.');
  }
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/count.js":
/*!************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/count.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "count": () => (/* binding */ count)
/* harmony export */ });
const ERR_NOT_OBJECT = 'count(): argument not an object';
const ERR_NOT_CONTAINER = 'count(): argument not a container';
function count(container) {
  if (!isObject(container)) {
    throw new Error(ERR_NOT_OBJECT);
  }

  if (typeof container.count === 'function') {
    return container.count();
  }

  if (Number.isFinite(container.size)) {
    return container.size;
  }

  if (Number.isFinite(container.length)) {
    return container.length;
  }

  if (isPlainObject(container)) {
    return Object.keys(container).length;
  }

  throw new Error(ERR_NOT_CONTAINER);
}

function isPlainObject(value) {
  return value !== null && typeof value === 'object' && value.constructor === Object;
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deepEqual": () => (/* binding */ deepEqual)
/* harmony export */ });
function deepEqual(a, b, depth) {
  if (a === b) {
    return true;
  }

  if (!depth || !a || !b) {
    return false;
  }

  if (Array.isArray(a)) {
    if (!Array.isArray(b) || a.length !== b.length) {
      return false;
    }

    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i], depth - 1)) {
        return false;
      }
    }

    return true;
  }

  if (Array.isArray(b)) {
    return false;
  }

  if (typeof a === 'object' && typeof b === 'object') {
    const aKeys = Object.keys(a);
    const bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) {
      return false;
    }

    for (const key of aKeys) {
      if (!b.hasOwnProperty(key)) {
        return false;
      }

      if (!deepEqual(a[key], b[key], depth - 1)) {
        return false;
      }
    }

    return true;
  }

  return false;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/flatten.js":
/*!**************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/flatten.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fillArray": () => (/* binding */ fillArray),
/* harmony export */   "flatten": () => (/* binding */ flatten)
/* harmony export */ });
function flatten(array, filter = () => true) {
  if (!Array.isArray(array)) {
    return filter(array) ? [array] : [];
  }

  return flattenArray(array, filter, []);
}

function flattenArray(array, filter, result) {
  let index = -1;

  while (++index < array.length) {
    const value = array[index];

    if (Array.isArray(value)) {
      flattenArray(value, filter, result);
    } else if (filter(value)) {
      result.push(value);
    }
  }

  return result;
}

function fillArray({
  target,
  source,
  start = 0,
  count = 1
}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;

  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createIterable": () => (/* binding */ createIterable),
/* harmony export */   "getAccessorFromBuffer": () => (/* binding */ getAccessorFromBuffer),
/* harmony export */   "isAsyncIterable": () => (/* binding */ isAsyncIterable)
/* harmony export */ });
const EMPTY_ARRAY = [];
const placeholderArray = [];
function createIterable(data, startRow = 0, endRow = Infinity) {
  let iterable = EMPTY_ARRAY;
  const objectInfo = {
    index: -1,
    data,
    target: []
  };

  if (!data) {
    iterable = EMPTY_ARRAY;
  } else if (typeof data[Symbol.iterator] === 'function') {
    iterable = data;
  } else if (data.length > 0) {
    placeholderArray.length = data.length;
    iterable = placeholderArray;
  }

  if (startRow > 0 || Number.isFinite(endRow)) {
    iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
    objectInfo.index = startRow - 1;
  }

  return {
    iterable,
    objectInfo
  };
}
function isAsyncIterable(data) {
  return data && data[Symbol.asyncIterator];
}
function getAccessorFromBuffer(typedArray, options) {
  const {
    size,
    stride,
    offset,
    startIndices,
    nested
  } = options;
  const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
  const elementStride = stride ? stride / bytesPerElement : size;
  const elementOffset = offset ? offset / bytesPerElement : 0;
  const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
  return (_, {
    index,
    target
  }) => {
    if (!startIndices) {
      const sourceIndex = index * elementStride + elementOffset;

      for (let j = 0; j < size; j++) {
        target[j] = typedArray[sourceIndex + j];
      }

      return target;
    }

    const startIndex = startIndices[index];
    const endIndex = startIndices[index + 1] || vertexCount;
    let result;

    if (nested) {
      result = new Array(endIndex - startIndex);

      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;
        target = new Array(size);

        for (let j = 0; j < size; j++) {
          target[j] = typedArray[sourceIndex + j];
        }

        result[i - startIndex] = target;
      }
    } else if (elementStride === size) {
      result = typedArray.subarray(startIndex * size + elementOffset, endIndex * size + elementOffset);
    } else {
      result = new typedArray.constructor((endIndex - startIndex) * size);
      let targetIndex = 0;

      for (let i = startIndex; i < endIndex; i++) {
        const sourceIndex = i * elementStride + elementOffset;

        for (let j = 0; j < size; j++) {
          result[targetIndex++] = typedArray[sourceIndex + j];
        }
      }
    }

    return result;
  };
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/json-loader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/json-loader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function isJSON(text) {
  const firstChar = text[0];
  const lastChar = text[text.length - 1];
  return firstChar === '{' && lastChar === '}' || firstChar === '[' && lastChar === ']';
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  id: 'JSON',
  name: 'JSON',
  module: '',
  version: '',
  options: {},
  extensions: ['json', 'geojson'],
  mimeTypes: ['application/json', 'application/geo+json'],
  testText: isJSON,
  parseTextSync: JSON.parse
});


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/log.js":
/*!**********************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/log.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/log */ "./node_modules/@probe.gl/log/dist/esm/log.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new _probe_gl_log__WEBPACK_IMPORTED_MODULE_0__.Log({
  id: 'deck'
}));


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createMat4": () => (/* binding */ createMat4),
/* harmony export */   "fp64LowPart": () => (/* binding */ fp64LowPart),
/* harmony export */   "getCameraPosition": () => (/* binding */ getCameraPosition),
/* harmony export */   "getFrustumPlanes": () => (/* binding */ getFrustumPlanes),
/* harmony export */   "mergeBounds": () => (/* binding */ mergeBounds),
/* harmony export */   "mod": () => (/* binding */ mod),
/* harmony export */   "toDoublePrecisionArray": () => (/* binding */ toDoublePrecisionArray)
/* harmony export */ });
/* harmony import */ var _typed_array_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typed-array-manager */ "./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");


function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function mod(value, divisor) {
  const modulus = value % divisor;
  return modulus < 0 ? divisor + modulus : modulus;
}
function getCameraPosition(viewMatrixInverse) {
  return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
}
function getFrustumPlanes(viewProjectionMatrix) {
  return {
    left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
    right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
    bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
    top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
    near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
    far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
  };
}
const scratchVector = new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["default"]();

function getFrustumPlane(a, b, c, d) {
  scratchVector.set(a, b, c);
  const L = scratchVector.len();
  return {
    distance: d / L,
    normal: new _math_gl_core__WEBPACK_IMPORTED_MODULE_0__["default"](-a / L, -b / L, -c / L)
  };
}

function fp64LowPart(x) {
  return x - Math.fround(x);
}
let scratchArray;
function toDoublePrecisionArray(typedArray, options) {
  const {
    size = 1,
    startIndex = 0
  } = options;
  const endIndex = options.endIndex !== undefined ? options.endIndex : typedArray.length;
  const count = (endIndex - startIndex) / size;
  scratchArray = _typed_array_manager__WEBPACK_IMPORTED_MODULE_1__["default"].allocate(scratchArray, count, {
    type: Float32Array,
    size: size * 2
  });
  let sourceIndex = startIndex;
  let targetIndex = 0;

  while (sourceIndex < endIndex) {
    for (let j = 0; j < size; j++) {
      const value = typedArray[sourceIndex++];
      scratchArray[targetIndex + j] = value;
      scratchArray[targetIndex + j + size] = fp64LowPart(value);
    }

    targetIndex += size * 2;
  }

  return scratchArray.subarray(0, count * size * 2);
}
function mergeBounds(boundsList) {
  let mergedBounds = null;
  let isMerged = false;

  for (const bounds of boundsList) {
    if (!bounds) continue;

    if (!mergedBounds) {
      mergedBounds = bounds;
    } else {
      if (!isMerged) {
        mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
        isMerged = true;
      }

      mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
      mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
      mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
      mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
    }
  }

  return mergedBounds;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/memoize.js":
/*!**************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/memoize.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ memoize)
/* harmony export */ });
function isEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (Array.isArray(a)) {
    const len = a.length;

    if (!b || b.length !== len) {
      return false;
    }

    for (let i = 0; i < len; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  return false;
}

function memoize(compute) {
  let cachedArgs = {};
  let cachedResult;
  return args => {
    for (const key in args) {
      if (!isEqual(args[key], cachedArgs[key])) {
        cachedResult = compute(args);
        cachedArgs = args;
        break;
      }
    }

    return cachedResult;
  };
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/positions.js":
/*!****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/positions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPosition": () => (/* binding */ getPosition),
/* harmony export */   "parsePosition": () => (/* binding */ parsePosition)
/* harmony export */ });
const PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
function parsePosition(value) {
  switch (typeof value) {
    case 'number':
      return {
        position: value,
        relative: false
      };

    case 'string':
      const match = PERCENT_OR_PIXELS_REGEX.exec(value);

      if (match && match.length >= 3) {
        const relative = match[2] === '%';
        const position = parseFloat(match[1]);
        return {
          position: relative ? position / 100 : position,
          relative
        };
      }

    default:
      throw new Error("Could not parse position string ".concat(value));
  }
}
function getPosition(position, extent) {
  return position.relative ? Math.round(position.position * extent) : position.position;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/range.js":
/*!************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/range.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY": () => (/* binding */ EMPTY),
/* harmony export */   "FULL": () => (/* binding */ FULL),
/* harmony export */   "add": () => (/* binding */ add)
/* harmony export */ });
const EMPTY = [];
const FULL = [[0, Infinity]];
function add(rangeList, range) {
  if (rangeList === FULL) {
    return rangeList;
  }

  if (range[0] < 0) {
    range[0] = 0;
  }

  if (range[0] >= range[1]) {
    return rangeList;
  }

  const newRangeList = [];
  const len = rangeList.length;
  let insertPosition = 0;

  for (let i = 0; i < len; i++) {
    const range0 = rangeList[i];

    if (range0[1] < range[0]) {
      newRangeList.push(range0);
      insertPosition = i + 1;
    } else if (range0[0] > range[1]) {
      newRangeList.push(range0);
    } else {
      range = [Math.min(range0[0], range[0]), Math.max(range0[1], range[1])];
    }
  }

  newRangeList.splice(insertPosition, 0, range);
  return newRangeList;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/shader.js":
/*!*************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/shader.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeShaders": () => (/* binding */ mergeShaders)
/* harmony export */ });
function mergeShaders(target, source) {
  if (!source) {
    return target;
  }

  const result = { ...target,
    ...source
  };

  if ('defines' in source) {
    result.defines = { ...target.defines,
      ...source.defines
    };
  }

  if ('modules' in source) {
    result.modules = (target.modules || []).concat(source.modules);

    if (source.modules.some(module => module.name === 'project64')) {
      const index = result.modules.findIndex(module => module.name === 'project32');

      if (index >= 0) {
        result.modules.splice(index, 1);
      }
    }
  }

  if ('inject' in source) {
    if (!target.inject) {
      result.inject = source.inject;
    } else {
      const mergedInjection = { ...target.inject
      };

      for (const key in source.inject) {
        mergedInjection[key] = (mergedInjection[key] || '') + source.inject[key];
      }

      result.inject = mergedInjection;
    }
  }

  return result;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Tesselator)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _iterable_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./iterable-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js");
/* harmony import */ var _typed_array_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./typed-array-manager */ "./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");





class Tesselator {
  constructor(opts) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "opts", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "typedArrayManager", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "indexStarts", [0]);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vertexStarts", [0]);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "vertexCount", 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "instanceCount", 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "attributes", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_attributeDefs", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "data", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "getGeometry", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "geometryBuffer", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "buffers", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "positionSize", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "normalize", void 0);

    const {
      attributes = {}
    } = opts;
    this.typedArrayManager = _typed_array_manager__WEBPACK_IMPORTED_MODULE_1__["default"];
    this.attributes = {};
    this._attributeDefs = attributes;
    this.opts = opts;
    this.updateGeometry(opts);
  }

  updateGeometry(opts) {
    Object.assign(this.opts, opts);
    const {
      data,
      buffers = {},
      getGeometry,
      geometryBuffer,
      positionFormat,
      dataChanged,
      normalize = true
    } = this.opts;
    this.data = data;
    this.getGeometry = getGeometry;
    this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === 'XY' ? 2 : 3);
    this.buffers = buffers;
    this.normalize = normalize;

    if (geometryBuffer) {
      (0,_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(data.startIndices);
      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);

      if (!normalize) {
        buffers.positions = geometryBuffer;
      }
    }

    this.geometryBuffer = buffers.positions;

    if (Array.isArray(dataChanged)) {
      for (const dataRange of dataChanged) {
        this._rebuildGeometry(dataRange);
      }
    } else {
      this._rebuildGeometry();
    }
  }

  updatePartialGeometry({
    startRow,
    endRow
  }) {
    this._rebuildGeometry({
      startRow,
      endRow
    });
  }

  getGeometryFromBuffer(geometryBuffer) {
    const value = geometryBuffer.value || geometryBuffer;

    if (!ArrayBuffer.isView(value)) {
      return null;
    }

    return (0,_iterable_utils__WEBPACK_IMPORTED_MODULE_3__.getAccessorFromBuffer)(value, {
      size: this.positionSize,
      offset: geometryBuffer.offset,
      stride: geometryBuffer.stride,
      startIndices: this.data.startIndices
    });
  }

  _allocate(instanceCount, copy) {
    const {
      attributes,
      buffers,
      _attributeDefs,
      typedArrayManager
    } = this;

    for (const name in _attributeDefs) {
      if (name in buffers) {
        typedArrayManager.release(attributes[name]);
        attributes[name] = null;
      } else {
        const def = _attributeDefs[name];
        def.copy = copy;
        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);
      }
    }
  }

  _forEachGeometry(visitor, startRow, endRow) {
    const {
      data,
      getGeometry
    } = this;
    const {
      iterable,
      objectInfo
    } = (0,_iterable_utils__WEBPACK_IMPORTED_MODULE_3__.createIterable)(data, startRow, endRow);

    for (const object of iterable) {
      objectInfo.index++;
      const geometry = getGeometry ? getGeometry(object, objectInfo) : null;
      visitor(geometry, objectInfo.index);
    }
  }

  _rebuildGeometry(dataRange) {
    if (!this.data) {
      return;
    }

    let {
      indexStarts,
      vertexStarts,
      instanceCount
    } = this;
    const {
      data,
      geometryBuffer
    } = this;
    const {
      startRow = 0,
      endRow = Infinity
    } = dataRange || {};
    const normalizedData = {};

    if (!dataRange) {
      indexStarts = [0];
      vertexStarts = [0];
    }

    if (this.normalize || !geometryBuffer) {
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
        normalizedData[dataIndex] = normalizedGeometry;
        vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
      }, startRow, endRow);

      instanceCount = vertexStarts[vertexStarts.length - 1];
    } else {
      vertexStarts = data.startIndices;
      instanceCount = vertexStarts[data.length] || 0;

      if (ArrayBuffer.isView(geometryBuffer)) {
        instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
      } else if (geometryBuffer instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["default"]) {
        const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
      } else if (geometryBuffer.buffer) {
        const byteStride = geometryBuffer.stride || this.positionSize * 4;
        instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
      } else if (geometryBuffer.value) {
        const bufferValue = geometryBuffer.value;
        const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
        instanceCount = instanceCount || bufferValue.length / elementStride;
      }
    }

    this._allocate(instanceCount, Boolean(dataRange));

    this.indexStarts = indexStarts;
    this.vertexStarts = vertexStarts;
    this.instanceCount = instanceCount;
    const context = {};

    this._forEachGeometry((geometry, dataIndex) => {
      const normalizedGeometry = normalizedData[dataIndex] || geometry;
      context.vertexStart = vertexStarts[dataIndex];
      context.indexStart = indexStarts[dataIndex];
      const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
      context.geometrySize = vertexEnd - vertexStarts[dataIndex];
      context.geometryIndex = dataIndex;
      this.updateGeometryAttributes(normalizedGeometry, context);
    }, startRow, endRow);

    this.vertexCount = indexStarts[indexStarts.length - 1];
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/texture.js":
/*!**************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/texture.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createTexture": () => (/* binding */ createTexture),
/* harmony export */   "destroyTexture": () => (/* binding */ destroyTexture)
/* harmony export */ });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/core */ "./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");

const DEFAULT_TEXTURE_PARAMETERS = {
  [10241]: 9987,
  [10240]: 9729,
  [10242]: 33071,
  [10243]: 33071
};
const internalTextures = {};
function createTexture(owner, gl, image, parameters) {
  if (image instanceof _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    return image;
  } else if (image.constructor && image.constructor.name !== 'Object') {
    image = {
      data: image
    };
  }

  let specialTextureParameters = null;

  if (image.compressed) {
    specialTextureParameters = {
      [10241]: image.data.length > 1 ? 9985 : 9729
    };
  }

  const texture = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["default"](gl, { ...image,
    parameters: { ...DEFAULT_TEXTURE_PARAMETERS,
      ...specialTextureParameters,
      ...parameters
    }
  });
  internalTextures[texture.id] = owner;
  return texture;
}
function destroyTexture(owner, texture) {
  if (!texture || !(texture instanceof _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["default"])) {
    return;
  }

  if (internalTextures[texture.id] === owner) {
    texture.delete();
    delete internalTextures[texture.id];
  }
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedArrayManager": () => (/* binding */ TypedArrayManager),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");

class TypedArrayManager {
  constructor(options = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_pool", []);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    });

    this.setOptions(options);
  }

  setOptions(options) {
    Object.assign(this.opts, options);
  }

  allocate(typedArray, count, {
    size = 1,
    type,
    padding = 0,
    copy = false,
    initialize = false,
    maxCount
  }) {
    const Type = type || typedArray && typedArray.constructor || Float32Array;
    const newSize = count * size + padding;

    if (ArrayBuffer.isView(typedArray)) {
      if (newSize <= typedArray.length) {
        return typedArray;
      }

      if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
        return new Type(typedArray.buffer, 0, newSize);
      }
    }

    let maxSize = Infinity;

    if (maxCount) {
      maxSize = maxCount * size + padding;
    }

    const newArray = this._allocate(Type, newSize, initialize, maxSize);

    if (typedArray && copy) {
      newArray.set(typedArray);
    } else if (!initialize) {
      newArray.fill(0, 0, 4);
    }

    this._release(typedArray);

    return newArray;
  }

  release(typedArray) {
    this._release(typedArray);
  }

  _allocate(Type, size, initialize, maxSize) {
    let sizeToAllocate = Math.max(Math.ceil(size * this.opts.overAlloc), 1);

    if (sizeToAllocate > maxSize) {
      sizeToAllocate = maxSize;
    }

    const pool = this._pool;
    const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
    const i = pool.findIndex(b => b.byteLength >= byteLength);

    if (i >= 0) {
      const array = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);

      if (initialize) {
        array.fill(0);
      }

      return array;
    }

    return new Type(sizeToAllocate);
  }

  _release(typedArray) {
    if (!ArrayBuffer.isView(typedArray)) {
      return;
    }

    const pool = this._pool;
    const {
      buffer
    } = typedArray;
    const {
      byteLength
    } = buffer;
    const i = pool.findIndex(b => b.byteLength >= byteLength);

    if (i < 0) {
      pool.push(buffer);
    } else if (i > 0 || pool.length < this.opts.poolSize) {
      pool.splice(i, 0, buffer);
    }

    if (pool.length > this.opts.poolSize) {
      pool.shift();
    }
  }

}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new TypedArrayManager());


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FirstPersonViewport)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _viewports_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");




class FirstPersonViewport extends _viewports_viewport__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(props) {
    const {
      longitude,
      latitude,
      modelMatrix,
      bearing = 0,
      pitch = 0,
      up = [0, 0, 1]
    } = props;
    const spherical = new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"]({
      bearing,
      pitch: pitch === -90 ? 0.0001 : 90 + pitch
    });
    const dir = spherical.toVector3().normalize();
    const center = modelMatrix ? new _math_gl_core__WEBPACK_IMPORTED_MODULE_4__["default"](modelMatrix).transformAsVector(dir) : dir;
    const zoom = Number.isFinite(latitude) ? (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getMeterZoom)({
      latitude: latitude
    }) : 0;
    const scale = Math.pow(2, zoom);
    const viewMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_4__["default"]().lookAt({
      eye: [0, 0, 0],
      center,
      up
    }).scale(scale);
    super({ ...props,
      zoom,
      viewMatrix
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "longitude", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "latitude", void 0);

    this.latitude = latitude;
    this.longitude = longitude;
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GlobeViewport)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec4 */ "./node_modules/gl-matrix/esm/vec4.js");






const DEGREES_TO_RADIANS = Math.PI / 180;
const RADIANS_TO_DEGREES = 180 / Math.PI;
const EARTH_RADIUS = 6370972;
const GLOBE_RADIUS = 256;

function getDistanceScales() {
  const unitsPerMeter = GLOBE_RADIUS / EARTH_RADIUS;
  const unitsPerDegree = Math.PI / 180 * GLOBE_RADIUS;
  return {
    unitsPerMeter: [unitsPerMeter, unitsPerMeter, unitsPerMeter],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / unitsPerMeter, 1 / unitsPerMeter, 1 / unitsPerMeter],
    unitsPerDegree: [unitsPerDegree, unitsPerDegree, unitsPerMeter],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / unitsPerDegree, 1 / unitsPerDegree, 1 / unitsPerMeter]
  };
}

class GlobeViewport extends _viewport__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 2,
      resolution = 10
    } = opts;
    let {
      height,
      altitude = 1.5
    } = opts;
    height = height || 1;
    altitude = Math.max(0.75, altitude);
    const viewMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"]().lookAt({
      eye: [0, -altitude, 0],
      up: [0, 0, 1]
    });
    const scale = Math.pow(2, zoom);
    viewMatrix.rotateX(latitude * DEGREES_TO_RADIANS);
    viewMatrix.rotateZ(-longitude * DEGREES_TO_RADIANS);
    viewMatrix.scale(scale / height);
    const halfFov = Math.atan(0.5 / altitude);
    const relativeScale = GLOBE_RADIUS * 2 * scale / height;
    super({ ...opts,
      height,
      viewMatrix,
      longitude,
      latitude,
      zoom,
      distanceScales: getDistanceScales(),
      fovyRadians: halfFov * 2,
      focalDistance: altitude,
      near: nearZMultiplier,
      far: Math.min(2, 1 / relativeScale + 1) * altitude * farZMultiplier
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "longitude", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "latitude", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "resolution", void 0);

    this.latitude = latitude;
    this.longitude = longitude;
    this.resolution = resolution;
  }

  get projectionMode() {
    return _lib_constants__WEBPACK_IMPORTED_MODULE_3__.PROJECTION_MODE.GLOBE;
  }

  getDistanceScales() {
    return this.distanceScales;
  }

  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const left = this.unproject([0, this.height / 2], unprojectOption);
    const top = this.unproject([this.width / 2, 0], unprojectOption);
    const right = this.unproject([this.width, this.height / 2], unprojectOption);
    const bottom = this.unproject([this.width / 2, this.height], unprojectOption);
    if (right[0] < this.longitude) right[0] += 360;
    if (left[0] > this.longitude) left[0] -= 360;
    return [Math.min(left[0], right[0], top[0], bottom[0]), Math.min(left[1], right[1], top[1], bottom[1]), Math.max(left[0], right[0], top[0], bottom[0]), Math.max(left[1], right[1], top[1], bottom[1])];
  }

  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const {
      pixelUnprojectionMatrix
    } = this;
    let coord;

    if (Number.isFinite(z)) {
      coord = transformVector(pixelUnprojectionMatrix, [x, y2, z, 1]);
    } else {
      const coord0 = transformVector(pixelUnprojectionMatrix, [x, y2, -1, 1]);
      const coord1 = transformVector(pixelUnprojectionMatrix, [x, y2, 1, 1]);
      const lt = ((targetZ || 0) / EARTH_RADIUS + 1) * GLOBE_RADIUS;
      const lSqr = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.sqrLen(gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.sub([], coord0, coord1));
      const l0Sqr = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.sqrLen(coord0);
      const l1Sqr = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.sqrLen(coord1);
      const sSqr = (4 * l0Sqr * l1Sqr - (lSqr - l0Sqr - l1Sqr) ** 2) / 16;
      const dSqr = 4 * sSqr / lSqr;
      const r0 = Math.sqrt(l0Sqr - dSqr);
      const dr = Math.sqrt(Math.max(0, lt * lt - dSqr));
      const t = (r0 - dr) / Math.sqrt(lSqr);
      coord = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.lerp([], coord0, coord1, t);
    }

    const [X, Y, Z] = this.unprojectPosition(coord);

    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }

    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }

  projectPosition(xyz) {
    const [lng, lat, Z = 0] = xyz;
    const lambda = lng * DEGREES_TO_RADIANS;
    const phi = lat * DEGREES_TO_RADIANS;
    const cosPhi = Math.cos(phi);
    const D = (Z / EARTH_RADIUS + 1) * GLOBE_RADIUS;
    return [Math.sin(lambda) * cosPhi * D, -Math.cos(lambda) * cosPhi * D, Math.sin(phi) * D];
  }

  unprojectPosition(xyz) {
    const [x, y, z] = xyz;
    const D = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_4__.len(xyz);
    const phi = Math.asin(z / D);
    const lambda = Math.atan2(x, -y);
    const lng = lambda * RADIANS_TO_DEGREES;
    const lat = phi * RADIANS_TO_DEGREES;
    const Z = (D / GLOBE_RADIUS - 1) * EARTH_RADIUS;
    return [lng, lat, Z];
  }

  projectFlat(xyz) {
    return xyz;
  }

  unprojectFlat(xyz) {
    return xyz;
  }

  panByPosition(coords, pixel) {
    const fromPosition = this.unproject(pixel);
    return {
      longitude: coords[0] - fromPosition[0] + this.longitude,
      latitude: coords[1] - fromPosition[1] + this.latitude
    };
  }

}

function transformVector(matrix, vector) {
  const result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_5__.transformMat4([], vector, matrix);
  gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_5__.scale(result, result, 1 / result[3]);
  return result;
}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrbitViewport)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _viewports_viewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../viewports/viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");




const DEGREES_TO_RADIANS = Math.PI / 180;

function getViewMatrix({
  height,
  focalDistance,
  orbitAxis,
  rotationX,
  rotationOrbit,
  zoom
}) {
  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];
  const eye = orbitAxis === 'Z' ? [0, -focalDistance, 0] : [0, 0, focalDistance];
  const viewMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_2__["default"]().lookAt({
    eye,
    up
  });
  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);

  if (orbitAxis === 'Z') {
    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);
  } else {
    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);
  }

  const projectionScale = Math.pow(2, zoom) / height;
  viewMatrix.scale(projectionScale);
  return viewMatrix;
}

class OrbitViewport extends _viewports_viewport__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(props) {
    const {
      height,
      projectionMatrix,
      fovy = 50,
      orbitAxis = 'Z',
      target = [0, 0, 0],
      rotationX = 0,
      rotationOrbit = 0,
      zoom = 0
    } = props;
    const focalDistance = projectionMatrix ? projectionMatrix[5] / 2 : (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.fovyToAltitude)(fovy);
    super({ ...props,
      longitude: undefined,
      viewMatrix: getViewMatrix({
        height: height || 1,
        focalDistance,
        orbitAxis,
        rotationX,
        rotationOrbit,
        zoom
      }),
      fovy,
      focalDistance,
      position: target,
      zoom
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "projectedCenter", void 0);

    this.projectedCenter = this.project(this.center);
  }

  unproject(xyz, {
    topLeft = true
  } = {}) {
    const [x, y, z = this.projectedCenter[2]] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const [X, Y, Z] = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix);
    return [X, Y, Z];
  }

  panByPosition(coords, pixel) {
    const p0 = this.project(coords);
    const nextCenter = [this.width / 2 + p0[0] - pixel[0], this.height / 2 + p0[1] - pixel[1], this.projectedCenter[2]];
    return {
      target: this.unproject(nextCenter)
    };
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrthographicViewport)
/* harmony export */ });
/* harmony import */ var _viewports_viewport__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../viewports/viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec2 */ "./node_modules/gl-matrix/esm/vec2.js");




const viewMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__["default"]().lookAt({
  eye: [0, 0, 1]
});

function getProjectionMatrix({
  width,
  height,
  near,
  far,
  padding
}) {
  let left = -width / 2;
  let right = width / 2;
  let bottom = -height / 2;
  let top = height / 2;

  if (padding) {
    const {
      left: l = 0,
      right: r = 0,
      top: t = 0,
      bottom: b = 0
    } = padding;
    const offsetX = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)((l + width - r) / 2, 0, width) - width / 2;
    const offsetY = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_2__.clamp)((t + height - b) / 2, 0, height) - height / 2;
    left -= offsetX;
    right -= offsetX;
    bottom += offsetY;
    top += offsetY;
  }

  return new _math_gl_core__WEBPACK_IMPORTED_MODULE_1__["default"]().ortho({
    left,
    right,
    bottom,
    top,
    near,
    far
  });
}

class OrthographicViewport extends _viewports_viewport__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(props) {
    const {
      width,
      height,
      near = 0.1,
      far = 1000,
      zoom = 0,
      target = [0, 0, 0],
      padding = null,
      flipY = true
    } = props;
    const zoomX = Array.isArray(zoom) ? zoom[0] : zoom;
    const zoomY = Array.isArray(zoom) ? zoom[1] : zoom;
    const zoom_ = Math.min(zoomX, zoomY);
    const scale = Math.pow(2, zoom_);
    let distanceScales;

    if (zoomX !== zoomY) {
      const scaleX = Math.pow(2, zoomX);
      const scaleY = Math.pow(2, zoomY);
      distanceScales = {
        unitsPerMeter: [scaleX / scale, scaleY / scale, 1],
        metersPerUnit: [scale / scaleX, scale / scaleY, 1]
      };
    }

    super({ ...props,
      longitude: undefined,
      position: target,
      viewMatrix: viewMatrix.clone().scale([scale, scale * (flipY ? -1 : 1), scale]),
      projectionMatrix: getProjectionMatrix({
        width: width || 1,
        height: height || 1,
        padding,
        near,
        far
      }),
      zoom: zoom_,
      distanceScales
    });
  }

  projectFlat([X, Y]) {
    const {
      unitsPerMeter
    } = this.distanceScales;
    return [X * unitsPerMeter[0], Y * unitsPerMeter[1]];
  }

  unprojectFlat([x, y]) {
    const {
      metersPerUnit
    } = this.distanceScales;
    return [x * metersPerUnit[0], y * metersPerUnit[1]];
  }

  panByPosition(coords, pixel) {
    const fromLocation = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_0__.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__.add([], toLocation, gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__.negate([], fromLocation));
    const newCenter = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__.add([], this.center, translate);
    return {
      target: this.unprojectFlat(newCenter)
    };
  }

}


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Viewport)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/log */ "./node_modules/@deck.gl/core/dist/esm/utils/log.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math-utils */ "./node_modules/@deck.gl/core/dist/esm/utils/math-utils.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! gl-matrix/mat4 */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../lib/constants */ "./node_modules/@deck.gl/core/dist/esm/lib/constants.js");







const DEGREES_TO_RADIANS = Math.PI / 180;
const IDENTITY = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.createMat4)();
const ZERO_VECTOR = [0, 0, 0];
const DEFAULT_DISTANCE_SCALES = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};

function createProjectionMatrix({
  width,
  height,
  orthographic,
  fovyRadians,
  focalDistance,
  padding,
  near,
  far
}) {
  const aspect = width / height;
  const matrix = orthographic ? new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"]().orthographic({
    fovy: fovyRadians,
    aspect,
    focalDistance,
    near,
    far
  }) : new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"]().perspective({
    fovy: fovyRadians,
    aspect,
    near,
    far
  });

  if (padding) {
    const {
      left = 0,
      right = 0,
      top = 0,
      bottom = 0
    } = padding;
    const offsetX = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)((left + width - right) / 2, 0, width) - width / 2;
    const offsetY = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)((top + height - bottom) / 2, 0, height) - height / 2;
    matrix[8] -= offsetX * 2 / width;
    matrix[9] += offsetY * 2 / height;
  }

  return matrix;
}

class Viewport {
  constructor(opts = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "x", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "y", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "width", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "height", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "padding", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "isGeospatial", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "zoom", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "focalDistance", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "position", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "modelMatrix", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "distanceScales", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "scale", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "center", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "cameraPosition", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "projectionMatrix", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewMatrix", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewMatrixUncentered", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewMatrixInverse", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewProjectionMatrix", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pixelProjectionMatrix", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pixelUnprojectionMatrix", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "resolution", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_frustumPlanes", {});

    this.id = opts.id || this.constructor.displayName || 'viewport';
    this.x = opts.x || 0;
    this.y = opts.y || 0;
    this.width = opts.width || 1;
    this.height = opts.height || 1;
    this.zoom = opts.zoom || 0;
    this.padding = opts.padding;
    this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
    this.focalDistance = opts.focalDistance || 1;
    this.position = opts.position || ZERO_VECTOR;
    this.modelMatrix = opts.modelMatrix || null;
    const {
      longitude,
      latitude
    } = opts;
    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);

    this._initProps(opts);

    this._initMatrices(opts);

    this.equals = this.equals.bind(this);
    this.project = this.project.bind(this);
    this.unproject = this.unproject.bind(this);
    this.projectPosition = this.projectPosition.bind(this);
    this.unprojectPosition = this.unprojectPosition.bind(this);
    this.projectFlat = this.projectFlat.bind(this);
    this.unprojectFlat = this.unprojectFlat.bind(this);
  }

  get subViewports() {
    return null;
  }

  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }

  get projectionMode() {
    if (this.isGeospatial) {
      return this.zoom < 12 ? _lib_constants__WEBPACK_IMPORTED_MODULE_5__.PROJECTION_MODE.WEB_MERCATOR : _lib_constants__WEBPACK_IMPORTED_MODULE_5__.PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
    }

    return _lib_constants__WEBPACK_IMPORTED_MODULE_5__.PROJECTION_MODE.IDENTITY;
  }

  equals(viewport) {
    if (!(viewport instanceof Viewport)) {
      return false;
    }

    if (this === viewport) {
      return true;
    }

    return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.equals)(viewport.viewMatrix, this.viewMatrix);
  }

  project(xyz, {
    topLeft = true
  } = {}) {
    const worldPosition = this.projectPosition(xyz);
    const coord = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.worldToPixels)(worldPosition, this.pixelProjectionMatrix);
    const [x, y] = coord;
    const y2 = topLeft ? y : this.height - y;
    return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
  }

  unproject(xyz, {
    topLeft = true,
    targetZ
  } = {}) {
    const [x, y, z] = xyz;
    const y2 = topLeft ? y : this.height - y;
    const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
    const coord = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
    const [X, Y, Z] = this.unprojectPosition(coord);

    if (Number.isFinite(z)) {
      return [X, Y, Z];
    }

    return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
  }

  projectPosition(xyz) {
    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [X, Y, Z];
  }

  unprojectPosition(xyz) {
    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [X, Y, Z];
  }

  projectFlat(xyz) {
    if (this.isGeospatial) {
      const result = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.lngLatToWorld)(xyz);
      result[1] = (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_4__.clamp)(result[1], -318, 830);
      return result;
    }

    return xyz;
  }

  unprojectFlat(xyz) {
    if (this.isGeospatial) {
      return (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.worldToLngLat)(xyz);
    }

    return xyz;
  }

  getBounds(options = {}) {
    const unprojectOption = {
      targetZ: options.z || 0
    };
    const topLeft = this.unproject([0, 0], unprojectOption);
    const topRight = this.unproject([this.width, 0], unprojectOption);
    const bottomLeft = this.unproject([0, this.height], unprojectOption);
    const bottomRight = this.unproject([this.width, this.height], unprojectOption);
    return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
  }

  getDistanceScales(coordinateOrigin) {
    if (coordinateOrigin) {
      return (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getDistanceScales)({
        longitude: coordinateOrigin[0],
        latitude: coordinateOrigin[1],
        highPrecision: true
      });
    }

    return this.distanceScales;
  }

  containsPixel({
    x,
    y,
    width = 1,
    height = 1
  }) {
    return x < this.x + this.width && this.x < x + width && y < this.y + this.height && this.y < y + height;
  }

  getFrustumPlanes() {
    if (this._frustumPlanes.near) {
      return this._frustumPlanes;
    }

    Object.assign(this._frustumPlanes, (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.getFrustumPlanes)(this.viewProjectionMatrix));
    return this._frustumPlanes;
  }

  panByPosition(coords, pixel) {
    return null;
  }

  _initProps(opts) {
    const longitude = opts.longitude;
    const latitude = opts.latitude;

    if (this.isGeospatial) {
      if (!Number.isFinite(opts.zoom)) {
        this.zoom = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getMeterZoom)({
          latitude
        }) + Math.log2(this.focalDistance);
      }

      this.distanceScales = opts.distanceScales || (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getDistanceScales)({
        latitude,
        longitude
      });
    }

    const scale = Math.pow(2, this.zoom);
    this.scale = scale;
    const {
      position,
      modelMatrix
    } = opts;
    let meterOffset = ZERO_VECTOR;

    if (position) {
      meterOffset = modelMatrix ? new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"](modelMatrix).transformAsVector(position, []) : position;
    }

    if (this.isGeospatial) {
      const center = this.projectPosition([longitude, latitude, 0]);
      this.center = new _math_gl_core__WEBPACK_IMPORTED_MODULE_6__["default"](meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
    } else {
      this.center = this.projectPosition(meterOffset);
    }
  }

  _initMatrices(opts) {
    const {
      viewMatrix = IDENTITY,
      projectionMatrix = null,
      orthographic = false,
      fovyRadians,
      fovy = 75,
      near = 0.1,
      far = 1000,
      padding = null,
      focalDistance = 1
    } = opts;
    this.viewMatrixUncentered = viewMatrix;
    this.viewMatrix = new _math_gl_core__WEBPACK_IMPORTED_MODULE_3__["default"]().multiplyRight(viewMatrix).translate(new _math_gl_core__WEBPACK_IMPORTED_MODULE_6__["default"](this.center).negate());
    this.projectionMatrix = projectionMatrix || createProjectionMatrix({
      width: this.width,
      height: this.height,
      orthographic,
      fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS,
      focalDistance,
      padding,
      near,
      far
    });
    const vpm = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.createMat4)();
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.multiply(vpm, vpm, this.projectionMatrix);
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.multiply(vpm, vpm, this.viewMatrix);
    this.viewProjectionMatrix = vpm;
    this.viewMatrixInverse = gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.invert([], this.viewMatrix) || this.viewMatrix;
    this.cameraPosition = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.getCameraPosition)(this.viewMatrixInverse);
    const viewportMatrix = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.createMat4)();
    const pixelProjectionMatrix = (0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.createMat4)();
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.scale(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.multiply(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
    this.pixelProjectionMatrix = pixelProjectionMatrix;
    this.pixelUnprojectionMatrix = gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_7__.invert((0,_utils_math_utils__WEBPACK_IMPORTED_MODULE_2__.createMat4)(), this.pixelProjectionMatrix);

    if (!this.pixelUnprojectionMatrix) {
      _utils_log__WEBPACK_IMPORTED_MODULE_8__["default"].warn('Pixel project matrix not invertible')();
    }
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(Viewport, "displayName", 'Viewport');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebMercatorViewport)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @math.gl/web-mercator */ "./node_modules/@math.gl/web-mercator/dist/esm/index.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec2 */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _math_gl_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @math.gl/core */ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js");





class WebMercatorViewport extends _viewport__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(opts = {}) {
    const {
      latitude = 0,
      longitude = 0,
      zoom = 0,
      pitch = 0,
      bearing = 0,
      nearZMultiplier = 0.1,
      farZMultiplier = 1.01,
      orthographic = false,
      projectionMatrix,
      repeat = false,
      worldOffset = 0,
      position,
      padding,
      legacyMeterSizes = false
    } = opts;
    let {
      width,
      height,
      altitude = 1.5
    } = opts;
    const scale = Math.pow(2, zoom);
    width = width || 1;
    height = height || 1;
    let fovy;
    let projectionParameters = null;

    if (projectionMatrix) {
      altitude = projectionMatrix[5] / 2;
      fovy = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.altitudeToFovy)(altitude);
    } else {
      if (opts.fovy) {
        fovy = opts.fovy;
        altitude = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.fovyToAltitude)(fovy);
      } else {
        fovy = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.altitudeToFovy)(altitude);
      }

      let offset;

      if (padding) {
        const {
          top = 0,
          bottom = 0
        } = padding;
        offset = [0, (0,_math_gl_core__WEBPACK_IMPORTED_MODULE_3__.clamp)((top + height - bottom) / 2, 0, height) - height / 2];
      }

      projectionParameters = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getProjectionParameters)({
        width,
        height,
        scale,
        center: position && [0, 0, position[2] * (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.unitsPerMeter)(latitude)],
        offset,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
    }

    let viewMatrixUncentered = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getViewMatrix)({
      height,
      pitch,
      bearing,
      scale,
      altitude
    });

    if (worldOffset) {
      const viewOffset = new _math_gl_core__WEBPACK_IMPORTED_MODULE_4__["default"]().translate([512 * worldOffset, 0, 0]);
      viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
    }

    super({ ...opts,
      width,
      height,
      viewMatrix: viewMatrixUncentered,
      longitude,
      latitude,
      zoom,
      ...projectionParameters,
      fovy,
      focalDistance: altitude
    });

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "longitude", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "latitude", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "pitch", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "bearing", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "altitude", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "fovy", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "orthographic", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_subViewports", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_pseudoMeters", void 0);

    this.latitude = latitude;
    this.longitude = longitude;
    this.zoom = zoom;
    this.pitch = pitch;
    this.bearing = bearing;
    this.altitude = altitude;
    this.fovy = fovy;
    this.orthographic = orthographic;
    this._subViewports = repeat ? [] : null;
    this._pseudoMeters = legacyMeterSizes;
    Object.freeze(this);
  }

  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const bounds = this.getBounds();
      const minOffset = Math.floor((bounds[0] + 180) / 360);
      const maxOffset = Math.ceil((bounds[2] - 180) / 360);

      for (let x = minOffset; x <= maxOffset; x++) {
        const offsetViewport = x ? new WebMercatorViewport({ ...this,
          worldOffset: x
        }) : this;

        this._subViewports.push(offsetViewport);
      }
    }

    return this._subViewports;
  }

  projectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.projectPosition(xyz);
    }

    const [X, Y] = this.projectFlat(xyz);
    const Z = (xyz[2] || 0) * (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.unitsPerMeter)(xyz[1]);
    return [X, Y, Z];
  }

  unprojectPosition(xyz) {
    if (this._pseudoMeters) {
      return super.unprojectPosition(xyz);
    }

    const [X, Y] = this.unprojectFlat(xyz);
    const Z = (xyz[2] || 0) / (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.unitsPerMeter)(Y);
    return [X, Y, Z];
  }

  addMetersToLngLat(lngLatZ, xyz) {
    return (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.addMetersToLngLat)(lngLatZ, xyz);
  }

  panByPosition(coords, pixel) {
    const fromLocation = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.pixelsToWorld)(pixel, this.pixelUnprojectionMatrix);
    const toLocation = this.projectFlat(coords);
    const translate = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_5__.add([], toLocation, gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_5__.negate([], fromLocation));
    const newCenter = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_5__.add([], this.center, translate);
    const [longitude, latitude] = this.unprojectFlat(newCenter);
    return {
      longitude,
      latitude
    };
  }

  getBounds(options = {}) {
    const corners = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.getBounds)(this, options.z || 0);
    return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
  }

  fitBounds(bounds, options = {}) {
    const {
      width,
      height
    } = this;
    const {
      longitude,
      latitude,
      zoom
    } = (0,_math_gl_web_mercator__WEBPACK_IMPORTED_MODULE_1__.fitBounds)({
      width,
      height,
      bounds,
      ...options
    });
    return new WebMercatorViewport({
      width,
      height,
      longitude,
      latitude,
      zoom
    });
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(WebMercatorViewport, "displayName", 'WebMercatorViewport');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/views/first-person-view.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/views/first-person-view.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FirstPersonView)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@deck.gl/core/dist/esm/views/view.js");
/* harmony import */ var _viewports_first_person_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/first-person-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/first-person-viewport.js");
/* harmony import */ var _controllers_first_person_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/first-person-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/first-person-controller.js");




class FirstPersonView extends _view__WEBPACK_IMPORTED_MODULE_1__["default"] {
  get ViewportType() {
    return _viewports_first_person_viewport__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  get ControllerType() {
    return _controllers_first_person_controller__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(FirstPersonView, "displayName", 'FirstPersonView');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/views/globe-view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/views/globe-view.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GlobeView)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@deck.gl/core/dist/esm/views/view.js");
/* harmony import */ var _viewports_globe_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/globe-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/globe-viewport.js");
/* harmony import */ var _controllers_globe_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/globe-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/globe-controller.js");




class GlobeView extends _view__WEBPACK_IMPORTED_MODULE_1__["default"] {
  get ViewportType() {
    return _viewports_globe_viewport__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  get ControllerType() {
    return _controllers_globe_controller__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(GlobeView, "displayName", 'GlobeView');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/views/map-view.js":
/*!***************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/views/map-view.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MapView)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@deck.gl/core/dist/esm/views/view.js");
/* harmony import */ var _viewports_web_mercator_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/web-mercator-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js");
/* harmony import */ var _controllers_map_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/map-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js");




class MapView extends _view__WEBPACK_IMPORTED_MODULE_1__["default"] {
  get ViewportType() {
    return _viewports_web_mercator_viewport__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  get ControllerType() {
    return _controllers_map_controller__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(MapView, "displayName", 'MapView');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/views/orbit-view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/views/orbit-view.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrbitView)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@deck.gl/core/dist/esm/views/view.js");
/* harmony import */ var _viewports_orbit_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/orbit-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/orbit-viewport.js");
/* harmony import */ var _controllers_orbit_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/orbit-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/orbit-controller.js");




class OrbitView extends _view__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(props = {}) {
    super(props);
    this.props.orbitAxis = props.orbitAxis || 'Z';
  }

  get ViewportType() {
    return _viewports_orbit_viewport__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  get ControllerType() {
    return _controllers_orbit_controller__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(OrbitView, "displayName", 'OrbitView');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/views/orthographic-view.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ OrthographicView)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./view */ "./node_modules/@deck.gl/core/dist/esm/views/view.js");
/* harmony import */ var _viewports_orthographic_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/orthographic-viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/orthographic-viewport.js");
/* harmony import */ var _controllers_orthographic_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/orthographic-controller */ "./node_modules/@deck.gl/core/dist/esm/controllers/orthographic-controller.js");




class OrthographicView extends _view__WEBPACK_IMPORTED_MODULE_1__["default"] {
  get ViewportType() {
    return _viewports_orthographic_viewport__WEBPACK_IMPORTED_MODULE_2__["default"];
  }

  get ControllerType() {
    return _controllers_orthographic_controller__WEBPACK_IMPORTED_MODULE_3__["default"];
  }

}

(0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(OrthographicView, "displayName", 'OrthographicView');


/***/ }),

/***/ "./node_modules/@deck.gl/core/dist/esm/views/view.js":
/*!***********************************************************!*\
  !*** ./node_modules/@deck.gl/core/dist/esm/views/view.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _viewports_viewport__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../viewports/viewport */ "./node_modules/@deck.gl/core/dist/esm/viewports/viewport.js");
/* harmony import */ var _utils_positions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/positions */ "./node_modules/@deck.gl/core/dist/esm/utils/positions.js");
/* harmony import */ var _utils_deep_equal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/deep-equal */ "./node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "./node_modules/@deck.gl/core/dist/esm/utils/assert.js");





class View {
  constructor(props) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "id", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "viewportInstance", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_x", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_y", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_width", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_height", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "_padding", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "props", void 0);

    const {
      id,
      x = 0,
      y = 0,
      width = '100%',
      height = '100%',
      padding = null,
      viewportInstance
    } = props || {};
    (0,_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(!viewportInstance || viewportInstance instanceof _viewports_viewport__WEBPACK_IMPORTED_MODULE_2__["default"]);
    this.viewportInstance = viewportInstance;
    this.id = id || this.constructor.displayName || 'view';
    this.props = { ...props,
      id: this.id
    };
    this._x = (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(x);
    this._y = (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(y);
    this._width = (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(width);
    this._height = (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(height);
    this._padding = padding && {
      left: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(padding.left || 0),
      right: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(padding.right || 0),
      top: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(padding.top || 0),
      bottom: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.parsePosition)(padding.bottom || 0)
    };
    this.equals = this.equals.bind(this);
    Object.seal(this);
  }

  equals(view) {
    if (this === view) {
      return true;
    }

    if (this.viewportInstance) {
      return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
    }

    return this.ViewportType === view.ViewportType && (0,_utils_deep_equal__WEBPACK_IMPORTED_MODULE_4__.deepEqual)(this.props, view.props, 2);
  }

  makeViewport({
    width,
    height,
    viewState
  }) {
    if (this.viewportInstance) {
      return this.viewportInstance;
    }

    viewState = this.filterViewState(viewState);
    const viewportDimensions = this.getDimensions({
      width,
      height
    });

    if (!viewportDimensions.height || !viewportDimensions.width) {
      return null;
    }

    return new this.ViewportType({ ...viewState,
      ...this.props,
      ...viewportDimensions
    });
  }

  getViewStateId() {
    const {
      viewState
    } = this.props;

    if (typeof viewState === 'string') {
      return viewState;
    }

    return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
  }

  filterViewState(viewState) {
    if (this.props.viewState && typeof this.props.viewState === 'object') {
      if (!this.props.viewState.id) {
        return this.props.viewState;
      }

      const newViewState = { ...viewState
      };

      for (const key in this.props.viewState) {
        if (key !== 'id') {
          newViewState[key] = this.props.viewState[key];
        }
      }

      return newViewState;
    }

    return viewState;
  }

  getDimensions({
    width,
    height
  }) {
    const dimensions = {
      x: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._x, width),
      y: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._y, height),
      width: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._width, width),
      height: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._height, height)
    };

    if (this._padding) {
      dimensions.padding = {
        left: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._padding.left, width),
        top: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._padding.top, height),
        right: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._padding.right, width),
        bottom: (0,_utils_positions__WEBPACK_IMPORTED_MODULE_3__.getPosition)(this._padding.bottom, height)
      };
    }

    return dimensions;
  }

  get controller() {
    const opts = this.props.controller;

    if (!opts) {
      return null;
    }

    if (opts === true) {
      return {
        type: this.ControllerType
      };
    }

    if (typeof opts === 'function') {
      return {
        type: opts
      };
    }

    return {
      type: this.ControllerType,
      ...opts
    };
  }

}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/image-loader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/image-loader.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageLoader": () => (/* binding */ ImageLoader),
/* harmony export */   "_typecheckImageLoader": () => (/* binding */ _typecheckImageLoader)
/* harmony export */ });
/* harmony import */ var _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/utils/version */ "./node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js");
/* harmony import */ var _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/parsers/parse-image */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js");
/* harmony import */ var _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/category-api/binary-image-api */ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js");



const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg', 'avif'];
const MIME_TYPES = ['image/png', 'image/jpeg', 'image/gif', 'image/webp', 'image/avif', 'image/bmp', 'image/vnd.microsoft.icon', 'image/svg+xml'];
const DEFAULT_IMAGE_LOADER_OPTIONS = {
  image: {
    type: 'auto',
    decode: true
  }
};
const ImageLoader = {
  id: 'image',
  module: 'images',
  name: 'Images',
  version: _lib_utils_version__WEBPACK_IMPORTED_MODULE_0__.VERSION,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"],
  tests: [arrayBuffer => Boolean((0,_lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__.getBinaryImageMetadata)(new DataView(arrayBuffer)))],
  options: DEFAULT_IMAGE_LOADER_OPTIONS
};
const _typecheckImageLoader = ImageLoader;


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getBinaryImageMetadata": () => (/* binding */ getBinaryImageMetadata),
/* harmony export */   "getBmpMetadata": () => (/* binding */ getBmpMetadata)
/* harmony export */ });
/* harmony import */ var _parse_isobmff_binary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-isobmff-binary */ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js");

const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;
function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
}
function getISOBMFFMetadata(binaryData) {
  const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
  const mediaType = (0,_parse_isobmff_binary__WEBPACK_IMPORTED_MODULE_0__.getISOBMFFMediaType)(buffer);
  if (!mediaType) {
    return null;
  }
  return {
    mimeType: mediaType.mimeType,
    width: 0,
    height: 0
  };
}
function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
  if (!isPng) {
    return null;
  }
  return {
    mimeType: 'image/png',
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
  if (!isGif) {
    return null;
  }
  return {
    mimeType: 'image/gif',
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 0x424d && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
  if (!isBmp) {
    return null;
  }
  return {
    mimeType: 'image/bmp',
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 && dataView.getUint8(2) === 0xff;
  if (!isJpeg) {
    return null;
  }
  const {
    tableMarkers,
    sofMarkers
  } = getJpegMarkers();
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);
    if (sofMarkers.has(marker)) {
      return {
        mimeType: 'image/jpeg',
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }
    if (!tableMarkers.has(marker)) {
      return null;
    }
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }
  return null;
}
function getJpegMarkers() {
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }
  const sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers,
    sofMarkers
  };
}
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error('toDataView');
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultImageType": () => (/* binding */ getDefaultImageType),
/* harmony export */   "isImageTypeSupported": () => (/* binding */ isImageTypeSupported)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js");

const {
  _parseImageNode
} = globalThis;
const IMAGE_SUPPORTED = typeof Image !== 'undefined';
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
const DATA_SUPPORTED = _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__.isBrowser ? true : NODE_IMAGE_SUPPORTED;
function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;
    case 'image':
      return IMAGE_SUPPORTED;
    case 'data':
      return DATA_SUPPORTED;
    default:
      throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
  }
}
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return 'imagebitmap';
  }
  if (IMAGE_SUPPORTED) {
    return 'image';
  }
  if (DATA_SUPPORTED) {
    return 'data';
  }
  throw new Error('Install \'@loaders.gl/polyfills\' to parse images under Node.js');
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decodeMajorBrand": () => (/* binding */ decodeMajorBrand),
/* harmony export */   "getISOBMFFMediaType": () => (/* binding */ getISOBMFFMediaType)
/* harmony export */ });
function getISOBMFFMediaType(buffer) {
  if (!checkString(buffer, 'ftyp', 4)) {
    return null;
  }
  if ((buffer[8] & 0x60) === 0x00) {
    return null;
  }
  return decodeMajorBrand(buffer);
}
function decodeMajorBrand(buffer) {
  const brandMajor = getUTF8String(buffer, 8, 12).replace('\0', ' ').trim();
  switch (brandMajor) {
    case 'avif':
    case 'avis':
      return {
        extension: 'avif',
        mimeType: 'image/avif'
      };
    default:
      return null;
  }
}
function getUTF8String(array, start, end) {
  return String.fromCharCode(...array.slice(start, end));
}
function stringToBytes(string) {
  return [...string].map(character => character.charCodeAt(0));
}
function checkString(buffer, header) {
  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  const headerBytes = stringToBytes(header);
  for (let i = 0; i < headerBytes.length; ++i) {
    if (headerBytes[i] !== buffer[i + offset]) {
      return false;
    }
  }
  return true;
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "deleteImage": () => (/* binding */ deleteImage),
/* harmony export */   "getImageData": () => (/* binding */ getImageData),
/* harmony export */   "getImageSize": () => (/* binding */ getImageSize),
/* harmony export */   "getImageType": () => (/* binding */ getImageType),
/* harmony export */   "isImage": () => (/* binding */ isImage)
/* harmony export */ });
function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}
function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;
    default:
  }
}
function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error('Not an image');
  }
  return format;
}
function getImageSize(image) {
  return getImageData(image);
}
function getImageData(image) {
  switch (getImageType(image)) {
    case 'data':
      return image;
    case 'image':
    case 'imagebitmap':
      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      if (!context) {
        throw new Error('getImageData');
      }
      canvas.width = image.width;
      canvas.height = image.height;
      context.drawImage(image, 0, 0);
      return context.getImageData(0, 0, image.width, image.height);
    default:
      throw new Error('getImageData');
  }
}
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }
  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'image';
  }
  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    return 'data';
  }
  return null;
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseImage)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js");
/* harmony import */ var _category_api_image_type__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../category-api/image-type */ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-to-image */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js");
/* harmony import */ var _parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse-to-image-bitmap */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js");
/* harmony import */ var _parse_to_node_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parse-to-node-image */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js");






async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};
  const imageType = imageOptions.type || 'auto';
  const {
    url
  } = context || {};
  const loadType = getLoadableImageType(imageType);
  let image;
  switch (loadType) {
    case 'imagebitmap':
      image = await (0,_parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_0__["default"])(arrayBuffer, options, url);
      break;
    case 'image':
      image = await (0,_parse_to_image__WEBPACK_IMPORTED_MODULE_1__["default"])(arrayBuffer, options, url);
      break;
    case 'data':
      image = await (0,_parse_to_node_image__WEBPACK_IMPORTED_MODULE_2__["default"])(arrayBuffer, options);
      break;
    default:
      (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_3__.assert)(false);
  }
  if (imageType === 'data') {
    image = (0,_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__.getImageData)(image);
  }
  return image;
}
function getLoadableImageType(type) {
  switch (type) {
    case 'auto':
    case 'data':
      return (0,_category_api_image_type__WEBPACK_IMPORTED_MODULE_5__.getDefaultImageType)();
    default:
      (0,_category_api_image_type__WEBPACK_IMPORTED_MODULE_5__.isImageTypeSupported)(type);
      return type;
  }
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseToImageBitmap)
/* harmony export */ });
/* harmony import */ var _svg_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg-utils */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-to-image */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js");


const EMPTY_OBJECT = {};
let imagebitmapOptionsSupported = true;
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;
  if ((0,_svg_utils__WEBPACK_IMPORTED_MODULE_0__.isSVG)(url)) {
    const image = await (0,_parse_to_image__WEBPACK_IMPORTED_MODULE_1__["default"])(arrayBuffer, options, url);
    blob = image;
  } else {
    blob = (0,_svg_utils__WEBPACK_IMPORTED_MODULE_0__.getBlob)(arrayBuffer, url);
  }
  const imagebitmapOptions = options && options.imagebitmap;
  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}
async function safeCreateImageBitmap(blob) {
  let imagebitmapOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }
  if (imagebitmapOptions) {
    try {
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error);
      imagebitmapOptionsSupported = false;
    }
  }
  return await createImageBitmap(blob);
}
function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseToImage),
/* harmony export */   "loadToImage": () => (/* binding */ loadToImage)
/* harmony export */ });
/* harmony import */ var _svg_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg-utils */ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js");

async function parseToImage(arrayBuffer, options, url) {
  const blobOrDataUrl = (0,_svg_utils__WEBPACK_IMPORTED_MODULE_0__.getBlobOrSVGDataUrl)(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}
async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
    } catch (error) {
      reject(error);
    }
  });
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseToNodeImage)
/* harmony export */ });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "./node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js");
/* harmony import */ var _category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../category-api/binary-image-api */ "./node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js");


async function parseToNodeImage(arrayBuffer, options) {
  const {
    mimeType
  } = (0,_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_0__.getBinaryImageMetadata)(arrayBuffer) || {};
  const _parseImageNode = globalThis._parseImageNode;
  (0,_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__.assert)(_parseImageNode);
  return await _parseImageNode(arrayBuffer, mimeType);
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getBlob": () => (/* binding */ getBlob),
/* harmony export */   "getBlobOrSVGDataUrl": () => (/* binding */ getBlobOrSVGDataUrl),
/* harmony export */   "isSVG": () => (/* binding */ isSVG)
/* harmony export */ });
const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}
function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    const textDecoder = new TextDecoder();
    let xmlText = textDecoder.decode(arrayBuffer);
    try {
      if (typeof unescape === 'function' && typeof encodeURIComponent === 'function') {
        xmlText = unescape(encodeURIComponent(xmlText));
      }
    } catch (error) {
      throw new Error(error.message);
    }
    const src = "data:image/svg+xml;base64,".concat(btoa(xmlText));
    return src;
  }
  return getBlob(arrayBuffer, url);
}
function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    throw new Error('SVG cannot be parsed directly to imagebitmap');
  }
  return new Blob([new Uint8Array(arrayBuffer)]);
}


/***/ }),

/***/ "./node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VERSION": () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION =  true ? "3.4.0" : 0;


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/animation/timeline.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/animation/timeline.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Timeline": () => (/* binding */ Timeline)
/* harmony export */ });
let channelHandles = 1;
let animationHandles = 1;
class Timeline {
  constructor() {
    this.time = 0;
    this.channels = new Map();
    this.animations = new Map();
    this.playing = false;
    this.lastEngineTime = -1;
  }

  addChannel(props) {
    const {
      delay = 0,
      duration = Number.POSITIVE_INFINITY,
      rate = 1,
      repeat = 1
    } = props;
    const handle = channelHandles++;
    const channel = {
      time: 0,
      delay,
      duration,
      rate,
      repeat
    };

    this._setChannelTime(channel, this.time);

    this.channels.set(handle, channel);
    return handle;
  }

  removeChannel(handle) {
    this.channels.delete(handle);

    for (const [animationHandle, animation] of this.animations) {
      if (animation.channel === handle) {
        this.detachAnimation(animationHandle);
      }
    }
  }

  isFinished(handle) {
    const channel = this.channels.get(handle);

    if (channel === undefined) {
      return false;
    }

    return this.time >= channel.delay + channel.duration * channel.repeat;
  }

  getTime(handle) {
    if (handle === undefined) {
      return this.time;
    }

    const channel = this.channels.get(handle);

    if (channel === undefined) {
      return -1;
    }

    return channel.time;
  }

  setTime(time) {
    this.time = Math.max(0, time);
    const channels = this.channels.values();

    for (const channel of channels) {
      this._setChannelTime(channel, this.time);
    }

    const animations = this.animations.values();

    for (const animationData of animations) {
      const {
        animation,
        channel
      } = animationData;
      animation.setTime(this.getTime(channel));
    }
  }

  play() {
    this.playing = true;
  }

  pause() {
    this.playing = false;
    this.lastEngineTime = -1;
  }

  reset() {
    this.setTime(0);
  }

  attachAnimation(animation, channelHandle) {
    const animationHandle = animationHandles++;
    this.animations.set(animationHandle, {
      animation,
      channel: channelHandle
    });
    animation.setTime(this.getTime(channelHandle));
    return animationHandle;
  }

  detachAnimation(handle) {
    this.animations.delete(handle);
  }

  update(engineTime) {
    if (this.playing) {
      if (this.lastEngineTime === -1) {
        this.lastEngineTime = engineTime;
      }

      this.setTime(this.time + (engineTime - this.lastEngineTime));
      this.lastEngineTime = engineTime;
    }
  }

  _setChannelTime(channel, time) {
    const offsetTime = time - channel.delay;
    const totalDuration = channel.duration * channel.repeat;

    if (offsetTime >= totalDuration) {
      channel.time = channel.duration * channel.rate;
    } else {
      channel.time = Math.max(0, offsetTime) % channel.duration;
      channel.time *= channel.rate;
    }
  }

}


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AnimationLoop)
/* harmony export */ });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/init.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/query.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _probe_gl_env__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @probe.gl/env */ "./node_modules/@probe.gl/env/dist/esm/lib/is-browser.js");



const isPage = (0,_probe_gl_env__WEBPACK_IMPORTED_MODULE_1__["default"])() && typeof document !== 'undefined';
let statIdCounter = 0;
class AnimationLoop {
  constructor() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      onCreateContext = opts => (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.createGLContext)(opts),
      onAddHTML = null,
      onInitialize = () => {},
      onRender = () => {},
      onFinalize = () => {},
      onError,
      gl = null,
      glOptions = {},
      debug = false,
      createFramebuffer = false,
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__.lumaStats.get("animation-loop-".concat(statIdCounter++))
    } = props;
    let {
      useDevicePixels = true
    } = props;

    if ('useDevicePixelRatio' in props) {
      _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();
      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,
      onError,
      gl,
      glOptions,
      debug,
      createFramebuffer
    };
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');
    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;
    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this._pageLoadPromise = null;
    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }

  delete() {
    this.stop();

    this._setDisplay(null);
  }

  setNeedsRedraw(reason) {
    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__.assert)(typeof reason === 'string');
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }

  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }

    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }

    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }

    return this;
  }

  start() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if (this._running) {
      return this;
    }

    this._running = true;

    const startPromise = this._getPageLoadPromise().then(() => {
      if (!this._running || this._initialized) {
        return null;
      }

      this._createWebGLContext(opts);

      this._createFramebuffer();

      this._startEventHandling();

      this._initializeCallbackData();

      this._updateCallbackData();

      this._resizeCanvasDrawingBuffer();

      this._resizeViewport();

      this._gpuTimeQuery = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["default"].isSupported(this.gl, ['timers']) ? new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["default"](this.gl) : null;
      this._initialized = true;
      return this.onInitialize(this.animationProps);
    }).then(appContext => {
      if (this._running) {
        this._addCallbackData(appContext || {});

        if (appContext !== false) {
          this._startLoop();
        }
      }
    });

    if (this.props.onError) {
      startPromise.catch(this.props.onError);
    }

    return this;
  }

  redraw() {
    if (this.isContextLost()) {
      return this;
    }

    this._beginTimers();

    this._setupFrame();

    this._updateCallbackData();

    this._renderFrame(this.animationProps);

    this._clearNeedsRedraw();

    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }

    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);

      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }

    this._endTimers();

    return this;
  }

  stop() {
    if (this._running) {
      this._finalizeCallbackData();

      this._cancelAnimationFrame(this._animationFrameId);

      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }

    return this;
  }

  attachTimeline(timeline) {
    this.timeline = timeline;
    return this.timeline;
  }

  detachTimeline() {
    this.timeline = null;
  }

  waitForRender() {
    this.setNeedsRedraw('waitForRender');

    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }

    return this._nextFramePromise;
  }

  async toDataURL() {
    this.setNeedsRedraw('toDataURL');
    await this.waitForRender();
    return this.gl.canvas.toDataURL();
  }

  isContextLost() {
    return this.gl.isContextLost();
  }

  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }

  onInitialize() {
    return this.props.onInitialize(...arguments);
  }

  onRender() {
    return this.props.onRender(...arguments);
  }

  onFinalize() {
    return this.props.onFinalize(...arguments);
  }

  getHTMLControlValue(id) {
    let defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }

  setViewParameters() {
    _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.log.removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();
    return this;
  }

  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }

      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };

    this._cancelAnimationFrame(this._animationFrameId);

    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }

  _getPageLoadPromise() {
    if (!this._pageLoadPromise) {
      this._pageLoadPromise = isPage ? new Promise((resolve, reject) => {
        if (isPage && document.readyState === 'complete') {
          resolve(document);
          return;
        }

        window.addEventListener('load', () => {
          resolve(document);
        });
      }) : Promise.resolve({});
    }

    return this._pageLoadPromise;
  }

  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }

    if (display) {
      display.animationLoop = this;
    }

    this.display = display;
  }

  _cancelAnimationFrame(animationFrameId) {
    if (this.display && this.display.cancelAnimationFrame) {
      return this.display.cancelAnimationFrame(animationFrameId);
    }

    return (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__.cancelAnimationFrame)(animationFrameId);
  }

  _requestAnimationFrame(renderFrameCallback) {
    if (this._running) {
      if (this.display && this.display.requestAnimationFrame) {
        return this.display.requestAnimationFrame(renderFrameCallback);
      }

      return (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__.requestAnimationFrame)(renderFrameCallback);
    }

    return undefined;
  }

  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);

      return;
    }

    this.onRender(...arguments);
  }

  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }

  _setupFrame() {
    this._resizeCanvasDrawingBuffer();

    this._resizeViewport();

    this._resizeFramebuffer();
  }

  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }

  _updateCallbackData() {
    const {
      width,
      height,
      aspect
    } = this._getSizeAndAspect();

    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }

    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }

    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;
    this.animationProps.needsRedraw = this.needsRedraw;
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;

    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }

    this.animationProps.tick = Math.floor(this.animationProps.time / 1000 * 60);
    this.animationProps.tock++;
    this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    this.animationProps._offScreen = this.offScreen;
  }

  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }

  _addCallbackData(appContext) {
    if (typeof appContext === 'object' && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }

  _createWebGLContext(opts) {
    this.offScreen = opts.canvas && typeof OffscreenCanvas !== 'undefined' && opts.canvas instanceof OffscreenCanvas;
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.instrumentGLContext)(this.props.gl, opts) : this.onCreateContext(opts);

    if (!(0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.isWebGL)(this.gl)) {
      throw new Error('AnimationLoop.onCreateContext - illegal context returned');
    }

    (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.resetParameters)(this.gl);

    this._createInfoDiv();
  }

  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);

      if (html) {
        div.innerHTML = html;
      }
    }
  }

  _getSizeAndAspect() {
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;
    let aspect = 1;
    const {
      canvas
    } = this.gl;

    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }

    return {
      width,
      height,
      aspect
    };
  }

  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }

  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.resizeGLContext)(this.gl, {
        useDevicePixels: this.useDevicePixels
      });
    }
  }

  _createFramebuffer() {
    if (this.props.createFramebuffer) {
      this.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_6__["default"](this.gl);
    }
  }

  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }

  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();

    if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }

    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }

    this.cpuTime.timeStart();
  }

  _endTimers() {
    this.cpuTime.timeEnd();

    if (this._gpuTimeQuery) {
      this._gpuTimeQuery.end();
    }
  }

  _startEventHandling() {
    const {
      canvas
    } = this.gl;

    if (canvas) {
      canvas.addEventListener('mousemove', this._onMousemove);
      canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }

  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }

  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }

}


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BufferTransform)
/* harmony export */ });
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");



class BufferTransform {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }

  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      varyings
    } = this;

    if (varyings.length > 0) {
      props = Object.assign({}, props, {
        varyings
      });
    }

    return props;
  }

  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const binding = this.bindings[this.currentIndex];
    const {
      sourceBuffers,
      transformFeedback
    } = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    return {
      attributes,
      transformFeedback
    };
  }

  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }

    return false;
  }

  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._setupBuffers(opts);
  }

  getBuffer(varyingName) {
    const {
      feedbackBuffers
    } = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;

    if (!bufferOrParams) {
      return null;
    }

    return bufferOrParams instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["default"] ? bufferOrParams : bufferOrParams.buffer;
  }

  getData() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      varyingName
    } = options;
    const buffer = this.getBuffer(varyingName);

    if (buffer) {
      return buffer.getData();
    }

    return null;
  }

  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }

  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._setupBuffers(props);

    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);

    if (this.varyings.length > 0) {
      (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__.assert)((0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.isWebGL2)(this.gl));
    }
  }

  _getFeedbackBuffers(props) {
    const {
      sourceBuffers = {}
    } = props;
    const feedbackBuffers = {};

    if (this.bindings[this.currentIndex]) {
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }

    if (this.feedbackMap) {
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];

        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }

    Object.assign(feedbackBuffers, props.feedbackBuffers);

    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];

      if (typeof bufferOrRef === 'string') {
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {
          byteLength,
          usage,
          accessor
        } = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }

    return feedbackBuffers;
  }

  _setupBuffers() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers = null
    } = props;
    Object.assign(this.feedbackMap, props.feedbackMap);

    const feedbackBuffers = this._getFeedbackBuffers(props);

    this._updateBindings({
      sourceBuffers,
      feedbackBuffers
    });
  }

  _setupTransformFeedback(binding, _ref) {
    let {
      model
    } = _ref;
    const {
      program
    } = model;
    binding.transformFeedback = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

    if (this.feedbackMap) {
      const {
        sourceBuffers,
        feedbackBuffers
      } = this._swapBuffers(this.bindings[this.currentIndex]);

      const nextIndex = this._getNextIndex();

      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }

  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }

    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);

    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }

    return binding;
  }

  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }

    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);

    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
      (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_2__.assert)(feedbackBuffers[dstName] instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["default"]);
    }

    return {
      sourceBuffers,
      feedbackBuffers
    };
  }

  _createNewBuffer(name, opts) {
    const buffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["default"](this.gl, opts);

    if (this.resources[name]) {
      this.resources[name].delete();
    }

    this.resources[name] = buffer;
    return buffer;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

}


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextureTransform)
/* harmony export */ });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/shadertools */ "./node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/shadertools */ "./node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @luma.gl/shadertools */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js");
/* harmony import */ var _transform_shader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform-shader-utils */ "./node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js");



const SRC_TEX_PARAMETER_OVERRIDES = {
  [10241]: 9728,
  [10240]: 9728,
  [10242]: 33071,
  [10243]: 33071
};
const FS_OUTPUT_VARIABLE = 'transform_output';
class TextureTransform {
  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.id = this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = [];
    this.resources = {};

    this._initialize(props);

    Object.seal(this);
  }

  updateModelProps() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    const updatedModelProps = this._processVertexShader(props);

    return Object.assign({}, props, updatedModelProps);
  }

  getDrawOptions() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers,
      sourceTextures,
      framebuffer,
      targetTexture
    } = this.bindings[this.currentIndex];
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;

    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;

      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }

      this._setSourceTextureParameters();

      const sizeUniforms = (0,_transform_shader_utils__WEBPACK_IMPORTED_MODULE_0__.getSizeUniforms)({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }

    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }

    return {
      attributes,
      framebuffer,
      uniforms,
      discard,
      parameters
    };
  }

  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }

    return false;
  }

  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._setupTextures(opts);
  }

  getTargetTexture() {
    const {
      targetTexture
    } = this.bindings[this.currentIndex];
    return targetTexture;
  }

  getData() {
    let {
      packed = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      framebuffer
    } = this.bindings[this.currentIndex];
    const pixels = (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__.readPixelsToArray)(framebuffer);

    if (!packed) {
      return pixels;
    }

    const ArrayType = pixels.constructor;
    const channelCount = (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__.typeToChannelCount)(this.targetTextureType);
    const packedPixels = new ArrayType(pixels.length * channelCount / 4);
    let packCount = 0;

    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }

    return packedPixels;
  }

  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }

  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }

    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }

  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      _targetTextureVarying,
      _swapTexture
    } = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;

    this._setupTextures(props);
  }

  _createTargetTexture(props) {
    const {
      sourceTextures,
      textureOrReference
    } = props;

    if (textureOrReference instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_3__["default"]) {
      return textureOrReference;
    }

    const refTexture = sourceTextures[textureOrReference];

    if (!refTexture) {
      return null;
    }

    this._targetRefTexName = textureOrReference;
    return this._createNewTexture(refTexture);
  }

  _setupTextures() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceBuffers,
      _sourceTextures = {},
      _targetTexture
    } = props;

    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });

    this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;

    this._updateBindings({
      sourceBuffers,
      sourceTextures: _sourceTextures,
      targetTexture
    });

    if ('elementCount' in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }

  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {
      return;
    }

    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });

    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["default"](this.gl, {
        data: elementIds,
        accessor: {
          size: 1
        }
      });
    } else {
      this.elementIDBuffer.setData({
        data: elementIds
      });
    }

    this.elementCount = elementCount;
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);

    if (this._swapTexture) {
      const {
        sourceTextures,
        targetTexture
      } = this._swapTextures(this.bindings[this.currentIndex]);

      const nextIndex = this._getNextIndex();

      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }

  _updateBinding(binding, opts) {
    const {
      sourceBuffers,
      sourceTextures,
      targetTexture
    } = opts;

    if (!binding) {
      binding = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      };
    }

    Object.assign(binding.sourceTextures, sourceTextures);
    Object.assign(binding.sourceBuffers, sourceBuffers);

    if (targetTexture) {
      binding.targetTexture = targetTexture;
      const {
        width,
        height
      } = targetTexture;
      const {
        framebuffer
      } = binding;

      if (framebuffer) {
        framebuffer.update({
          attachments: {
            [36064]: targetTexture
          },
          resizeAttachments: false
        });
        framebuffer.resize({
          width,
          height
        });
      } else {
        binding.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_5__["default"](this.gl, {
          id: "transform-framebuffer",
          width,
          height,
          attachments: {
            [36064]: targetTexture
          }
        });
      }
    }

    return binding;
  }

  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {
      sourceTextures
    } = this.bindings[index];

    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }

  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }

    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;
    const targetTexture = opts.sourceTextures[this._swapTexture];
    return {
      sourceTextures,
      targetTexture
    };
  }

  _createNewTexture(refTexture) {
    const texture = (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_6__.cloneTextureFrom)(refTexture, {
      parameters: {
        [10241]: 9728,
        [10240]: 9728,
        [10242]: 33071,
        [10243]: 33071
      },
      pixelStore: {
        [37440]: false
      }
    });

    if (this.ownTexture) {
      this.ownTexture.delete();
    }

    this.ownTexture = texture;
    return texture;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

  _processVertexShader() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      sourceTextures,
      targetTexture
    } = this.bindings[this.currentIndex];
    const {
      vs,
      uniforms,
      targetTextureType,
      inject,
      samplerTextureMap
    } = (0,_transform_shader_utils__WEBPACK_IMPORTED_MODULE_0__.updateForTextures)({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_7__.combineInjects)([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs = props._fs || (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__.getPassthroughFS)({
      version: (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_8__["default"])(vs),
      input: this.targetTextureVarying,
      inputType: targetTextureType,
      output: FS_OUTPUT_VARIABLE
    });
    const modules = this.hasSourceTextures || this.targetTextureVarying ? [_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_9__.transform].concat(props.modules || []) : props.modules;
    return {
      vs,
      fs,
      modules,
      uniforms,
      inject: combinedInject
    };
  }

}


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSizeUniforms": () => (/* binding */ getSizeUniforms),
/* harmony export */   "getVaryingType": () => (/* binding */ getVaryingType),
/* harmony export */   "processAttributeDefinition": () => (/* binding */ processAttributeDefinition),
/* harmony export */   "updateForTextures": () => (/* binding */ updateForTextures)
/* harmony export */ });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/shadertools */ "./node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/shadertools */ "./node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js");


const SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
const SIZE_UNIFORM_PREFIX = 'transform_uSize_';
const VS_POS_VARIABLE = 'transform_position';
function updateForTextures(_ref) {
  let {
    vs,
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref;
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs;
  let finalInject = {};

  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split('\n');
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);

        if (updated) {
          const {
            updatedLine,
            inject
          } = updated;
          updateVsLines[index] = updatedLine;
          finalInject = (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__.combineInjects)([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }

      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });

    if (targetTextureVarying) {
      (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__.assert)(targetTexture);
      const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
      const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
      const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
      const inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__.combineInjects)([finalInject, inject]);
    }

    updatedVs = updateVsLines.join('\n');
  }

  return {
    vs: updatedVs,
    targetTextureType,
    inject: finalInject,
    samplerTextureMap
  };
}
function getSizeUniforms(_ref2) {
  let {
    sourceTextureMap,
    targetTextureVarying,
    targetTexture
  } = _ref2;
  const uniforms = {};
  let width;
  let height;

  if (targetTextureVarying) {
    ({
      width,
      height
    } = targetTexture);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width, height];
  }

  for (const textureName in sourceTextureMap) {
    ({
      width,
      height
    } = sourceTextureMap[textureName]);
    uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width, height];
  }

  return uniforms;
}

function getAttributeDefinition(line) {
  return (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__.getQualifierDetails)(line, ['attribute', 'in']);
}

function getSamplerDeclerations(textureName) {
  const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
  const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
  const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
  return {
    samplerName,
    sizeName,
    uniformDeclerations
  };
}

function getVaryingType(line, varying) {
  const qualaiferDetails = (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__.getQualifierDetails)(line, ['varying', 'out']);

  if (!qualaiferDetails) {
    return null;
  }

  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);

  if (!attributeData) {
    return null;
  }

  const {
    type,
    name
  } = attributeData;

  if (name && textureMap[name]) {
    const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
    const {
      samplerName,
      sizeName,
      uniformDeclerations
    } = getSamplerDeclerations(name);
    const channels = (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__.typeToChannelSuffix)(type);
    const sampleInstruction = "  ".concat(type, " ").concat(name, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
    samplerTextureMap[samplerName] = name;
    const inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };
    return {
      updatedLine,
      inject,
      samplerTextureMap
    };
  }

  return null;
}


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/transform/transform.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/transform/transform.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Transform)
/* harmony export */ });
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/shadertools */ "./node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js");
/* harmony import */ var _buffer_transform__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./buffer-transform */ "./node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js");
/* harmony import */ var _texture_transform__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./texture-transform */ "./node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/webgl */ "./node_modules/@luma.gl/webgl/dist/esm/utils/utils.js");
/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/model */ "./node_modules/@luma.gl/engine/dist/esm/lib/model.js");






class Transform {
  static isSupported(gl) {
    return (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.isWebGL2)(gl);
  }

  constructor(gl) {
    let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;

    this._initialize(props);

    Object.seal(this);
  }

  delete() {
    const {
      model,
      bufferTransform,
      textureTransform
    } = this;

    if (model) {
      model.delete();
    }

    if (bufferTransform) {
      bufferTransform.delete();
    }

    if (textureTransform) {
      textureTransform.delete();
    }
  }

  run() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      clearRenderTarget = true
    } = opts;

    const updatedOpts = this._updateDrawOptions(opts);

    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({
        color: true
      });
    }

    this.model.transform(updatedOpts);
  }

  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }

    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__.assert)(swapped, 'Nothing to swap');
  }

  getBuffer() {
    let varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }

  getData() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      const data = resourceTransform.getData(opts);

      if (data) {
        return data;
      }
    }

    return null;
  }

  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }

  update() {
    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    if ('elementCount' in opts) {
      this.model.setVertexCount(opts.elementCount);
    }

    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }

  _initialize() {
    let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      gl
    } = this;

    this._buildResourceTransforms(gl, props);

    props = this._updateModelProps(props);
    this.model = new _lib_model__WEBPACK_IMPORTED_MODULE_2__["default"](gl, Object.assign({}, props, {
      fs: props.fs || (0,_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_3__.getPassthroughFS)({
        version: (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["default"])(props.vs)
      }),
      id: props.id || 'transform-model',
      drawMode: props.drawMode || 0,
      vertexCount: props.elementCount
    }));
    this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }

  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }

    return updatedProps;
  }

  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new _buffer_transform__WEBPACK_IMPORTED_MODULE_5__["default"](gl, props);
    }

    if (canCreateTextureTransform(props)) {
      this.textureTransform = new _texture_transform__WEBPACK_IMPORTED_MODULE_6__["default"](gl, props);
    }

    (0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__.assert)(this.bufferTransform || this.textureTransform, 'must provide source/feedback buffers or source/target textures');
  }

  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);

    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }

    return updatedOpts;
  }

}

function canCreateBufferTransform(props) {
  if (!(0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_7__.isObjectEmpty)(props.feedbackBuffers) || !(0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_7__.isObjectEmpty)(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
    return true;
  }

  return false;
}

function canCreateTextureTransform(props) {
  if (!(0,_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_7__.isObjectEmpty)(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
    return true;
  }

  return false;
}


/***/ }),

/***/ "./node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@luma.gl/engine/dist/esm/utils/clip-space.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ClipSpace)
/* harmony export */ });
/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/model */ "./node_modules/@luma.gl/engine/dist/esm/lib/model.js");
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/geometry */ "./node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js");


const CLIPSPACE_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
const POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];
class ClipSpace extends _lib_model__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, opts) {
    const TEX_COORDS = POSITIONS.map(coord => coord === -1 ? 0 : coord);
    super(gl, Object.assign({}, opts, {
      vs: CLIPSPACE_VERTEX_SHADER,
      geometry: new _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__["default"]({
        drawMode: 5,
        vertexCount: 4,
        attributes: {
          aClipSpacePosition: {
            size: 2,
            value: new Float32Array(POSITIONS)
          },
          aTexCoord: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          },
          aCoordinate: {
            size: 2,
            value: new Float32Array(TEX_COORDS)
          }
        }
      })
    }));
    this.setVertexCount(4);
  }

}


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fp32": () => (/* binding */ fp32)
/* harmony export */ });
const fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
const fp32 = {
  name: 'fp32',
  vs: fp32shader,
  fs: null
};


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\n\nstruct AmbientLight {\n vec3 color;\n};\n\nstruct PointLight {\n vec3 color;\n vec3 position;\n vec3 attenuation;\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform AmbientLight lighting_uAmbientLight;\nuniform PointLight lighting_uPointLight[MAX_LIGHTS];\nuniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];\nuniform int lighting_uPointLightCount;\nuniform int lighting_uDirectionalLightCount;\n\nuniform bool lighting_uEnabled;\n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n#endif\n");


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "lights": () => (/* binding */ lights)
/* harmony export */ });
/* harmony import */ var _lights_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lights.glsl */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.glsl.js");

const INITIAL_MODULE_OPTIONS = {
  lightSources: {}
};

function convertColor() {
  let {
    color = [0, 0, 0],
    intensity = 1.0
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return color.map(component => component * intensity / 255.0);
}

function getLightSourceUniforms(_ref) {
  let {
    ambientLight,
    pointLights = [],
    directionalLights = []
  } = _ref;
  const lightSourceUniforms = {};

  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }

  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].color")] = convertColor(pointLight);
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].position")] = pointLight.position;
    lightSourceUniforms["lighting_uPointLight[".concat(index, "].attenuation")] = pointLight.attenuation || [1, 0, 0];
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;
  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].color")] = convertColor(directionalLight);
    lightSourceUniforms["lighting_uDirectionalLight[".concat(index, "].direction")] = directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;
  return lightSourceUniforms;
}

function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if ('lightSources' in opts) {
    const {
      ambientLight,
      pointLights,
      directionalLights
    } = opts.lightSources || {};
    const hasLights = ambientLight || pointLights && pointLights.length > 0 || directionalLights && directionalLights.length > 0;

    if (!hasLights) {
      return {
        lighting_uEnabled: false
      };
    }

    return Object.assign({}, getLightSourceUniforms({
      ambientLight,
      pointLights,
      directionalLights
    }), {
      lighting_uEnabled: true
    });
  }

  if ('lights' in opts) {
    const lightSources = {
      pointLights: [],
      directionalLights: []
    };

    for (const light of opts.lights || []) {
      switch (light.type) {
        case 'ambient':
          lightSources.ambientLight = light;
          break;

        case 'directional':
          lightSources.directionalLights.push(light);
          break;

        case 'point':
          lightSources.pointLights.push(light);
          break;

        default:
      }
    }

    return getUniforms({
      lightSources
    });
  }

  return {};
}

const lights = {
  name: 'lights',
  vs: _lights_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  fs: _lights_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
};


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("\nuniform float lighting_uAmbient;\nuniform float lighting_uDiffuse;\nuniform float lighting_uShininess;\nuniform vec3  lighting_uSpecularColor;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normal_worldspace);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n      specular = pow(specular_angle, lighting_uShininess);\n    }\n    lambertian = max(lambertian, 0.0);\n    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n\nvec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = vec3(0, 0, 0);\n  vec3 surfaceColor = vec3(0, 0, 0);\n\n  if (lighting_uEnabled) {\n    vec3 view_direction = normalize(cameraPosition - position_worldspace);\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uPointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_uPointLight[i];\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting_uDirectionalLightCount) {\n        break;\n      }\n      DirectionalLight directionalLight = lighting_uDirectionalLight[i];\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  return lightColor;\n}\n");


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gouraudLighting": () => (/* binding */ gouraudLighting),
/* harmony export */   "phongLighting": () => (/* binding */ phongLighting)
/* harmony export */ });
/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lights/lights */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/lights/lights.js");
/* harmony import */ var _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./phong-lighting.glsl */ "./node_modules/@luma.gl/shadertools/dist/esm/modules/phong-lighting/phong-lighting.glsl.js");


const INITIAL_MODULE_OPTIONS = {};

function getMaterialUniforms(material) {
  const {
    ambient = 0.35,
    diffuse = 0.6,
    shininess = 32,
    specularColor = [30, 30, 30]
  } = material;
  return {
    lighting_uAmbient: ambient,
    lighting_uDiffuse: diffuse,
    lighting_uShininess: shininess,
    lighting_uSpecularColor: specularColor.map(x => x / 255)
  };
}

function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

  if (!('material' in opts)) {
    return {};
  }

  const {
    material
  } = opts;

  if (!material) {
    return {
      lighting_uEnabled: false
    };
  }

  return getMaterialUniforms(material);
}

const gouraudLighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__.lights],
  vs: _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms
};
const phongLighting = {
  name: 'phong-lighting',
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__.lights],
  fs: _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms
};


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "picking": () => (/* binding */ picking)
/* harmony export */ });
const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
const DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null,
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
  pickingActive: false,
  pickingAttribute: false
};

function getUniforms() {
  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
  const uniforms = {};

  if (opts.pickingSelectedColor !== undefined) {
    if (!opts.pickingSelectedColor) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = opts.pickingSelectedColor.slice(0, 3);
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }

  if (opts.pickingHighlightColor) {
    const color = Array.from(opts.pickingHighlightColor, x => x / 255);

    if (!Number.isFinite(color[3])) {
      color[3] = 1;
    }

    uniforms.picking_uHighlightColor = color;
  }

  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = Boolean(opts.pickingActive);
    uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
  }

  return uniforms;
}

const vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
const fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
const picking = {
  name: 'picking',
  vs,
  fs,
  getUniforms
};


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "transform": () => (/* binding */ transform)
/* harmony export */ });
const vs = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
const transform = {
  name: 'transform',
  vs,
  fs: null
};


/***/ }),

/***/ "./node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertToVec4": () => (/* binding */ convertToVec4),
/* harmony export */   "getPassthroughFS": () => (/* binding */ getPassthroughFS),
/* harmony export */   "getQualifierDetails": () => (/* binding */ getQualifierDetails),
/* harmony export */   "typeToChannelCount": () => (/* binding */ typeToChannelCount),
/* harmony export */   "typeToChannelSuffix": () => (/* binding */ typeToChannelSuffix)
/* harmony export */ });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js");

const FS100 = "void main() {gl_FragColor = vec4(0);}";
const FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
const FS300 = "#version 300 es\n".concat(FS_GLES);
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, '').split(/\s+/);
  const [qualifier, type, definition] = words;

  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }

  const name = definition.split(';')[0];
  return {
    qualifier,
    type,
    name
  };
}
function getPassthroughFS() {
  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    version = 100,
    input,
    inputType,
    output
  } = options;

  if (!input) {
    if (version === 300) {
      return FS300;
    } else if (version > 300) {
      return "#version ".concat(version, "\n").concat(FS_GLES);
    }

    return FS100;
  }

  const outputValue = convertToVec4(input, inputType);

  if (version >= 300) {
    return "#version ".concat(version, " ").concat(version === 300 ? 'es' : '', "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
  }

  return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
}
function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';

    case 'vec2':
      return 'xy';

    case 'vec3':
      return 'xyz';

    case 'vec4':
      return 'xyzw';

    default:
      (0,_utils__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
      return null;
  }
}
function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;

    case 'vec2':
      return 2;

    case 'vec3':
      return 3;

    case 'vec4':
      return 4;

    default:
      (0,_utils__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
      return null;
  }
}
function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");

    case 'vec2':
      return "vec4(".concat(variable, ", 0.0, 1.0)");

    case 'vec3':
      return "vec4(".concat(variable, ", 1.0)");

    case 'vec4':
      return variable;

    default:
      (0,_utils__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
      return null;
  }
}


/***/ }),

/***/ "./node_modules/@luma.gl/webgl/dist/esm/classes/query.js":
/*!***************************************************************!*\
  !*** ./node_modules/@luma.gl/webgl/dist/esm/classes/query.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Query)
/* harmony export */ });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "./node_modules/@luma.gl/webgl/dist/esm/classes/resource.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../features */ "./node_modules/@luma.gl/webgl/dist/esm/features/features.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../features */ "./node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js");
/* harmony import */ var _luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/gltools */ "./node_modules/@luma.gl/gltools/dist/esm/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/assert */ "./node_modules/@luma.gl/webgl/dist/esm/utils/assert.js");




const GL_QUERY_RESULT = 0x8866;
const GL_QUERY_RESULT_AVAILABLE = 0x8867;
const GL_TIME_ELAPSED_EXT = 0x88bf;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88;
const GL_ANY_SAMPLES_PASSED = 0x8c2f;
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a;
class Query extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  get [Symbol.toStringTag]() {
    return 'Query';
  }

  static isSupported(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    const webgl2 = (0,_luma_gl_gltools__WEBPACK_IMPORTED_MODULE_0__.isWebGL2)(gl);
    const hasTimerQuery = (0,_features__WEBPACK_IMPORTED_MODULE_2__.hasFeatures)(gl, _features__WEBPACK_IMPORTED_MODULE_3__.FEATURES.TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;

    for (const key of opts) {
      switch (key) {
        case 'queries':
          supported = supported && webgl2;
          break;

        case 'timers':
          supported = supported && hasTimerQuery;
          break;

        default:
          (0,_utils_assert__WEBPACK_IMPORTED_MODULE_4__.assert)(false);
      }
    }

    return supported;
  }

  constructor(gl) {
    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super(gl, opts);
    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;
    Object.seal(this);
  }

  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }

  beginOcclusionQuery() {
    let {
      conservative = false
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }

  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }

  begin(target) {
    if (this._queryPending) {
      return this;
    }

    this.target = target;
    this.gl2.beginQuery(this.target, this.handle);
    return this;
  }

  end() {
    if (this._queryPending) {
      return this;
    }

    if (this.target) {
      this.gl2.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }

    return this;
  }

  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }

    const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);

    if (resultAvailable) {
      this._queryPending = false;
    }

    return resultAvailable;
  }

  isTimerDisjoint() {
    return this.gl2.getParameter(GL_GPU_DISJOINT_EXT);
  }

  getResult() {
    return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }

  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }

  createPoll() {
    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.POSITIVE_INFINITY;

    if (this._pollingPromise) {
      return this._pollingPromise;
    }

    let counter = 0;
    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject('Timed out');
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };

      requestAnimationFrame(poll);
    });
    return this._pollingPromise;
  }

  _createHandle() {
    return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }

  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }

}


/***/ }),

/***/ "./node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getShaderVersion)
/* harmony export */ });
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);

  if (words.length >= 2 && words[0] === '#version') {
    const v = parseInt(words[1], 10);

    if (Number.isFinite(v)) {
      version = v;
    }
  }

  return version;
}


/***/ }),

/***/ "./node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cancelAnimationFrame": () => (/* binding */ cancelAnimationFrame),
/* harmony export */   "requestAnimationFrame": () => (/* binding */ requestAnimationFrame)
/* harmony export */ });
function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
}
function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/classes/base/math-array.js":
/*!************************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/classes/base/math-array.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MathArray)
/* harmony export */ });
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/common */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
function _extendableBuiltin(cls) {
  function ExtendableBuiltin() {
    var instance = Reflect.construct(cls, Array.from(arguments));
    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
    return instance;
  }

  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
    constructor: {
      value: cls,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(ExtendableBuiltin, cls);
  } else {
    ExtendableBuiltin.__proto__ = cls;
  }

  return ExtendableBuiltin;
}


class MathArray extends _extendableBuiltin(Array) {
  clone() {
    return new this.constructor().copy(this);
  }

  fromArray(array, offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = array[i + offset];
    }

    return this.check();
  }

  toArray(targetArray = [], offset = 0) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      targetArray[offset + i] = this[i];
    }

    return targetArray;
  }

  from(arrayOrObject) {
    return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
  }

  to(arrayOrObject) {
    if (arrayOrObject === this) {
      return this;
    }

    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.isArray)(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
  }

  toTarget(target) {
    return target ? this.to(target) : this;
  }

  toFloat32Array() {
    return new Float32Array(this);
  }

  toString() {
    return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_0__.config);
  }

  formatString(opts) {
    let string = '';

    for (let i = 0; i < this.ELEMENTS; ++i) {
      string += (i > 0 ? ', ' : '') + (0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.formatValue)(this[i], opts);
    }

    return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
  }

  equals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (!(0,_lib_common__WEBPACK_IMPORTED_MODULE_0__.equals)(this[i], array[i])) {
        return false;
      }
    }

    return true;
  }

  exactEquals(array) {
    if (!array || this.length !== array.length) {
      return false;
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      if (this[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  negate() {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = -this[i];
    }

    return this.check();
  }

  lerp(a, b, t) {
    if (t === undefined) {
      return this.lerp(this, a, b);
    }

    for (let i = 0; i < this.ELEMENTS; ++i) {
      const ai = a[i];
      this[i] = ai + t * (b[i] - ai);
    }

    return this.check();
  }

  min(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(vector[i], this[i]);
    }

    return this.check();
  }

  max(vector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.max(vector[i], this[i]);
    }

    return this.check();
  }

  clamp(minVector, maxVector) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
    }

    return this.check();
  }

  add(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += vector[i];
      }
    }

    return this.check();
  }

  subtract(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] -= vector[i];
      }
    }

    return this.check();
  }

  scale(scale) {
    if (typeof scale === 'number') {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scale;
      }
    } else {
      for (let i = 0; i < this.ELEMENTS && i < scale.length; ++i) {
        this[i] *= scale[i];
      }
    }

    return this.check();
  }

  multiplyByScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }

    return this.check();
  }

  check() {
    if (_lib_common__WEBPACK_IMPORTED_MODULE_0__.config.debug && !this.validate()) {
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    }

    return this;
  }

  validate() {
    let valid = this.length === this.ELEMENTS;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      valid = valid && Number.isFinite(this[i]);
    }

    return valid;
  }

  sub(a) {
    return this.subtract(a);
  }

  setScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = a;
    }

    return this.check();
  }

  addScalar(a) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] += a;
    }

    return this.check();
  }

  subScalar(a) {
    return this.addScalar(-a);
  }

  multiplyScalar(scalar) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] *= scalar;
    }

    return this.check();
  }

  divideScalar(a) {
    return this.multiplyByScalar(1 / a);
  }

  clampScalar(min, max) {
    for (let i = 0; i < this.ELEMENTS; ++i) {
      this[i] = Math.min(Math.max(this[i], min), max);
    }

    return this.check();
  }

  get elements() {
    return this;
  }

}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/classes/base/matrix.js":
/*!********************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/classes/base/matrix.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix)
/* harmony export */ });
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math-array */ "./node_modules/@math.gl/core/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/validators */ "./node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/common */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");



class Matrix extends _math_array__WEBPACK_IMPORTED_MODULE_0__["default"] {
  toString() {
    let string = '[';

    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__.config.printRowMajor) {
      string += 'row-major:';

      for (let row = 0; row < this.RANK; ++row) {
        for (let col = 0; col < this.RANK; ++col) {
          string += " ".concat(this[col * this.RANK + row]);
        }
      }
    } else {
      string += 'column-major:';

      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += " ".concat(this[i]);
      }
    }

    string += ']';
    return string;
  }

  getElementIndex(row, col) {
    return col * this.RANK + row;
  }

  getElement(row, col) {
    return this[col * this.RANK + row];
  }

  setElement(row, col, value) {
    this[col * this.RANK + row] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(value);
    return this;
  }

  getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
    const firstIndex = columnIndex * this.RANK;

    for (let i = 0; i < this.RANK; ++i) {
      result[i] = this[firstIndex + i];
    }

    return result;
  }

  setColumn(columnIndex, columnVector) {
    const firstIndex = columnIndex * this.RANK;

    for (let i = 0; i < this.RANK; ++i) {
      this[firstIndex + i] = columnVector[i];
    }

    return this;
  }

}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/classes/base/vector.js":
/*!********************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/classes/base/vector.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Vector)
/* harmony export */ });
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math-array */ "./node_modules/@math.gl/core/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lib/validators */ "./node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lib/assert */ "./node_modules/@math.gl/core/dist/esm/lib/assert.js");



class Vector extends _math_array__WEBPACK_IMPORTED_MODULE_0__["default"] {
  get x() {
    return this[0];
  }

  set x(value) {
    this[0] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__.checkNumber)(value);
  }

  get y() {
    return this[1];
  }

  set y(value) {
    this[1] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__.checkNumber)(value);
  }

  len() {
    return Math.sqrt(this.lengthSquared());
  }

  magnitude() {
    return this.len();
  }

  lengthSquared() {
    let length = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      length += this[i] * this[i];
    }

    return length;
  }

  magnitudeSquared() {
    return this.lengthSquared();
  }

  distance(mathArray) {
    return Math.sqrt(this.distanceSquared(mathArray));
  }

  distanceSquared(mathArray) {
    let length = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      const dist = this[i] - mathArray[i];
      length += dist * dist;
    }

    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__.checkNumber)(length);
  }

  dot(mathArray) {
    let product = 0;

    for (let i = 0; i < this.ELEMENTS; ++i) {
      product += this[i] * mathArray[i];
    }

    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__.checkNumber)(product);
  }

  normalize() {
    const length = this.magnitude();

    if (length !== 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= length;
      }
    }

    return this.check();
  }

  multiply(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= vector[i];
      }
    }

    return this.check();
  }

  divide(...vectors) {
    for (const vector of vectors) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] /= vector[i];
      }
    }

    return this.check();
  }

  lengthSq() {
    return this.lengthSquared();
  }

  distanceTo(vector) {
    return this.distance(vector);
  }

  distanceToSquared(vector) {
    return this.distanceSquared(vector);
  }

  getComponent(i) {
    (0,_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    return (0,_lib_validators__WEBPACK_IMPORTED_MODULE_1__.checkNumber)(this[i]);
  }

  setComponent(i, value) {
    (0,_lib_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
    this[i] = value;
    return this.check();
  }

  addVectors(a, b) {
    return this.copy(a).add(b);
  }

  subVectors(a, b) {
    return this.copy(a).subtract(b);
  }

  multiplyVectors(a, b) {
    return this.copy(a).multiply(b);
  }

  addScaledVector(a, b) {
    return this.add(new this.constructor(a).multiplyScalar(b));
  }

}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/classes/matrix4.js":
/*!****************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/classes/matrix4.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Matrix4)
/* harmony export */ });
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/matrix */ "./node_modules/@math.gl/core/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/validators */ "./node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "./node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix/mat4 */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! gl-matrix/vec2 */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix/vec4 */ "./node_modules/gl-matrix/esm/vec4.js");







var INDICES;

(function (INDICES) {
  INDICES[INDICES["COL0ROW0"] = 0] = "COL0ROW0";
  INDICES[INDICES["COL0ROW1"] = 1] = "COL0ROW1";
  INDICES[INDICES["COL0ROW2"] = 2] = "COL0ROW2";
  INDICES[INDICES["COL0ROW3"] = 3] = "COL0ROW3";
  INDICES[INDICES["COL1ROW0"] = 4] = "COL1ROW0";
  INDICES[INDICES["COL1ROW1"] = 5] = "COL1ROW1";
  INDICES[INDICES["COL1ROW2"] = 6] = "COL1ROW2";
  INDICES[INDICES["COL1ROW3"] = 7] = "COL1ROW3";
  INDICES[INDICES["COL2ROW0"] = 8] = "COL2ROW0";
  INDICES[INDICES["COL2ROW1"] = 9] = "COL2ROW1";
  INDICES[INDICES["COL2ROW2"] = 10] = "COL2ROW2";
  INDICES[INDICES["COL2ROW3"] = 11] = "COL2ROW3";
  INDICES[INDICES["COL3ROW0"] = 12] = "COL3ROW0";
  INDICES[INDICES["COL3ROW1"] = 13] = "COL3ROW1";
  INDICES[INDICES["COL3ROW2"] = 14] = "COL3ROW2";
  INDICES[INDICES["COL3ROW3"] = 15] = "COL3ROW3";
})(INDICES || (INDICES = {}));

const DEFAULT_FOVY = 45 * Math.PI / 180;
const DEFAULT_ASPECT = 1;
const DEFAULT_NEAR = 0.1;
const DEFAULT_FAR = 500;
const IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Matrix4 extends _base_matrix__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static get IDENTITY() {
    return getIdentityMatrix();
  }

  static get ZERO() {
    return getZeroMatrix();
  }

  get ELEMENTS() {
    return 16;
  }

  get RANK() {
    return 4;
  }

  get INDICES() {
    return INDICES;
  }

  constructor(array) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);

    if (arguments.length === 1 && Array.isArray(array)) {
      this.copy(array);
    } else {
      this.identity();
    }
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    this[3] = array[3];
    this[4] = array[4];
    this[5] = array[5];
    this[6] = array[6];
    this[7] = array[7];
    this[8] = array[8];
    this[9] = array[9];
    this[10] = array[10];
    this[11] = array[11];
    this[12] = array[12];
    this[13] = array[13];
    this[14] = array[14];
    this[15] = array[15];
    return this.check();
  }

  set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }

  setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    this[0] = m00;
    this[1] = m10;
    this[2] = m20;
    this[3] = m30;
    this[4] = m01;
    this[5] = m11;
    this[6] = m21;
    this[7] = m31;
    this[8] = m02;
    this[9] = m12;
    this[10] = m22;
    this[11] = m32;
    this[12] = m03;
    this[13] = m13;
    this[14] = m23;
    this[15] = m33;
    return this.check();
  }

  toRowMajor(result) {
    result[0] = this[0];
    result[1] = this[4];
    result[2] = this[8];
    result[3] = this[12];
    result[4] = this[1];
    result[5] = this[5];
    result[6] = this[9];
    result[7] = this[13];
    result[8] = this[2];
    result[9] = this[6];
    result[10] = this[10];
    result[11] = this[14];
    result[12] = this[3];
    result[13] = this[7];
    result[14] = this[11];
    result[15] = this[15];
    return result;
  }

  identity() {
    return this.copy(IDENTITY_MATRIX);
  }

  fromObject(object) {
    return this.check();
  }

  fromQuaternion(quaternion) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.fromQuat(this, quaternion);
    return this.check();
  }

  frustum(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;

    if (far === Infinity) {
      computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
    } else {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.frustum(this, left, right, bottom, top, near, far);
    }

    return this.check();
  }

  lookAt(view) {
    const {
      eye,
      center = [0, 0, 0],
      up = [0, 1, 0]
    } = view;
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.lookAt(this, eye, center, up);
    return this.check();
  }

  ortho(view) {
    const {
      left,
      right,
      bottom,
      top,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.ortho(this, left, right, bottom, top, near, far);
    return this.check();
  }

  orthographic(view) {
    const {
      fovy = DEFAULT_FOVY,
      aspect = DEFAULT_ASPECT,
      focalDistance = 1,
      near = DEFAULT_NEAR,
      far = DEFAULT_FAR
    } = view;
    checkRadians(fovy);
    const halfY = fovy / 2;
    const top = focalDistance * Math.tan(halfY);
    const right = top * aspect;
    return this.ortho({
      left: -right,
      right,
      bottom: -top,
      top,
      near,
      far
    });
  }

  perspective(view) {
    const {
      fovy = 45 * Math.PI / 180,
      aspect = 1,
      near = 0.1,
      far = 500
    } = view;
    checkRadians(fovy);
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.perspective(this, fovy, aspect, near, far);
    return this.check();
  }

  determinant() {
    return gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.determinant(this);
  }

  getScale(result = [-0, -0, -0]) {
    result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
    result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
    result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
    return result;
  }

  getTranslation(result = [-0, -0, -0]) {
    result[0] = this[12];
    result[1] = this[13];
    result[2] = this[14];
    return result;
  }

  getRotation(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = 0;
    result[4] = this[4] * inverseScale0;
    result[5] = this[5] * inverseScale1;
    result[6] = this[6] * inverseScale2;
    result[7] = 0;
    result[8] = this[8] * inverseScale0;
    result[9] = this[9] * inverseScale1;
    result[10] = this[10] * inverseScale2;
    result[11] = 0;
    result[12] = 0;
    result[13] = 0;
    result[14] = 0;
    result[15] = 1;
    return result;
  }

  getRotationMatrix3(result, scaleResult) {
    result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
    scaleResult = scaleResult || [-0, -0, -0];
    const scale = this.getScale(scaleResult);
    const inverseScale0 = 1 / scale[0];
    const inverseScale1 = 1 / scale[1];
    const inverseScale2 = 1 / scale[2];
    result[0] = this[0] * inverseScale0;
    result[1] = this[1] * inverseScale1;
    result[2] = this[2] * inverseScale2;
    result[3] = this[4] * inverseScale0;
    result[4] = this[5] * inverseScale1;
    result[5] = this[6] * inverseScale2;
    result[6] = this[8] * inverseScale0;
    result[7] = this[9] * inverseScale1;
    result[8] = this[10] * inverseScale2;
    return result;
  }

  transpose() {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.transpose(this, this);
    return this.check();
  }

  invert() {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.invert(this, this);
    return this.check();
  }

  multiplyLeft(a) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.multiply(this, a, this);
    return this.check();
  }

  multiplyRight(a) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.multiply(this, this, a);
    return this.check();
  }

  rotateX(radians) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.rotateX(this, this, radians);
    return this.check();
  }

  rotateY(radians) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.rotateY(this, this, radians);
    return this.check();
  }

  rotateZ(radians) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.rotateZ(this, this, radians);
    return this.check();
  }

  rotateXYZ(angleXYZ) {
    return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
  }

  rotateAxis(radians, axis) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.rotate(this, this, radians, axis);
    return this.check();
  }

  scale(factor) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
    return this.check();
  }

  translate(vector) {
    gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_1__.translate(this, this, vector);
    return this.check();
  }

  transform(vector, result) {
    if (vector.length === 4) {
      result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_2__.transformMat4(result || [-0, -0, -0, -0], vector, this);
      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__.checkVector)(result, 4);
      return result;
    }

    return this.transformAsPoint(vector, result);
  }

  transformAsPoint(vector, result) {
    const {
      length
    } = vector;
    let out;

    switch (length) {
      case 2:
        out = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_4__.transformMat4(result || [-0, -0], vector, this);
        break;

      case 3:
        out = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__.transformMat4(result || [-0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__.checkVector)(out, vector.length);
    return out;
  }

  transformAsVector(vector, result) {
    let out;

    switch (vector.length) {
      case 2:
        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__.vec2_transformMat4AsVector)(result || [-0, -0], vector, this);
        break;

      case 3:
        out = (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_6__.vec3_transformMat4AsVector)(result || [-0, -0, -0], vector, this);
        break;

      default:
        throw new Error('Illegal vector');
    }

    (0,_lib_validators__WEBPACK_IMPORTED_MODULE_3__.checkVector)(out, vector.length);
    return out;
  }

  transformPoint(vector, result) {
    return this.transformAsPoint(vector, result);
  }

  transformVector(vector, result) {
    return this.transformAsPoint(vector, result);
  }

  transformDirection(vector, result) {
    return this.transformAsVector(vector, result);
  }

  makeRotationX(radians) {
    return this.identity().rotateX(radians);
  }

  makeTranslation(x, y, z) {
    return this.identity().translate([x, y, z]);
  }

}
let ZERO;
let IDENTITY;

function getZeroMatrix() {
  if (!ZERO) {
    ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    Object.freeze(ZERO);
  }

  return ZERO;
}

function getIdentityMatrix() {
  if (!IDENTITY) {
    IDENTITY = new Matrix4();
    Object.freeze(IDENTITY);
  }

  return IDENTITY;
}

function checkRadians(possiblyDegrees) {
  if (possiblyDegrees > Math.PI * 2) {
    throw Error('expected radians');
  }
}

function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
  const column0Row0 = 2 * near / (right - left);
  const column1Row1 = 2 * near / (top - bottom);
  const column2Row0 = (right + left) / (right - left);
  const column2Row1 = (top + bottom) / (top - bottom);
  const column2Row2 = -1;
  const column2Row3 = -1;
  const column3Row2 = -2 * near;
  result[0] = column0Row0;
  result[1] = 0;
  result[2] = 0;
  result[3] = 0;
  result[4] = 0;
  result[5] = column1Row1;
  result[6] = 0;
  result[7] = 0;
  result[8] = column2Row0;
  result[9] = column2Row1;
  result[10] = column2Row2;
  result[11] = column2Row3;
  result[12] = 0;
  result[13] = 0;
  result[14] = column3Row2;
  result[15] = 0;
  return result;
}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/classes/spherical-coordinates.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SphericalCoordinates)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vector3 */ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/common */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");





const EPSILON = 0.000001;
const EARTH_RADIUS_METERS = 6371000;
class SphericalCoordinates {
  constructor({
    phi = 0,
    theta = 0,
    radius = 1,
    bearing,
    pitch,
    altitude,
    radiusScale = EARTH_RADIUS_METERS
  } = {}) {
    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "phi", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "theta", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radius", void 0);

    (0,_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(this, "radiusScale", void 0);

    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;

    if (bearing !== undefined) {
      this.bearing = bearing;
    }

    if (pitch !== undefined) {
      this.pitch = pitch;
    }

    this.check();
  }

  toString() {
    return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_1__.config);
  }

  formatString({
    printTypes = false
  }) {
    const f = _lib_common__WEBPACK_IMPORTED_MODULE_1__.formatValue;
    return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
  }

  equals(other) {
    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.equals)(this.radius, other.radius) && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.equals)(this.theta, other.theta) && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.equals)(this.phi, other.phi);
  }

  exactEquals(other) {
    return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
  }

  get bearing() {
    return 180 - (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.degrees)(this.phi);
  }

  set bearing(v) {
    this.phi = Math.PI - (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.radians)(v);
  }

  get pitch() {
    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.degrees)(this.theta);
  }

  set pitch(v) {
    this.theta = (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.radians)(v);
  }

  get longitude() {
    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.degrees)(this.phi);
  }

  get latitude() {
    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.degrees)(this.theta);
  }

  get lng() {
    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.degrees)(this.phi);
  }

  get lat() {
    return (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.degrees)(this.theta);
  }

  get z() {
    return (this.radius - 1) * this.radiusScale;
  }

  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this.check();
  }

  clone() {
    return new SphericalCoordinates().copy(this);
  }

  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this.check();
  }

  fromLngLatZ([lng, lat, z]) {
    this.radius = 1 + z / this.radiusScale;
    this.phi = (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.radians)(lat);
    this.theta = (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.radians)(lng);
    return this.check();
  }

  fromVector3(v) {
    this.radius = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_2__.length(v);

    if (this.radius > 0) {
      this.theta = Math.atan2(v[0], v[1]);
      this.phi = Math.acos((0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.clamp)(v[2] / this.radius, -1, 1));
    }

    return this.check();
  }

  toVector3() {
    return new _vector3__WEBPACK_IMPORTED_MODULE_3__["default"](0, 0, this.radius).rotateX({
      radians: this.theta
    }).rotateZ({
      radians: this.phi
    });
  }

  makeSafe() {
    this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    return this;
  }

  check() {
    if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
      throw new Error('SphericalCoordinates: some fields set to invalid numbers');
    }

    return this;
  }

}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/classes/vector3.js":
/*!****************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/classes/vector3.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Vector3)
/* harmony export */ });
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base/vector */ "./node_modules/@math.gl/core/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/common */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/validators */ "./node_modules/@math.gl/core/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix/vec3 */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "./node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js");





const ORIGIN = [0, 0, 0];
let ZERO;
class Vector3 extends _base_vector__WEBPACK_IMPORTED_MODULE_0__["default"] {
  static get ZERO() {
    if (!ZERO) {
      ZERO = new Vector3(0, 0, 0);
      Object.freeze(ZERO);
    }

    return ZERO;
  }

  constructor(x = 0, y = 0, z = 0) {
    super(-0, -0, -0);

    if (arguments.length === 1 && (0,_lib_common__WEBPACK_IMPORTED_MODULE_1__.isArray)(x)) {
      this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_1__.config.debug) {
        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(x);
        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(y);
        (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(z);
      }

      this[0] = x;
      this[1] = y;
      this[2] = z;
    }
  }

  set(x, y, z) {
    this[0] = x;
    this[1] = y;
    this[2] = z;
    return this.check();
  }

  copy(array) {
    this[0] = array[0];
    this[1] = array[1];
    this[2] = array[2];
    return this.check();
  }

  fromObject(object) {
    if (_lib_common__WEBPACK_IMPORTED_MODULE_1__.config.debug) {
      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(object.x);
      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(object.y);
      (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(object.z);
    }

    this[0] = object.x;
    this[1] = object.y;
    this[2] = object.z;
    return this.check();
  }

  toObject(object) {
    object.x = this[0];
    object.y = this[1];
    object.z = this[2];
    return object;
  }

  get ELEMENTS() {
    return 3;
  }

  get z() {
    return this[2];
  }

  set z(value) {
    this[2] = (0,_lib_validators__WEBPACK_IMPORTED_MODULE_2__.checkNumber)(value);
  }

  angle(vector) {
    return gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.angle(this, vector);
  }

  cross(vector) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.cross(this, this, vector);
    return this.check();
  }

  rotateX({
    radians,
    origin = ORIGIN
  }) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.rotateX(this, this, origin, radians);
    return this.check();
  }

  rotateY({
    radians,
    origin = ORIGIN
  }) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.rotateY(this, this, origin, radians);
    return this.check();
  }

  rotateZ({
    radians,
    origin = ORIGIN
  }) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.rotateZ(this, this, origin, radians);
    return this.check();
  }

  transform(matrix4) {
    return this.transformAsPoint(matrix4);
  }

  transformAsPoint(matrix4) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.transformMat4(this, this, matrix4);
    return this.check();
  }

  transformAsVector(matrix4) {
    (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__.vec3_transformMat4AsVector)(this, this, matrix4);
    return this.check();
  }

  transformByMatrix3(matrix3) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.transformMat3(this, this, matrix3);
    return this.check();
  }

  transformByMatrix2(matrix2) {
    (0,_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_4__.vec3_transformMat2)(this, this, matrix2);
    return this.check();
  }

  transformByQuaternion(quaternion) {
    gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_3__.transformQuat(this, this, quaternion);
    return this.check();
  }

}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "vec2_transformMat4AsVector": () => (/* binding */ vec2_transformMat4AsVector),
/* harmony export */   "vec3_transformMat2": () => (/* binding */ vec3_transformMat2),
/* harmony export */   "vec3_transformMat4AsVector": () => (/* binding */ vec3_transformMat4AsVector),
/* harmony export */   "vec4_transformMat2": () => (/* binding */ vec4_transformMat2),
/* harmony export */   "vec4_transformMat3": () => (/* binding */ vec4_transformMat3)
/* harmony export */ });
function vec2_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  const w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  const x = a[0];
  const y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  const x = a[0];
  const y = a[1];
  const z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}


/***/ }),

/***/ "./node_modules/@math.gl/core/dist/esm/lib/validators.js":
/*!***************************************************************!*\
  !*** ./node_modules/@math.gl/core/dist/esm/lib/validators.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "checkNumber": () => (/* binding */ checkNumber),
/* harmony export */   "checkVector": () => (/* binding */ checkVector),
/* harmony export */   "deprecated": () => (/* binding */ deprecated),
/* harmony export */   "validateVector": () => (/* binding */ validateVector)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./node_modules/@math.gl/core/dist/esm/lib/common.js");

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  for (let i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }

  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}
function checkVector(v, length, callerName = '') {
  if (_common__WEBPACK_IMPORTED_MODULE_0__.config.debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
  }

  return v;
}
const map = {};
function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}


/***/ }),

/***/ "./node_modules/@math.gl/sun/dist/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@math.gl/sun/dist/esm/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSunDirection": () => (/* reexport safe */ _suncalc__WEBPACK_IMPORTED_MODULE_0__.getSunDirection),
/* harmony export */   "getSunPosition": () => (/* reexport safe */ _suncalc__WEBPACK_IMPORTED_MODULE_0__.getSunPosition)
/* harmony export */ });
/* harmony import */ var _suncalc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./suncalc */ "./node_modules/@math.gl/sun/dist/esm/suncalc.js");



/***/ }),

/***/ "./node_modules/@math.gl/sun/dist/esm/suncalc.js":
/*!*******************************************************!*\
  !*** ./node_modules/@math.gl/sun/dist/esm/suncalc.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSunDirection": () => (/* binding */ getSunDirection),
/* harmony export */   "getSunPosition": () => (/* binding */ getSunPosition)
/* harmony export */ });
const DEGREES_TO_RADIANS = Math.PI / 180;
const DAY_IN_MS = 1000 * 60 * 60 * 24;
const JD1970 = 2440588;
const JD2000 = 2451545;
const e = DEGREES_TO_RADIANS * 23.4397;
const M0 = 357.5291;
const M1 = 0.98560028;
const THETA0 = 280.147;
const THETA1 = 360.9856235;
function getSunPosition(timestamp, latitude, longitude) {
  const longitudeWestInRadians = DEGREES_TO_RADIANS * -longitude;
  const phi = DEGREES_TO_RADIANS * latitude;
  const d = toDays(timestamp);
  const c = getSunCoords(d);
  const H = getSiderealTime(d, longitudeWestInRadians) - c.rightAscension;
  return {
    azimuth: getAzimuth(H, phi, c.declination),
    altitude: getAltitude(H, phi, c.declination)
  };
}
function getSunDirection(timestamp, latitude, longitude) {
  const {
    azimuth,
    altitude
  } = getSunPosition(timestamp, latitude, longitude);
  return [Math.sin(azimuth) * Math.cos(altitude), Math.cos(azimuth) * Math.cos(altitude), -Math.sin(altitude)];
}

function toJulianDay(timestamp) {
  const ts = typeof timestamp === 'number' ? timestamp : timestamp.getTime();
  return ts / DAY_IN_MS - 0.5 + JD1970;
}

function toDays(timestamp) {
  return toJulianDay(timestamp) - JD2000;
}

function getRightAscension(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.atan2(Math.sin(lambda) * Math.cos(e) - Math.tan(b) * Math.sin(e), Math.cos(lambda));
}

function getDeclination(eclipticLongitude, b) {
  const lambda = eclipticLongitude;
  return Math.asin(Math.sin(b) * Math.cos(e) + Math.cos(b) * Math.sin(e) * Math.sin(lambda));
}

function getAzimuth(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.atan2(Math.sin(H), Math.cos(H) * Math.sin(phi) - Math.tan(delta) * Math.cos(phi));
}

function getAltitude(hourAngle, latitudeInRadians, declination) {
  const H = hourAngle;
  const phi = latitudeInRadians;
  const delta = declination;
  return Math.asin(Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(H));
}

function getSiderealTime(dates, longitudeWestInRadians) {
  return DEGREES_TO_RADIANS * (THETA0 + THETA1 * dates) - longitudeWestInRadians;
}

function getSolarMeanAnomaly(days) {
  return DEGREES_TO_RADIANS * (M0 + M1 * days);
}

function getEclipticLongitude(meanAnomaly) {
  const M = meanAnomaly;
  const C = DEGREES_TO_RADIANS * (1.9148 * Math.sin(M) + 0.02 * Math.sin(2 * M) + 0.0003 * Math.sin(3 * M));
  const P = DEGREES_TO_RADIANS * 102.9372;
  return M + C + P + Math.PI;
}

function getSunCoords(dates) {
  const M = getSolarMeanAnomaly(dates);
  const L = getEclipticLongitude(M);
  return {
    declination: getDeclination(L, 0),
    rightAscension: getRightAscension(L, 0)
  };
}


/***/ }),

/***/ "./node_modules/hammerjs/hammer.js":
/*!*****************************************!*\
  !*** ./node_modules/hammerjs/hammer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

// this prevents errors when Hammer is loaded in the presence of an AMD
//  style loader but by script tag, not by the loader.
var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
freeGlobal.Hammer = Hammer;

if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return Hammer;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

})(window, document, 'Hammer');


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/constants.js":
/*!*******************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/constants.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BASIC_EVENT_ALIASES": () => (/* binding */ BASIC_EVENT_ALIASES),
/* harmony export */   "EVENT_RECOGNIZER_MAP": () => (/* binding */ EVENT_RECOGNIZER_MAP),
/* harmony export */   "GESTURE_EVENT_ALIASES": () => (/* binding */ GESTURE_EVENT_ALIASES),
/* harmony export */   "INPUT_EVENT_TYPES": () => (/* binding */ INPUT_EVENT_TYPES),
/* harmony export */   "RECOGNIZERS": () => (/* binding */ RECOGNIZERS),
/* harmony export */   "RECOGNIZER_COMPATIBLE_MAP": () => (/* binding */ RECOGNIZER_COMPATIBLE_MAP),
/* harmony export */   "RECOGNIZER_FALLBACK_MAP": () => (/* binding */ RECOGNIZER_FALLBACK_MAP)
/* harmony export */ });
/* harmony import */ var _utils_hammer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/hammer */ "./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js");

// This module contains constants that must be conditionally required
// due to `window`/`document` references downstream.
const RECOGNIZERS = _utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"]
    ? [
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Pan, { event: 'tripan', pointers: 3, threshold: 0, enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Rotate, { enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Pinch, { enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Swipe, { enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Pan, { threshold: 0, enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Press, { enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Tap, { event: 'doubletap', taps: 2, enable: false }],
        // TODO - rename to 'tap' and 'singletap' in the next major release
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Tap, { event: 'anytap', enable: false }],
        [_utils_hammer__WEBPACK_IMPORTED_MODULE_0__["default"].Tap, { enable: false }]
    ]
    : null;
// Recognize the following gestures even if a given recognizer succeeds
const RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ['rotate', 'pinch', 'pan'],
    rotate: ['pinch'],
    pinch: ['pan'],
    pan: ['press', 'doubletap', 'anytap', 'tap'],
    doubletap: ['anytap'],
    anytap: ['tap']
};
// Recognize the folling gestures only if a given recognizer fails
const RECOGNIZER_FALLBACK_MAP = {
    doubletap: ['tap']
};
/**
 * Only one set of basic input events will be fired by Hammer.js:
 * either pointer, touch, or mouse, depending on system support.
 * In order to enable an application to be agnostic of system support,
 * alias basic input events into "classes" of events: down, move, and up.
 * See `_onBasicInput()` for usage of these aliases.
 */
const BASIC_EVENT_ALIASES = {
    pointerdown: 'pointerdown',
    pointermove: 'pointermove',
    pointerup: 'pointerup',
    touchstart: 'pointerdown',
    touchmove: 'pointermove',
    touchend: 'pointerup',
    mousedown: 'pointerdown',
    mousemove: 'pointermove',
    mouseup: 'pointerup'
};
const INPUT_EVENT_TYPES = {
    KEY_EVENTS: ['keydown', 'keyup'],
    MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
    WHEEL_EVENTS: [
        // Chrome, Safari
        'wheel',
        // IE
        'mousewheel'
    ]
};
/**
 * "Gestural" events are those that have semantic meaning beyond the basic input event,
 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
 * Hammer.js handles these with its Recognizer system;
 * this block maps event names to the Recognizers required to detect the events.
 */
const EVENT_RECOGNIZER_MAP = {
    tap: 'tap',
    anytap: 'anytap',
    doubletap: 'doubletap',
    press: 'press',
    pinch: 'pinch',
    pinchin: 'pinch',
    pinchout: 'pinch',
    pinchstart: 'pinch',
    pinchmove: 'pinch',
    pinchend: 'pinch',
    pinchcancel: 'pinch',
    rotate: 'rotate',
    rotatestart: 'rotate',
    rotatemove: 'rotate',
    rotateend: 'rotate',
    rotatecancel: 'rotate',
    tripan: 'tripan',
    tripanstart: 'tripan',
    tripanmove: 'tripan',
    tripanup: 'tripan',
    tripandown: 'tripan',
    tripanleft: 'tripan',
    tripanright: 'tripan',
    tripanend: 'tripan',
    tripancancel: 'tripan',
    pan: 'pan',
    panstart: 'pan',
    panmove: 'pan',
    panup: 'pan',
    pandown: 'pan',
    panleft: 'pan',
    panright: 'pan',
    panend: 'pan',
    pancancel: 'pan',
    swipe: 'swipe',
    swipeleft: 'swipe',
    swiperight: 'swipe',
    swipeup: 'swipe',
    swipedown: 'swipe'
};
/**
 * Map gestural events typically provided by browsers
 * that are not reported in 'hammer.input' events
 * to corresponding Hammer.js gestures.
 */
const GESTURE_EVENT_ALIASES = {
    click: 'tap',
    anyclick: 'anytap',
    dblclick: 'doubletap',
    mousedown: 'pointerdown',
    mousemove: 'pointermove',
    mouseup: 'pointerup',
    mouseover: 'pointerover',
    mouseout: 'pointerout',
    mouseleave: 'pointerleave'
};


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/event-manager.js":
/*!***********************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/event-manager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventManager)
/* harmony export */ });
/* harmony import */ var _utils_hammer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/hammer */ "./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js");
/* harmony import */ var _inputs_wheel_input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inputs/wheel-input */ "./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js");
/* harmony import */ var _inputs_move_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./inputs/move-input */ "./node_modules/mjolnir.js/dist/esm/inputs/move-input.js");
/* harmony import */ var _inputs_key_input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inputs/key-input */ "./node_modules/mjolnir.js/dist/esm/inputs/key-input.js");
/* harmony import */ var _inputs_contextmenu_input__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inputs/contextmenu-input */ "./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js");
/* harmony import */ var _utils_event_registrar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/event-registrar */ "./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./node_modules/mjolnir.js/dist/esm/constants.js");







const DEFAULT_OPTIONS = {
    // event handlers
    events: null,
    // custom recognizers
    recognizers: null,
    recognizerOptions: {},
    // Manager class
    Manager: _utils_hammer__WEBPACK_IMPORTED_MODULE_0__.Manager,
    // allow browser default touch action
    // https://github.com/uber/react-map-gl/issues/506
    touchAction: 'none',
    tabIndex: 0
};
// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.
class EventManager {
    constructor(element = null, options) {
        /**
         * Handle basic events using the 'hammer.input' Hammer.js API:
         * Before running Recognizers, Hammer emits a 'hammer.input' event
         * with the basic event info. This function emits all basic events
         * aliased to the "class" of event received.
         * See constants.BASIC_EVENT_CLASSES basic event class definitions.
         */
        this._onBasicInput = (event) => {
            const { srcEvent } = event;
            const alias = _constants__WEBPACK_IMPORTED_MODULE_6__.BASIC_EVENT_ALIASES[srcEvent.type];
            if (alias) {
                // fire all events aliased to srcEvent.type
                this.manager.emit(alias, event);
            }
        };
        /**
         * Handle events not supported by Hammer.js,
         * and pipe back out through same (Hammer) channel used by other events.
         */
        this._onOtherEvent = (event) => {
            // console.log('onotherevent', event.type, event)
            this.manager.emit(event.type, event);
        };
        this.options = { ...DEFAULT_OPTIONS, ...options };
        this.events = new Map();
        this.setElement(element);
        // Register all passed events.
        const { events } = this.options;
        if (events) {
            this.on(events);
        }
    }
    getElement() {
        return this.element;
    }
    setElement(element) {
        if (this.element) {
            // unregister all events
            this.destroy();
        }
        this.element = element;
        if (!element) {
            return;
        }
        const { options } = this;
        const ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
            touchAction: options.touchAction,
            recognizers: options.recognizers || _constants__WEBPACK_IMPORTED_MODULE_6__.RECOGNIZERS
        }).on('hammer.input', this._onBasicInput);
        if (!options.recognizers) {
            // Set default recognize withs
            // http://hammerjs.github.io/recognize-with/
            Object.keys(_constants__WEBPACK_IMPORTED_MODULE_6__.RECOGNIZER_COMPATIBLE_MAP).forEach(name => {
                const recognizer = this.manager.get(name);
                if (recognizer) {
                    _constants__WEBPACK_IMPORTED_MODULE_6__.RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {
                        recognizer.recognizeWith(otherName);
                    });
                }
            });
        }
        // Set recognizer options
        for (const recognizerName in options.recognizerOptions) {
            const recognizer = this.manager.get(recognizerName);
            if (recognizer) {
                const recognizerOption = options.recognizerOptions[recognizerName];
                // `enable` is managed by the event registrations
                delete recognizerOption.enable;
                recognizer.set(recognizerOption);
            }
        }
        // Handle events not handled by Hammer.js:
        // - mouse wheel
        // - pointer/touch/mouse move
        this.wheelInput = new _inputs_wheel_input__WEBPACK_IMPORTED_MODULE_1__["default"](element, this._onOtherEvent, {
            enable: false
        });
        this.moveInput = new _inputs_move_input__WEBPACK_IMPORTED_MODULE_2__["default"](element, this._onOtherEvent, {
            enable: false
        });
        this.keyInput = new _inputs_key_input__WEBPACK_IMPORTED_MODULE_3__["default"](element, this._onOtherEvent, {
            enable: false,
            tabIndex: options.tabIndex
        });
        this.contextmenuInput = new _inputs_contextmenu_input__WEBPACK_IMPORTED_MODULE_4__["default"](element, this._onOtherEvent, {
            enable: false
        });
        // Register all existing events
        for (const [eventAlias, eventRegistrar] of this.events) {
            if (!eventRegistrar.isEmpty()) {
                // Enable recognizer for this event.
                this._toggleRecognizer(eventRegistrar.recognizerName, true);
                this.manager.on(eventAlias, eventRegistrar.handleEvent);
            }
        }
    }
    // Tear down internal event management implementations.
    destroy() {
        if (this.element) {
            // wheelInput etc. are created in setElement() and therefore
            // cannot exist if there is no element
            this.wheelInput.destroy();
            this.moveInput.destroy();
            this.keyInput.destroy();
            this.contextmenuInput.destroy();
            this.manager.destroy();
            this.wheelInput = null;
            this.moveInput = null;
            this.keyInput = null;
            this.contextmenuInput = null;
            this.manager = null;
            this.element = null;
        }
    }
    /** Register an event handler function to be called on `event` */
    on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
        this._removeEventHandler(event, handler);
    }
    /*
     * Enable/disable recognizer for the given event
     */
    _toggleRecognizer(name, enabled) {
        const { manager } = this;
        if (!manager) {
            return;
        }
        const recognizer = manager.get(name);
        // @ts-ignore
        if (recognizer && recognizer.options.enable !== enabled) {
            recognizer.set({ enable: enabled });
            const fallbackRecognizers = _constants__WEBPACK_IMPORTED_MODULE_6__.RECOGNIZER_FALLBACK_MAP[name];
            if (fallbackRecognizers && !this.options.recognizers) {
                // Set default require failures
                // http://hammerjs.github.io/require-failure/
                fallbackRecognizers.forEach(otherName => {
                    const otherRecognizer = manager.get(otherName);
                    if (enabled) {
                        // Wait for this recognizer to fail
                        otherRecognizer.requireFailure(name);
                        /**
                         * This seems to be a bug in hammerjs:
                         * requireFailure() adds both ways
                         * dropRequireFailure() only drops one way
                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
                           recognizer-constructor.js#L136
                         */
                        recognizer.dropRequireFailure(otherName);
                    }
                    else {
                        // Do not wait for this recognizer to fail
                        otherRecognizer.dropRequireFailure(name);
                    }
                });
            }
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */
    _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== 'string') {
            // @ts-ignore
            opts = handler;
            // If `event` is a map, call `on()` for each entry.
            for (const eventName in event) {
                this._addEventHandler(eventName, event[eventName], opts, once, passive);
            }
            return;
        }
        const { manager, events } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = _constants__WEBPACK_IMPORTED_MODULE_6__.GESTURE_EVENT_ALIASES[event] || event;
        let eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
            eventRegistrar = new _utils_event_registrar__WEBPACK_IMPORTED_MODULE_5__["default"](this);
            events.set(eventAlias, eventRegistrar);
            // Enable recognizer for this event.
            eventRegistrar.recognizerName = _constants__WEBPACK_IMPORTED_MODULE_6__.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
            // Listen to the event
            if (manager) {
                manager.on(eventAlias, eventRegistrar.handleEvent);
            }
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) {
            this._toggleRecognizer(eventRegistrar.recognizerName, true);
        }
    }
    /**
     * Process the event deregistration for a single event + handler.
     */
    _removeEventHandler(event, handler) {
        if (typeof event !== 'string') {
            // If `event` is a map, call `off()` for each entry.
            for (const eventName in event) {
                this._removeEventHandler(eventName, event[eventName]);
            }
            return;
        }
        const { events } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = _constants__WEBPACK_IMPORTED_MODULE_6__.GESTURE_EVENT_ALIASES[event] || event;
        const eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
            return;
        }
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
            const { recognizerName } = eventRegistrar;
            // Disable recognizer if no more handlers are attached to its events
            let isRecognizerUsed = false;
            for (const eh of events.values()) {
                if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
                    isRecognizerUsed = true;
                    break;
                }
            }
            if (!isRecognizerUsed) {
                this._toggleRecognizer(recognizerName, false);
            }
        }
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EventManager": () => (/* reexport safe */ _event_manager__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _event_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-manager */ "./node_modules/mjolnir.js/dist/esm/event-manager.js");



/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ContextmenuInput)
/* harmony export */ });
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ "./node_modules/mjolnir.js/dist/esm/inputs/input.js");

const EVENT_TYPE = 'contextmenu';
class ContextmenuInput extends _input__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
            if (!this.options.enable) {
                return;
            }
            this.callback({
                type: EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
            });
        };
        element.addEventListener('contextmenu', this.handleEvent);
    }
    destroy() {
        this.element.removeEventListener('contextmenu', this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE) {
            this.options.enable = enabled;
        }
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/inputs/input.js":
/*!**********************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/inputs/input.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Input)
/* harmony export */ });
class Input {
    constructor(element, callback, options) {
        this.element = element;
        this.callback = callback;
        this.options = { enable: true, ...options };
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/inputs/key-input.js":
/*!**************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/inputs/key-input.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ KeyInput)
/* harmony export */ });
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ "./node_modules/mjolnir.js/dist/esm/inputs/input.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/mjolnir.js/dist/esm/constants.js");


const { KEY_EVENTS } = _constants__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPES;
const DOWN_EVENT_TYPE = 'keydown';
const UP_EVENT_TYPE = 'keyup';
class KeyInput extends _input__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
            // Ignore if focused on text input
            const targetElement = (event.target || event.srcElement);
            if ((targetElement.tagName === 'INPUT' && targetElement.type === 'text') ||
                targetElement.tagName === 'TEXTAREA') {
                return;
            }
            if (this.enableDownEvent && event.type === 'keydown') {
                this.callback({
                    type: DOWN_EVENT_TYPE,
                    srcEvent: event,
                    key: event.key,
                    target: event.target
                });
            }
            if (this.enableUpEvent && event.type === 'keyup') {
                this.callback({
                    type: UP_EVENT_TYPE,
                    srcEvent: event,
                    key: event.key,
                    target: event.target
                });
            }
        };
        this.enableDownEvent = this.options.enable;
        this.enableUpEvent = this.options.enable;
        this.events = (this.options.events || []).concat(KEY_EVENTS);
        element.tabIndex = this.options.tabIndex || 0;
        element.style.outline = 'none';
        this.events.forEach(event => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === DOWN_EVENT_TYPE) {
            this.enableDownEvent = enabled;
        }
        if (eventType === UP_EVENT_TYPE) {
            this.enableUpEvent = enabled;
        }
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/inputs/move-input.js":
/*!***************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/inputs/move-input.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MoveInput)
/* harmony export */ });
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ "./node_modules/mjolnir.js/dist/esm/inputs/input.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/mjolnir.js/dist/esm/constants.js");


const { MOUSE_EVENTS } = _constants__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPES;
const MOVE_EVENT_TYPE = 'pointermove';
const OVER_EVENT_TYPE = 'pointerover';
const OUT_EVENT_TYPE = 'pointerout';
const ENTER_EVENT_TYPE = 'pointerenter';
const LEAVE_EVENT_TYPE = 'pointerleave';
/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */
class MoveInput extends _input__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
            this.handleOverEvent(event);
            this.handleOutEvent(event);
            this.handleEnterEvent(event);
            this.handleLeaveEvent(event);
            this.handleMoveEvent(event);
        };
        this.pressed = false;
        const { enable } = this.options;
        this.enableMoveEvent = enable;
        this.enableLeaveEvent = enable;
        this.enableEnterEvent = enable;
        this.enableOutEvent = enable;
        this.enableOverEvent = enable;
        this.events = (this.options.events || []).concat(MOUSE_EVENTS);
        this.events.forEach(event => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === MOVE_EVENT_TYPE) {
            this.enableMoveEvent = enabled;
        }
        if (eventType === OVER_EVENT_TYPE) {
            this.enableOverEvent = enabled;
        }
        if (eventType === OUT_EVENT_TYPE) {
            this.enableOutEvent = enabled;
        }
        if (eventType === ENTER_EVENT_TYPE) {
            this.enableEnterEvent = enabled;
        }
        if (eventType === LEAVE_EVENT_TYPE) {
            this.enableLeaveEvent = enabled;
        }
    }
    handleOverEvent(event) {
        if (this.enableOverEvent) {
            if (event.type === 'mouseover') {
                this._emit(OVER_EVENT_TYPE, event);
            }
        }
    }
    handleOutEvent(event) {
        if (this.enableOutEvent) {
            if (event.type === 'mouseout') {
                this._emit(OUT_EVENT_TYPE, event);
            }
        }
    }
    handleEnterEvent(event) {
        if (this.enableEnterEvent) {
            if (event.type === 'mouseenter') {
                this._emit(ENTER_EVENT_TYPE, event);
            }
        }
    }
    handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
            if (event.type === 'mouseleave') {
                this._emit(LEAVE_EVENT_TYPE, event);
            }
        }
    }
    handleMoveEvent(event) {
        if (this.enableMoveEvent) {
            switch (event.type) {
                case 'mousedown':
                    if (event.button >= 0) {
                        // Button is down
                        this.pressed = true;
                    }
                    break;
                case 'mousemove':
                    // Move events use `which` to track the button being pressed
                    if (event.which === 0) {
                        // Button is not down
                        this.pressed = false;
                    }
                    if (!this.pressed) {
                        // Drag events are emitted by hammer already
                        // we just need to emit the move event on hover
                        this._emit(MOVE_EVENT_TYPE, event);
                    }
                    break;
                case 'mouseup':
                    this.pressed = false;
                    break;
                default:
            }
        }
    }
    _emit(type, event) {
        this.callback({
            type,
            center: {
                x: event.clientX,
                y: event.clientY
            },
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
        });
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js":
/*!****************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WheelInput)
/* harmony export */ });
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./input */ "./node_modules/mjolnir.js/dist/esm/inputs/input.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./node_modules/mjolnir.js/dist/esm/constants.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/globals */ "./node_modules/mjolnir.js/dist/esm/utils/globals.js");



const firefox = _utils_globals__WEBPACK_IMPORTED_MODULE_2__.userAgent.indexOf('firefox') !== -1;
const { WHEEL_EVENTS } = _constants__WEBPACK_IMPORTED_MODULE_1__.INPUT_EVENT_TYPES;
const EVENT_TYPE = 'wheel';
// Constants for normalizing input delta
const WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const WHEEL_DELTA_PER_LINE = 40;
// Slow down zoom if shift key is held for more precise zooming
const SHIFT_MULTIPLIER = 0.25;
class WheelInput extends _input__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(element, callback, options) {
        super(element, callback, options);
        /* eslint-disable complexity, max-statements */
        this.handleEvent = (event) => {
            if (!this.options.enable) {
                return;
            }
            let value = event.deltaY;
            if (_utils_globals__WEBPACK_IMPORTED_MODULE_2__.window.WheelEvent) {
                // Firefox doubles the values on retina screens...
                if (firefox && event.deltaMode === _utils_globals__WEBPACK_IMPORTED_MODULE_2__.window.WheelEvent.DOM_DELTA_PIXEL) {
                    value /= _utils_globals__WEBPACK_IMPORTED_MODULE_2__.window.devicePixelRatio;
                }
                if (event.deltaMode === _utils_globals__WEBPACK_IMPORTED_MODULE_2__.window.WheelEvent.DOM_DELTA_LINE) {
                    value *= WHEEL_DELTA_PER_LINE;
                }
            }
            if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
                // This one is definitely a mouse wheel event.
                // Normalize this value to match trackpad.
                value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
            }
            if (event.shiftKey && value) {
                value = value * SHIFT_MULTIPLIER;
            }
            this.callback({
                type: EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                delta: -value,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
            });
        };
        this.events = (this.options.events || []).concat(WHEEL_EVENTS);
        this.events.forEach(event => element.addEventListener(event, this.handleEvent, _utils_globals__WEBPACK_IMPORTED_MODULE_2__.passiveSupported ? { passive: false } : false));
    }
    destroy() {
        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE) {
            this.options.enable = enabled;
        }
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/utils/event-registrar.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EventRegistrar)
/* harmony export */ });
/* harmony import */ var _event_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-utils */ "./node_modules/mjolnir.js/dist/esm/utils/event-utils.js");

const DEFAULT_OPTIONS = {
    srcElement: 'root',
    priority: 0
};
class EventRegistrar {
    constructor(eventManager) {
        /**
         * Handles hammerjs event
         */
        this.handleEvent = (event) => {
            if (this.isEmpty()) {
                return;
            }
            const mjolnirEvent = this._normalizeEvent(event);
            let target = event.srcEvent.target;
            while (target && target !== mjolnirEvent.rootElement) {
                this._emit(mjolnirEvent, target);
                if (mjolnirEvent.handled) {
                    return;
                }
                target = target.parentNode;
            }
            this._emit(mjolnirEvent, 'root');
        };
        this.eventManager = eventManager;
        this.handlers = [];
        // Element -> handler map
        this.handlersByElement = new Map();
        this._active = false;
    }
    // Returns true if there are no non-passive handlers
    isEmpty() {
        return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
        const { handlers, handlersByElement } = this;
        let opts = DEFAULT_OPTIONS;
        if (typeof options === 'string' || (options && options.addEventListener)) {
            // is DOM element, backward compatibility
            // @ts-ignore
            opts = { ...DEFAULT_OPTIONS, srcElement: options };
        }
        else if (options) {
            opts = { ...DEFAULT_OPTIONS, ...options };
        }
        let entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
            entries = [];
            handlersByElement.set(opts.srcElement, entries);
        }
        const entry = {
            type,
            handler,
            srcElement: opts.srcElement,
            priority: opts.priority
        };
        if (once) {
            entry.once = true;
        }
        if (passive) {
            entry.passive = true;
        }
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        // Sort handlers by descending priority
        // Handlers with the same priority are excuted in the order of registration
        let insertPosition = entries.length - 1;
        while (insertPosition >= 0) {
            if (entries[insertPosition].priority >= entry.priority) {
                break;
            }
            insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
        const { handlers, handlersByElement } = this;
        for (let i = handlers.length - 1; i >= 0; i--) {
            const entry = handlers[i];
            if (entry.type === type && entry.handler === handler) {
                handlers.splice(i, 1);
                const entries = handlersByElement.get(entry.srcElement);
                entries.splice(entries.indexOf(entry), 1);
                if (entries.length === 0) {
                    handlersByElement.delete(entry.srcElement);
                }
            }
        }
        this._active = handlers.some(entry => !entry.passive);
    }
    /**
     * Invoke handlers on a particular element
     */
    _emit(event, srcElement) {
        const entries = this.handlersByElement.get(srcElement);
        if (entries) {
            let immediatePropagationStopped = false;
            // Prevents the current event from bubbling up
            const stopPropagation = () => {
                event.handled = true;
            };
            // Prevent any remaining listeners from being called
            const stopImmediatePropagation = () => {
                event.handled = true;
                immediatePropagationStopped = true;
            };
            const entriesToRemove = [];
            for (let i = 0; i < entries.length; i++) {
                const { type, handler, once } = entries[i];
                handler({
                    ...event,
                    // @ts-ignore
                    type,
                    stopPropagation,
                    stopImmediatePropagation
                });
                if (once) {
                    entriesToRemove.push(entries[i]);
                }
                if (immediatePropagationStopped) {
                    break;
                }
            }
            for (let i = 0; i < entriesToRemove.length; i++) {
                const { type, handler } = entriesToRemove[i];
                this.remove(type, handler);
            }
        }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */
    _normalizeEvent(event) {
        const rootElement = this.eventManager.getElement();
        return {
            ...event,
            ...(0,_event_utils__WEBPACK_IMPORTED_MODULE_0__.whichButtons)(event),
            ...(0,_event_utils__WEBPACK_IMPORTED_MODULE_0__.getOffsetPosition)(event, rootElement),
            preventDefault: () => {
                event.srcEvent.preventDefault();
            },
            stopImmediatePropagation: null,
            stopPropagation: null,
            handled: false,
            rootElement
        };
    }
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/utils/event-utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/utils/event-utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getOffsetPosition": () => (/* binding */ getOffsetPosition),
/* harmony export */   "whichButtons": () => (/* binding */ whichButtons)
/* harmony export */ });
/* Constants */
const DOWN_EVENT = 1;
const MOVE_EVENT = 2;
const UP_EVENT = 4;
const MOUSE_EVENTS = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
};
// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
const MOUSE_EVENT_WHICH_LEFT = 1;
const MOUSE_EVENT_WHICH_MIDDLE = 2;
const MOUSE_EVENT_WHICH_RIGHT = 3;
// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
const MOUSE_EVENT_BUTTON_LEFT = 0;
const MOUSE_EVENT_BUTTON_MIDDLE = 1;
const MOUSE_EVENT_BUTTON_RIGHT = 2;
// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
const MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
 * Extract the involved mouse button
 */
function whichButtons(event) {
    const eventType = MOUSE_EVENTS[event.srcEvent.type];
    if (!eventType) {
        // Not a mouse evet
        return null;
    }
    const { buttons, button, which } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (
    // button is up, need to find out which one was pressed before
    eventType === UP_EVENT ||
        // moving but does not support `buttons` API
        (eventType === MOVE_EVENT && !Number.isFinite(buttons))) {
        leftButton = which === MOUSE_EVENT_WHICH_LEFT;
        middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
        rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
    }
    else if (eventType === MOVE_EVENT) {
        leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
        middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
        rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    }
    else if (eventType === DOWN_EVENT) {
        leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
        middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
        rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
}
/**
 * Calculate event position relative to the root element
 */
function getOffsetPosition(event, rootElement) {
    const center = event.center;
    // `center` is a hammer.js event property
    if (!center) {
        // Not a gestural event
        return null;
    }
    const rect = rootElement.getBoundingClientRect();
    // Fix scale for map affected by a CSS transform.
    // See https://stackoverflow.com/a/26893663/3528533
    const scaleX = rect.width / rootElement.offsetWidth || 1;
    const scaleY = rect.height / rootElement.offsetHeight || 1;
    // Calculate center relative to the root element
    const offsetCenter = {
        x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
        y: (center.y - rect.top - rootElement.clientTop) / scaleY
    };
    return { center, offsetCenter };
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/utils/globals.js":
/*!***********************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/utils/globals.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "document": () => (/* binding */ document_),
/* harmony export */   "global": () => (/* binding */ global_),
/* harmony export */   "passiveSupported": () => (/* binding */ passiveSupported),
/* harmony export */   "userAgent": () => (/* binding */ userAgent),
/* harmony export */   "window": () => (/* binding */ window_)
/* harmony export */ });
// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global'
/* global window, global, document, navigator */
const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
const window_ = typeof window !== 'undefined' ? window : __webpack_require__.g;
const global_ = typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : window;
const document_ = typeof document !== 'undefined' ? document : {};

/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */
let passiveSupported = false;
/* eslint-disable accessor-pairs, no-empty */
try {
    const options = {
        // This function will be called when the browser
        // attempts to access the passive property.
        get passive() {
            passiveSupported = true;
            return true;
        }
    };
    window_.addEventListener('test', null, options);
    window_.removeEventListener('test', null);
}
catch (err) {
    passiveSupported = false;
}



/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js":
/*!********************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "enhanceMouseInput": () => (/* binding */ enhanceMouseInput),
/* harmony export */   "enhancePointerEventInput": () => (/* binding */ enhancePointerEventInput)
/* harmony export */ });
/**
 * This file contains overrides the default
 * hammer.js functions to add our own utility
 */
/* eslint-disable */
/* Hammer.js constants */
const INPUT_START = 1;
const INPUT_MOVE = 2;
const INPUT_END = 4;
const MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};
/**
 * Helper function that returns true if any element in an array meets given criteria.
 * Because older browsers do not support `Array.prototype.some`
 * @params array {Array}
 * @params predict {Function}
 */
function some(array, predict) {
    for (let i = 0; i < array.length; i++) {
        if (predict(array[i])) {
            return true;
        }
    }
    return false;
}
/* eslint-disable no-invalid-this */
function enhancePointerEventInput(PointerEventInput) {
    const oldHandler = PointerEventInput.prototype.handler;
    // overrides PointerEventInput.handler to accept right mouse button
    PointerEventInput.prototype.handler = function handler(ev) {
        const store = this.store;
        // Allow non-left mouse buttons through
        if (ev.button > 0 && ev.type === 'pointerdown') {
            if (!some(store, e => e.pointerId === ev.pointerId)) {
                store.push(ev);
            }
        }
        oldHandler.call(this, ev);
    };
}
// overrides MouseInput.handler to accept right mouse button
function enhanceMouseInput(MouseInput) {
    MouseInput.prototype.handler = function handler(ev) {
        let eventType = MOUSE_INPUT_MAP[ev.type];
        // on start we want to have the mouse button down
        if (eventType & INPUT_START && ev.button >= 0) {
            this.pressed = true;
        }
        if (eventType & INPUT_MOVE && ev.which === 0) {
            eventType = INPUT_END;
        }
        // mouse must be down
        if (!this.pressed) {
            return;
        }
        if (eventType & INPUT_END) {
            this.pressed = false;
        }
        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: 'mouse',
            srcEvent: ev
        });
    };
}


/***/ }),

/***/ "./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Manager": () => (/* binding */ Manager),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hammerjs */ "./node_modules/hammerjs/hammer.js");
/* harmony import */ var hammerjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hammerjs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _hammer_overrides__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hammer-overrides */ "./node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js");


(0,_hammer_overrides__WEBPACK_IMPORTED_MODULE_1__.enhancePointerEventInput)(hammerjs__WEBPACK_IMPORTED_MODULE_0__.PointerEventInput);
(0,_hammer_overrides__WEBPACK_IMPORTED_MODULE_1__.enhanceMouseInput)(hammerjs__WEBPACK_IMPORTED_MODULE_0__.MouseInput);
const Manager = hammerjs__WEBPACK_IMPORTED_MODULE_0__.Manager;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hammerjs__WEBPACK_IMPORTED_MODULE_0__);


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_deck_gl_core_dist_esm_index_js.5fd2dc54e62d2276d6c3.js.map